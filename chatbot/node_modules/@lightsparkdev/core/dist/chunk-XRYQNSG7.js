// src/utils/base64.ts
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var Base64 = {
  btoa: (input = "") => {
    const str = input;
    let output = "";
    for (let block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = "=", i % 1); output += map.charAt(63 & block >> 8 - i % 1 * 8)) {
      charCode = str.charCodeAt(i += 3 / 4);
      if (charCode > 255) {
        throw new Error(
          "'btoa' failed: The string to be encoded contains characters outside of the Latin1 range."
        );
      }
      block = block << 8 | charCode;
    }
    return output;
  },
  atob: (input = "") => {
    const str = input.replace(/=+$/, "");
    let output = "";
    if (str.length % 4 == 1) {
      throw new Error(
        "'atob' failed: The string to be decoded is not correctly encoded."
      );
    }
    for (let bc = 0, bs = 0, buffer, i = 0; buffer = str.charAt(i++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
      buffer = chars.indexOf(buffer);
    }
    return output;
  }
};
var b64decode = (encoded) => {
  return Uint8Array.from(Base64.atob(encoded), (c) => c.charCodeAt(0));
};
var urlsafe_b64decode = (encoded) => {
  return b64decode(encoded.replace(/_/g, "/").replace(/-/g, "+"));
};
var b64encode = (data) => {
  return Base64.btoa(
    String.fromCharCode.apply(null, Array.from(new Uint8Array(data)))
  );
};

// src/utils/environment.ts
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var isTest = isNode && process.env.NODE_ENV === "test";

// src/utils/hex.ts
var bytesToHex = (bytes) => {
  return bytes.reduce((acc, byte) => {
    return acc += ("0" + byte.toString(16)).slice(-2);
  }, "");
};
var hexToBytes = (hex) => {
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.substr(c, 2), 16));
  }
  return Uint8Array.from(bytes);
};

// src/utils/createHash.ts
async function createSha256Hash(data, asHex) {
  if (isBrowser) {
    const source = typeof data === "string" ? new TextEncoder().encode(data) : data;
    const buffer = await window.crypto.subtle.digest("SHA-256", source);
    const arr = new Uint8Array(buffer);
    if (asHex) {
      return bytesToHex(arr);
    }
    return arr;
  } else {
    const { createHash } = await import("crypto");
    if (asHex) {
      const hexStr = createHash("sha256").update(data).digest("hex");
      return hexStr;
    }
    const buffer = createHash("sha256").update(data).digest();
    return new Uint8Array(buffer);
  }
}

// src/LightsparkException.ts
var LightsparkException = class extends Error {
  code;
  message;
  extraInfo;
  constructor(code, message, extraInfo) {
    super(message);
    this.code = code;
    this.message = message;
    this.extraInfo = extraInfo;
  }
};
var LightsparkException_default = LightsparkException;

// src/utils/locale.ts
function getCurrentLocale() {
  return Intl.NumberFormat().resolvedOptions().locale;
}

// src/utils/localeToCurrencyCodes.ts
var countryCodesToCurrencyCodes = {
  AD: "EUR",
  // AE: "AED",
  // AF: "AFN",
  // AG: "XCD",
  // AI: "XCD",
  // AL: "ALL",
  // AM: "AMD",
  // AO: "AOA",
  AR: "ARS",
  AS: "USD",
  AT: "EUR",
  AU: "AUD",
  // AW: "AWG",
  AX: "EUR",
  // AZ: "AZN",
  // BA: "BAM",
  // BB: "BBD",
  // BD: "BDT",
  BE: "EUR",
  // BF: "XOF",
  // BG: "BGN",
  // BH: "BHD",
  // BI: "BIF",
  // BJ: "XOF",
  BL: "EUR",
  // BM: "BMD",
  // BN: "BND",
  // BO: "BOB",
  BQ: "USD",
  BR: "BRL",
  // BS: "BSD",
  // BT: "BTN",
  // BV: "NOK",
  // BW: "BWP",
  // BY: "BYN",
  // BZ: "BZD",
  CA: "CAD",
  // CC: "AUD",
  // CD: "CDF",
  // CF: "XAF",
  // CG: "XAF",
  // CH: "CHF",
  // CI: "XOF",
  // CK: "NZD",
  // CL: "CLP",
  // CM: "XAF",
  // CN: "CNY",
  CO: "COP",
  // CR: "CRC",
  // CU: "CUP",
  // CV: "CVE",
  // CW: "ANG",
  // CX: "AUD",
  CY: "EUR",
  // CZ: "CZK",
  DE: "EUR",
  // DJ: "DJF",
  // DK: "DKK",
  // DM: "XCD",
  // DO: "DOP",
  // DZ: "DZD",
  EC: "USD",
  EE: "EUR",
  // EG: "EGP",
  // EH: "MAD",
  // ER: "ERN",
  ES: "EUR",
  // ET: "ETB",
  FI: "EUR",
  // FJ: "FJD",
  // FK: "FKP",
  FM: "USD",
  // FO: "DKK",
  FR: "EUR",
  // GA: "XAF",
  GB: "GBP",
  // GD: "XCD",
  // GE: "GEL",
  GF: "EUR",
  GG: "GBP",
  // GH: "GHS",
  // GI: "GIP",
  // GL: "DKK",
  // GM: "GMD",
  // GN: "GNF",
  GP: "EUR",
  // GQ: "XAF",
  GR: "EUR",
  GS: "GBP",
  // GT: "GTQ",
  GU: "USD",
  // GW: "XOF",
  // GY: "GYD",
  // HK: "HKD",
  // HM: "AUD",
  // HN: "HNL",
  // HR: "HRK",
  // HT: "HTG",
  // HU: "HUF",
  // ID: "IDR",
  IE: "EUR",
  // IL: "ILS",
  IM: "GBP",
  IN: "INR",
  IO: "USD",
  // IQ: "IQD",
  // IR: "IRR",
  // IS: "ISK",
  IT: "EUR",
  JE: "GBP",
  // JM: "JMD",
  // JO: "JOD",
  // JP: "JPY",
  // KE: "KES",
  // KG: "KGS",
  // KH: "KHR",
  // KI: "AUD",
  // KM: "KMF",
  // KN: "XCD",
  // KP: "KPW",
  // KR: "KRW",
  // KW: "KWD",
  // KY: "KYD",
  // KZ: "KZT",
  // LA: "LAK",
  // LB: "LBP",
  // LC: "XCD",
  // LI: "CHF",
  // LK: "LKR",
  // LR: "LRD",
  // LS: "LSL",
  LT: "EUR",
  LU: "EUR",
  LV: "EUR",
  // LY: "LYD",
  // MA: "MAD",
  MC: "EUR",
  // MD: "MDL",
  ME: "EUR",
  MF: "EUR",
  // MG: "MGA",
  MH: "USD",
  // MK: "MKD",
  // ML: "XOF",
  // MM: "MMK",
  // MN: "MNT",
  // MO: "MOP",
  MP: "USD",
  MQ: "EUR",
  // MR: "MRO",
  // MS: "XCD",
  MT: "EUR",
  // MU: "MUR",
  // MV: "MVR",
  // MW: "MWK",
  MX: "MXN",
  // MY: "MYR",
  // MZ: "MZN",
  // NA: "NAD",
  // NC: "XPF",
  // NE: "XOF",
  NF: "AUD",
  // NG: "NGN",
  // NI: "NIO",
  NL: "EUR",
  // NO: "NOK",
  // NP: "NPR",
  NR: "AUD",
  // NU: "NZD",
  // NZ: "NZD",
  // OM: "OMR",
  // PA: "PAB",
  // PE: "PEN",
  // PF: "XPF",
  // PG: "PGK",
  // PH: "PHP",
  // PK: "PKR",
  // PL: "PLN",
  PM: "EUR",
  // PN: "NZD",
  PR: "USD",
  // PS: "ILS",
  PT: "EUR",
  PW: "USD",
  // PY: "PYG",
  // QA: "QAR",
  RE: "EUR",
  // RO: "RON",
  // RS: "RSD",
  // RU: "RUB",
  // RW: "RWF",
  // SA: "SAR",
  // SB: "SBD",
  // SC: "SCR",
  // SD: "SDG",
  // SE: "SEK",
  // SG: "SGD",
  // SH: "SHP",
  SI: "EUR",
  // SJ: "NOK",
  SK: "EUR",
  // SL: "SLL",
  SM: "EUR",
  // SN: "XOF",
  // SO: "SOS",
  // SR: "SRD",
  // ST: "STD",
  // SV: "SVC",
  // SX: "ANG",
  // SY: "SYP",
  // SZ: "SZL",
  TC: "USD",
  // TD: "XAF",
  TF: "EUR",
  // TG: "XOF",
  // TH: "THB",
  // TJ: "TJS",
  // TK: "NZD",
  TL: "USD",
  // TM: "TMT",
  // TN: "TND",
  // TO: "TOP",
  // TR: "TRY",
  // TT: "TTD",
  TV: "AUD",
  // TW: "TWD",
  // TZ: "TZS",
  // UA: "UAH",
  // UG: "UGX",
  UM: "USD",
  US: "USD",
  // UY: "UYU",
  // UZ: "UZS",
  VA: "EUR",
  // VC: "XCD",
  // VE: "VEF",
  VG: "USD",
  VI: "USD",
  // VN: "VND",
  // VU: "VUV",
  // WF: "XPF",
  // WS: "WST",
  // YE: "YER",
  YT: "EUR"
  // ZA: "ZAR",
  // ZM: "ZMW",
  // ZW: "ZWL",
};
function getCountryCode(localeString) {
  let components = localeString.split("_");
  if (components.length === 2) {
    return components.pop();
  }
  components = localeString.split("-");
  if (components.length === 2) {
    return components.pop();
  }
  return localeString;
}
function localeToCurrencyCode(locale) {
  const countryCode = getCountryCode(locale);
  return countryCodesToCurrencyCodes[countryCode];
}

// src/utils/numbers.ts
function clamp(val, min, max) {
  return val > max ? max : val < min ? min : val;
}
function linearInterpolate(value, fromRangeStart, fromRangeEnd, toRangeStart, toRangeEnd) {
  const fromRangeMax = fromRangeEnd - fromRangeStart;
  const fromRangeVal = value - fromRangeStart;
  const toRangeMax = toRangeEnd - toRangeStart;
  const val = fromRangeVal / fromRangeMax * toRangeMax + toRangeStart;
  return clamp(
    val,
    Math.min(toRangeStart, toRangeEnd),
    Math.max(toRangeStart, toRangeEnd)
  );
}
function round(num, decimalPlaces = 0) {
  const p = Math.pow(10, decimalPlaces);
  const n = num * p * (1 + Number.EPSILON);
  return Math.round(n) / p;
}
function isNumber(value) {
  return typeof value === "number";
}

// src/utils/currency.ts
var defaultCurrencyCode = "USD";
var CurrencyUnit = {
  FUTURE_VALUE: "FUTURE_VALUE",
  BITCOIN: "BITCOIN",
  SATOSHI: "SATOSHI",
  MILLISATOSHI: "MILLISATOSHI",
  USD: "USD",
  NANOBITCOIN: "NANOBITCOIN",
  MICROBITCOIN: "MICROBITCOIN",
  MILLIBITCOIN: "MILLIBITCOIN",
  Bitcoin: "BITCOIN",
  Microbitcoin: "MICROBITCOIN",
  Millibitcoin: "MILLIBITCOIN",
  Millisatoshi: "MILLISATOSHI",
  Nanobitcoin: "NANOBITCOIN",
  Satoshi: "SATOSHI",
  Usd: "USD"
};
var CONVERSION_MAP = {
  [CurrencyUnit.BITCOIN]: {
    [CurrencyUnit.BITCOIN]: (v) => v,
    [CurrencyUnit.MICROBITCOIN]: (v) => v * 1e6,
    [CurrencyUnit.MILLIBITCOIN]: (v) => v * 1e3,
    [CurrencyUnit.MILLISATOSHI]: (v) => v * 1e11,
    [CurrencyUnit.NANOBITCOIN]: (v) => v * 1e9,
    [CurrencyUnit.SATOSHI]: (v) => v * 1e8,
    [CurrencyUnit.USD]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v * centsPerBtc, 2)
    )
  },
  [CurrencyUnit.MICROBITCOIN]: {
    [CurrencyUnit.BITCOIN]: (v) => v / 1e6,
    [CurrencyUnit.MICROBITCOIN]: (v) => v,
    [CurrencyUnit.MILLIBITCOIN]: (v) => v / 1e3,
    [CurrencyUnit.MILLISATOSHI]: (v) => v * 1e5,
    [CurrencyUnit.NANOBITCOIN]: (v) => v * 1e3,
    [CurrencyUnit.SATOSHI]: (v) => v * 100,
    [CurrencyUnit.USD]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e6 * centsPerBtc)
    )
  },
  [CurrencyUnit.MILLIBITCOIN]: {
    [CurrencyUnit.BITCOIN]: (v) => v / 1e3,
    [CurrencyUnit.MICROBITCOIN]: (v) => v * 1e3,
    [CurrencyUnit.MILLIBITCOIN]: (v) => v,
    [CurrencyUnit.MILLISATOSHI]: (v) => v * 1e8,
    [CurrencyUnit.NANOBITCOIN]: (v) => v * 1e6,
    [CurrencyUnit.SATOSHI]: (v) => v * 1e5,
    [CurrencyUnit.USD]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e3 * centsPerBtc)
    )
  },
  [CurrencyUnit.MILLISATOSHI]: {
    [CurrencyUnit.BITCOIN]: (v) => v / 1e11,
    [CurrencyUnit.MICROBITCOIN]: (v) => v / 1e5,
    [CurrencyUnit.MILLIBITCOIN]: (v) => v / 1e8,
    [CurrencyUnit.MILLISATOSHI]: (v) => v,
    [CurrencyUnit.NANOBITCOIN]: (v) => v / 100,
    [CurrencyUnit.SATOSHI]: (v) => v / 1e3,
    [CurrencyUnit.USD]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e11 * centsPerBtc)
    )
  },
  [CurrencyUnit.NANOBITCOIN]: {
    [CurrencyUnit.BITCOIN]: (v) => v / 1e9,
    [CurrencyUnit.MICROBITCOIN]: (v) => v / 1e3,
    [CurrencyUnit.MILLIBITCOIN]: (v) => v / 1e6,
    [CurrencyUnit.MILLISATOSHI]: (v) => v * 100,
    [CurrencyUnit.NANOBITCOIN]: (v) => v,
    [CurrencyUnit.SATOSHI]: (v) => v / 10,
    [CurrencyUnit.USD]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e9 * centsPerBtc)
    )
  },
  [CurrencyUnit.SATOSHI]: {
    [CurrencyUnit.BITCOIN]: (v) => v / 1e8,
    [CurrencyUnit.MICROBITCOIN]: (v) => v / 100,
    [CurrencyUnit.MILLIBITCOIN]: (v) => v / 1e5,
    [CurrencyUnit.MILLISATOSHI]: (v) => v * 1e3,
    [CurrencyUnit.NANOBITCOIN]: (v) => v * 10,
    [CurrencyUnit.SATOSHI]: (v) => v,
    [CurrencyUnit.USD]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e8 * centsPerBtc)
    )
  },
  [CurrencyUnit.USD]: {
    [CurrencyUnit.BITCOIN]: (v, centsPerBtc = 1) => v / centsPerBtc,
    [CurrencyUnit.MICROBITCOIN]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e6,
    [CurrencyUnit.MILLIBITCOIN]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e3,
    [CurrencyUnit.MILLISATOSHI]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e11,
    [CurrencyUnit.NANOBITCOIN]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e9,
    [CurrencyUnit.SATOSHI]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e8,
    [CurrencyUnit.USD]: (v) => v
  }
};
function convertCurrencyAmountValue(fromUnit, toUnit, amount, centsPerBtc = 1) {
  if (fromUnit === CurrencyUnit.FUTURE_VALUE || toUnit === CurrencyUnit.FUTURE_VALUE) {
    throw new LightsparkException_default("CurrencyError", `Unsupported CurrencyUnit.`);
  }
  if (fromUnit === toUnit) {
    return amount;
  }
  const conversionFn = CONVERSION_MAP[fromUnit][toUnit];
  if (!conversionFn) {
    throw new LightsparkException_default(
      "CurrencyError",
      `Cannot convert from ${fromUnit} to ${toUnit}`
    );
  }
  return conversionFn(amount, centsPerBtc);
}
var convertCurrencyAmount = (from, toUnit) => {
  const value = convertCurrencyAmountValue(
    from.originalUnit,
    toUnit,
    from.originalValue
  );
  return {
    ...from,
    preferredCurrencyUnit: toUnit,
    preferredCurrencyValueApprox: value,
    preferredCurrencyValueRounded: value
  };
};
function isCurrencyAmountObj(arg) {
  return typeof arg === "object" && arg !== null && "value" in arg && "unit" in arg;
}
function isSDKCurrencyAmount(arg) {
  return typeof arg === "object" && arg !== null && /* We can expect all SDK CurrencyAmount types to always have these exact properties: */
  "originalValue" in arg && "originalUnit" in arg && "preferredCurrencyUnit" in arg && "preferredCurrencyValueRounded" in arg && "preferredCurrencyValueApprox" in arg;
}
function asNumber(value) {
  if (typeof value === "string") {
    return Number(value);
  }
  return value || 0;
}
function getCurrencyAmount(currencyAmountArg) {
  let value = 0;
  let unit = void 0;
  if (isSDKCurrencyAmount(currencyAmountArg)) {
    value = currencyAmountArg.originalValue;
    unit = currencyAmountArg.originalUnit;
  } else if (isCurrencyAmountObj(currencyAmountArg)) {
    value = asNumber(currencyAmountArg.value);
    unit = currencyAmountArg.unit;
  }
  return {
    value: asNumber(value),
    unit: unit || CurrencyUnit.SATOSHI
  };
}
function mapCurrencyAmount(currencyAmountArg, centsPerBtc = 1) {
  const { value, unit } = getCurrencyAmount(currencyAmountArg);
  const convert = convertCurrencyAmountValue;
  const sats = convert(unit, CurrencyUnit.SATOSHI, value, centsPerBtc);
  const btc = convert(unit, CurrencyUnit.BITCOIN, value, centsPerBtc);
  const msats = convert(unit, CurrencyUnit.MILLISATOSHI, value, centsPerBtc);
  const usd = convert(unit, CurrencyUnit.USD, value, centsPerBtc);
  const mibtc = convert(unit, CurrencyUnit.MICROBITCOIN, value, centsPerBtc);
  const mlbtc = convert(unit, CurrencyUnit.MILLIBITCOIN, value, centsPerBtc);
  const nbtc = convert(unit, CurrencyUnit.NANOBITCOIN, value, centsPerBtc);
  const mapWithCurrencyUnits = {
    [CurrencyUnit.BITCOIN]: btc,
    [CurrencyUnit.SATOSHI]: sats,
    [CurrencyUnit.MILLISATOSHI]: msats,
    [CurrencyUnit.USD]: usd,
    [CurrencyUnit.MICROBITCOIN]: mibtc,
    [CurrencyUnit.MILLIBITCOIN]: mlbtc,
    [CurrencyUnit.NANOBITCOIN]: nbtc,
    [CurrencyUnit.FUTURE_VALUE]: NaN,
    formatted: {
      [CurrencyUnit.BITCOIN]: formatCurrencyStr({
        value: btc,
        unit: CurrencyUnit.BITCOIN
      }),
      [CurrencyUnit.SATOSHI]: formatCurrencyStr({
        value: sats,
        unit: CurrencyUnit.SATOSHI
      }),
      [CurrencyUnit.MILLISATOSHI]: formatCurrencyStr({
        value: msats,
        unit: CurrencyUnit.MILLISATOSHI
      }),
      [CurrencyUnit.MICROBITCOIN]: formatCurrencyStr({
        value: mibtc,
        unit: CurrencyUnit.MICROBITCOIN
      }),
      [CurrencyUnit.MILLIBITCOIN]: formatCurrencyStr({
        value: mlbtc,
        unit: CurrencyUnit.MILLIBITCOIN
      }),
      [CurrencyUnit.NANOBITCOIN]: formatCurrencyStr({
        value: nbtc,
        unit: CurrencyUnit.NANOBITCOIN
      }),
      [CurrencyUnit.USD]: formatCurrencyStr({
        value: usd,
        unit: CurrencyUnit.USD
      }),
      [CurrencyUnit.FUTURE_VALUE]: "-"
    }
  };
  return {
    ...mapWithCurrencyUnits,
    btc,
    sats,
    msats,
    isZero: msats === 0,
    isLessThan: (other) => {
      if (isNumber(other)) {
        return msats < other;
      }
      if (isCurrencyAmountObj(other)) {
        other = mapCurrencyAmount(other);
      }
      return msats < other.msats;
    },
    isGreaterThan: (other) => {
      if (isNumber(other)) {
        return msats > other;
      }
      if (isCurrencyAmountObj(other)) {
        other = mapCurrencyAmount(other);
      }
      return msats > other.msats;
    },
    isEqualTo: (other) => {
      if (isNumber(other)) {
        return msats === other;
      }
      if (isCurrencyAmountObj(other)) {
        other = mapCurrencyAmount(other);
      }
      return msats === other.msats;
    },
    formatted: {
      ...mapWithCurrencyUnits.formatted,
      btc: mapWithCurrencyUnits.formatted[CurrencyUnit.BITCOIN],
      sats: mapWithCurrencyUnits.formatted[CurrencyUnit.SATOSHI],
      msats: mapWithCurrencyUnits.formatted[CurrencyUnit.MILLISATOSHI]
    },
    type: "CurrencyMap"
  };
}
var isCurrencyMap = (currencyMap) => typeof currencyMap === "object" && currencyMap !== null && "type" in currencyMap && typeof currencyMap.type === "string" && currencyMap.type === "CurrencyMap";
var abbrCurrencyUnit = (unit) => {
  switch (unit) {
    case CurrencyUnit.BITCOIN:
      return "BTC";
    case CurrencyUnit.SATOSHI:
      return "SAT";
    case CurrencyUnit.MILLISATOSHI:
      return "MSAT";
    case CurrencyUnit.USD:
      return "USD";
  }
  return "Unsupported CurrencyUnit";
};
var defaultOptions = {
  /* undefined indicates to use default precision for unit defined below */
  precision: void 0,
  compact: false,
  showBtcSymbol: false
};
function formatCurrencyStr(amount, options) {
  const { precision, compact, showBtcSymbol } = {
    ...defaultOptions,
    ...options
  };
  const currencyAmount = getCurrencyAmount(amount);
  let { value: num } = currencyAmount;
  const { unit } = currencyAmount;
  if (unit === CurrencyUnit.USD) {
    num = num / 100;
  }
  function getDefaultMaxFractionDigits(defaultDigits, fullPrecisionDigits) {
    let digits = defaultDigits;
    if (precision === "full") {
      digits = fullPrecisionDigits;
    } else if (typeof precision === "number") {
      digits = precision;
    } else if (compact) {
      digits = 1;
    }
    return digits;
  }
  const symbol = !showBtcSymbol ? "" : unit === CurrencyUnit.BITCOIN ? "\uE903" : unit === CurrencyUnit.SATOSHI ? "\uE902" : "";
  const currentLocale = getCurrentLocale();
  switch (unit) {
    case CurrencyUnit.BITCOIN:
      return `${symbol}${num.toLocaleString(currentLocale, {
        notation: compact ? "compact" : void 0,
        maximumFractionDigits: getDefaultMaxFractionDigits(4, 8)
      })}`;
    case CurrencyUnit.SATOSHI:
      return `${symbol}${num.toLocaleString(currentLocale, {
        notation: compact ? "compact" : void 0,
        maximumFractionDigits: getDefaultMaxFractionDigits(0, 3)
      })}`;
    case CurrencyUnit.MILLISATOSHI:
    case CurrencyUnit.MICROBITCOIN:
    case CurrencyUnit.MILLIBITCOIN:
    case CurrencyUnit.NANOBITCOIN:
    default:
      return `${symbol}${num.toLocaleString(currentLocale, {
        notation: compact ? "compact" : void 0,
        maximumFractionDigits: getDefaultMaxFractionDigits(0, 0)
      })}`;
    case CurrencyUnit.USD:
      return num.toLocaleString(currentLocale, {
        style: "currency",
        currency: defaultCurrencyCode,
        notation: compact ? "compact" : void 0,
        maximumFractionDigits: getDefaultMaxFractionDigits(2, 2)
      });
  }
}
function separateCurrencyStrParts(currencyStr) {
  const symbol = currencyStr.replace(/[0-9\s\u00a0.,]/g, "");
  const amount = currencyStr.replace(/[^\d.,-]/g, "");
  return { symbol, amount };
}
function localeToCurrencySymbol(locale) {
  const currencyCode = localeToCurrencyCode(locale);
  const formatted = new Intl.NumberFormat(locale, {
    style: "currency",
    currency: currencyCode,
    useGrouping: false,
    // to avoid thousands separators
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(0);
  const { symbol } = separateCurrencyStrParts(formatted);
  return symbol;
}

// src/utils/errors.ts
var isError = (e) => {
  return Boolean(
    typeof e === "object" && e !== null && "name" in e && typeof e.name === "string" && "message" in e && typeof e.message === "string" && "stack" in e && (!e.stack || typeof e.stack === "string")
  );
};
var isErrorWithMessage = (e) => {
  return Boolean(
    typeof e === "object" && e !== null && "message" in e && typeof e.message === "string"
  );
};
var getErrorMsg = (e) => {
  return isErrorWithMessage(e) ? e.message : "Unknown error";
};
var isErrorMsg = (e, msg) => {
  if (isError(e)) {
    return e.message === msg;
  }
  return false;
};
function errorToJSON(err) {
  if (!err) {
    return null;
  }
  if (typeof err === "object" && "toJSON" in err && typeof err.toJSON === "function") {
    return err.toJSON();
  }
  if (typeof err === "object" && /* This happens for certain errors like DOMException: */
  Object.getOwnPropertyNames(err).length === 0 && "message" in err && typeof err.message === "string") {
    return { message: err.message };
  }
  return JSON.parse(
    JSON.stringify(err, Object.getOwnPropertyNames(err))
  );
}

// src/utils/localStorage.ts
function getLocalStorageConfigItem(key) {
  return getLocalStorageBoolean(key);
}
function getLocalStorageBoolean(key) {
  try {
    return localStorage.getItem(key) === "1";
  } catch (e) {
    return false;
  }
}
function setLocalStorageBoolean(key, value) {
  try {
    localStorage.setItem(key, value ? "1" : "0");
  } catch (e) {
  }
}
var deleteLocalStorageItem = (key) => {
  try {
    localStorage.removeItem(key);
  } catch (e) {
  }
};

// ../../node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../../node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../../node_modules/lodash-es/_Symbol.js
var Symbol = root_default.Symbol;
var Symbol_default = Symbol;

// ../../node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../../node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../../node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../../node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// ../../node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// src/utils/sleep.ts
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// src/utils/pollUntil.ts
function getDefaultMaxPollsError() {
  return new Error("pollUntil: Max polls reached");
}
async function pollUntil(asyncFn, getValue, maxPolls = 60, pollIntervalMs = 500, ignoreErrors = false, getMaxPollsError = getDefaultMaxPollsError) {
  let polls = 0;
  let stopPolling = false;
  let result = {
    stopPolling: false,
    value: null
  };
  while (!stopPolling) {
    polls += 1;
    if (polls > maxPolls) {
      stopPolling = true;
      const maxPollsError = getMaxPollsError(maxPolls);
      throw maxPollsError;
    }
    try {
      const asyncResult = await asyncFn();
      result = getValue(asyncResult, {
        stopPolling: false,
        value: null
      });
      if (result.stopPolling) {
        stopPolling = true;
      }
    } catch (e) {
      if (!ignoreErrors || isFunction_default(ignoreErrors) && !ignoreErrors(e)) {
        stopPolling = true;
        throw e;
      }
    }
    await sleep(pollIntervalMs);
  }
  return result.value;
}

// src/utils/strings.ts
function lsidToUUID(lsid) {
  return lsid.replace(/^[^:]+:(.*)$/, "$1");
}

// src/utils/typeGuards.ts
function isUint8Array(variable) {
  return variable instanceof Uint8Array;
}

// src/utils/types.ts
var isType = (typename) => (node) => {
  return node?.__typename === typename;
};
function notNullUndefined(value) {
  return value !== null && value !== void 0;
}

export {
  LightsparkException_default,
  isBrowser,
  isNode,
  isTest,
  b64decode,
  urlsafe_b64decode,
  b64encode,
  bytesToHex,
  hexToBytes,
  createSha256Hash,
  getCurrentLocale,
  countryCodesToCurrencyCodes,
  localeToCurrencyCode,
  clamp,
  linearInterpolate,
  round,
  isNumber,
  defaultCurrencyCode,
  CurrencyUnit,
  convertCurrencyAmountValue,
  convertCurrencyAmount,
  isCurrencyAmountObj,
  isSDKCurrencyAmount,
  mapCurrencyAmount,
  isCurrencyMap,
  abbrCurrencyUnit,
  formatCurrencyStr,
  separateCurrencyStrParts,
  localeToCurrencySymbol,
  isError,
  isErrorWithMessage,
  getErrorMsg,
  isErrorMsg,
  errorToJSON,
  getLocalStorageConfigItem,
  getLocalStorageBoolean,
  setLocalStorageBoolean,
  deleteLocalStorageItem,
  sleep,
  pollUntil,
  lsidToUUID,
  isUint8Array,
  isType,
  notNullUndefined
};
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
