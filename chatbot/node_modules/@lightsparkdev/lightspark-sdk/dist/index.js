import {
  assertValidBitcoinNetwork,
  getBitcoinNetworkOrThrow,
  isBitcoinNetwork
} from "./chunk-D32EWIPX.js";
import {
  Account_default,
  ApiTokenFromJson,
  ChannelStatus_default,
  Channel_default,
  ComplianceProvider_default,
  CurrencyAmountFromJson,
  CurrencyUnit_default,
  FRAGMENT,
  FRAGMENT10,
  FRAGMENT11,
  FRAGMENT12,
  FRAGMENT13,
  FRAGMENT14,
  FRAGMENT2,
  FRAGMENT3,
  FRAGMENT4,
  FRAGMENT5,
  FRAGMENT6,
  FRAGMENT7,
  FRAGMENT8,
  FRAGMENT9,
  FeeEstimateFromJson,
  GraphNode_default,
  HtlcAttemptFailureCode_default,
  IncentivesIneligibilityReason_default,
  IncentivesStatus_default,
  IncomingPaymentAttemptStatus_default,
  IncomingPaymentFromJson,
  IncomingPayment_default,
  InvoiceDataFromJson,
  InvoiceFromJson,
  InvoiceType_default,
  LightningPaymentDirection_default,
  LightsparkNodeStatus_default,
  LightsparkNodeWithOSK_default,
  LightsparkNodeWithRemoteSigning_default,
  NodeAddressType_default,
  OnChainFeeTarget_default,
  OutgoingPaymentAttemptStatus_default,
  OutgoingPaymentAttempt_default,
  OutgoingPaymentFromJson,
  OutgoingPayment_default,
  PaymentDirection_default,
  PaymentFailureReason_default,
  PaymentRequestFromJson,
  PaymentRequestStatus_default,
  Permission_default,
  RegionCode_default,
  RemoteSigningSubEventType_default,
  RiskRating_default,
  RoutingTransactionFailureReason_default,
  SignablePayloadStatus_default,
  TransactionFromJson,
  TransactionStatus_default,
  TransactionType_default,
  TransactionUpdateFromJson,
  UmaInvitationFromJson,
  WalletStatus_default,
  Wallet_default,
  WebhookEventType,
  WebhookEventType_default,
  WithdrawalFeeEstimateOutputFromJson,
  WithdrawalMode_default,
  WithdrawalRequestFromJson,
  WithdrawalRequestStatus_default,
  WithdrawalRequest_default,
  autoBind,
  getApiTokenQuery,
  getAuditLogActorQuery,
  getChannelClosingTransactionQuery,
  getChannelOpeningTransactionQuery,
  getChannelSnapshotQuery,
  getDepositQuery,
  getHopQuery,
  getIncomingPaymentAttemptQuery,
  getInvoiceQuery,
  getLightningTransactionQuery,
  getLightsparkNodeOwnerQuery,
  getLightsparkNodeQuery,
  getNodeQuery,
  getOnChainTransactionQuery,
  getPaymentRequestQuery,
  getRoutingTransactionQuery,
  getSignablePayloadQuery,
  getSignableQuery,
  getTransactionQuery,
  getUmaInvitationQuery,
  getWithdrawalQuery
} from "./chunk-UHTZSOPX.js";
import {
  BitcoinNetwork_default
} from "./chunk-K6SAUSAX.js";
import "./chunk-BMTV3EA2.js";

// src/auth/AccountTokenAuthProvider.ts
import { b64encode } from "@lightsparkdev/core";
var AccountTokenAuthProvider = class {
  constructor(apiTokenClientId, apiTokenClientSecret) {
    this.apiTokenClientId = apiTokenClientId;
    this.apiTokenClientSecret = apiTokenClientSecret;
    this.utf8AuthBytes = new TextEncoder().encode(
      `${apiTokenClientId}:${apiTokenClientSecret}`
    );
    autoBind(this);
  }
  utf8AuthBytes;
  addWsConnectionParams(params) {
    return Promise.resolve(
      Object.assign({}, params, {
        client_id: this.apiTokenClientId,
        client_secret: this.apiTokenClientSecret
      })
    );
  }
  addAuthHeaders(headers) {
    return Promise.resolve(
      Object.assign({}, headers, {
        authorization: `Basic ${b64encode(this.utf8AuthBytes)}`
      })
    );
  }
  isAuthorized() {
    return Promise.resolve(true);
  }
};
var AccountTokenAuthProvider_default = AccountTokenAuthProvider;

// src/client.ts
import {
  DefaultCrypto as DefaultCrypto2,
  LightsparkAuthException,
  LightsparkException,
  LightsparkSigningException as LightsparkSigningException3,
  NodeKeyCache,
  Requester,
  SigningKeyType as SigningKeyType2,
  StubAuthProvider,
  createSha256Hash,
  pollUntil
} from "@lightsparkdev/core";

// package.json
var package_default = {
  name: "@lightsparkdev/lightspark-sdk",
  version: "1.6.0",
  description: "Lightspark JS SDK",
  author: "Lightspark Inc.",
  keywords: [
    "lightspark",
    "bitcoin",
    "lightning",
    "payments",
    "typescript"
  ],
  homepage: "https://github.com/lightsparkdev/js-sdk",
  repository: {
    type: "git",
    url: "https://github.com/lightsparkdev/js-sdk.git"
  },
  bugs: {
    url: "https://github.com/lightsparkdev/js-sdk/issues"
  },
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      import: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      },
      module: "./dist/index.js",
      require: "./dist/index.cjs",
      default: "./dist/index.cjs"
    },
    "./objects": {
      types: "./dist/objects/index.d.ts",
      import: {
        types: "./dist/objects/index.d.ts",
        default: "./dist/objects/index.js"
      },
      module: "./dist/objects/index.js",
      require: "./dist/objects/index.cjs",
      default: "./dist/objects/index.cjs"
    },
    "./env": {
      types: "./dist/env.d.ts",
      import: {
        types: "./dist/env.d.ts",
        default: "./dist/env.js"
      },
      module: "./dist/env.js",
      require: "./dist/env.cjs",
      default: "./dist/env.cjs"
    }
  },
  type: "module",
  types: "./dist/index.d.ts",
  main: "./dist/index.js",
  module: "./dist/index.js",
  browser: {
    crypto: false,
    fs: false,
    path: false
  },
  files: [
    "src/*",
    "dist/*",
    "CHANGELOG.md"
  ],
  scripts: {
    build: "yarn tsc && tsup",
    "build:watch": "yarn build --watch --clean=false",
    clean: "rm -rf .turbo && rm -rf dist",
    dev: "yarn build -- --watch",
    docs: "typedoc src",
    "format:fix": "prettier src --write",
    format: "prettier src --check",
    "lint:fix": "eslint --fix .",
    "lint:fix:continue": "eslint --fix . || exit 0",
    "lint:watch": "esw ./src -w --ext .ts,.tsx,.js --color",
    lint: "eslint .",
    postversion: "yarn build",
    "test-cmd": "node --experimental-vm-modules $(yarn bin jest) --no-cache --runInBand --bail",
    test: "yarn test-cmd src/tests/*.test.ts",
    "test:integration": "yarn test-cmd src/tests/integration/*.test.ts",
    "types:watch": "tsc-absolute --watch",
    types: "tsc"
  },
  license: "Apache-2.0",
  dependencies: {
    "@lightsparkdev/core": "1.1.0",
    "@lightsparkdev/crypto-wasm": "0.1.4",
    "crypto-browserify": "^3.12.0",
    dayjs: "^1.11.7",
    dotenv: "^16.3.1",
    graphql: "^16.6.0",
    "graphql-ws": "^5.11.3",
    ws: "^8.12.1",
    "zen-observable-ts": "^1.1.0"
  },
  devDependencies: {
    "@lightsparkdev/eslint-config": "*",
    "@lightsparkdev/tsconfig": "0.0.1",
    "@types/crypto-js": "^4.1.1",
    "@types/jest": "^29.5.3",
    "@types/node": "^20.2.5",
    "@types/ws": "^8.5.4",
    "auto-bind": "^5.0.1",
    eslint: "^8.3.0",
    "eslint-watch": "^8.0.0",
    jest: "^29.6.2",
    prettier: "3.0.3",
    "prettier-plugin-organize-imports": "^3.2.4",
    "ts-jest": "^29.1.1",
    "tsc-absolute": "^1.0.1",
    tsup: "^7.2.0",
    typedoc: "^0.24.7",
    typescript: "^5.0.0"
  },
  engines: {
    node: ">=18"
  }
};

// src/NodeKeyLoaderCache.ts
import {
  DefaultCrypto,
  LightsparkSigningException as LightsparkSigningException2
} from "@lightsparkdev/core";

// src/SigningKeyLoader.ts
import {
  LightsparkSigningException,
  SigningKeyType,
  b64encode as b64encode2,
  isBrowser
} from "@lightsparkdev/core";

// src/graphql/RecoverNodeSigningKey.ts
var RecoverNodeSigningKey = `
  query RecoverNodeSigningKey($nodeId: ID!) {
    entity(id: $nodeId) {
      __typename
      ... on LightsparkNodeWithOSK {
        encrypted_signing_private_key {
          encrypted_value
          cipher
        }
      }
    }
  }
`;

// src/SigningKeyLoader.ts
var SIGNING_KEY_PATH = "m/5";
function isNodeIdAndPasswordSigningKeyLoaderArgs(args) {
  return args.password !== void 0;
}
function isMasterSeedSigningKeyLoaderArgs(args) {
  return args.masterSeed !== void 0;
}
var NodeIdAndPasswordSigningKeyLoader = class {
  nodeId;
  password;
  requester;
  cryptoImpl;
  constructor(args, requester, cryptoImpl) {
    this.nodeId = args.nodeId;
    this.password = args.password;
    this.requester = requester;
    this.cryptoImpl = cryptoImpl;
  }
  async loadSigningKey() {
    const encryptedKey = await this.recoverNodeSigningKey();
    if (!encryptedKey) {
      console.warn("No encrypted key found for node " + this.nodeId);
      return;
    }
    const signingPrivateKey = await this.cryptoImpl.decryptSecretWithNodePassword(
      encryptedKey.cipher,
      encryptedKey.encrypted_value,
      this.password
    );
    if (!signingPrivateKey) {
      throw new LightsparkSigningException(
        "Unable to decrypt signing key with provided password. Please try again."
      );
    }
    let signingPrivateKeyPEM = "";
    if (new Uint8Array(signingPrivateKey)[0] === 48) {
      signingPrivateKeyPEM = b64encode2(signingPrivateKey);
    } else {
      const dec = new TextDecoder();
      signingPrivateKeyPEM = dec.decode(signingPrivateKey);
    }
    return { key: signingPrivateKeyPEM, type: SigningKeyType.RSASigningKey };
  }
  async recoverNodeSigningKey() {
    const response = await this.requester.makeRawRequest(
      RecoverNodeSigningKey,
      { nodeId: this.nodeId }
    );
    const nodeEntity = response.entity;
    if (nodeEntity?.__typename === "LightsparkNodeWithOSK") {
      return nodeEntity.encrypted_signing_private_key;
    }
    return null;
  }
};
var MasterSeedSigningKeyLoader = class {
  masterSeed;
  network;
  constructor(args) {
    this.masterSeed = args.masterSeed;
    this.network = args.network;
  }
  async loadSigningKey() {
    if (isBrowser) {
      throw new LightsparkSigningException(
        "Browser environments not supported for master seed signing key loader."
      );
    }
    const { LightsparkSigner, Network } = await import("@lightsparkdev/crypto-wasm");
    let cryptoLibNetwork;
    switch (this.network) {
      case BitcoinNetwork_default.MAINNET:
        cryptoLibNetwork = Network.Bitcoin;
        break;
      case BitcoinNetwork_default.TESTNET:
        cryptoLibNetwork = Network.Testnet;
        break;
      case BitcoinNetwork_default.REGTEST:
        cryptoLibNetwork = Network.Regtest;
        break;
      default:
        throw new Error(
          `Unsupported lightspark_crypto network ${this.network}.`
        );
    }
    const lightsparkSigner = LightsparkSigner.from_bytes(
      this.masterSeed,
      cryptoLibNetwork
    );
    const privateKey = lightsparkSigner.derive_private_key(SIGNING_KEY_PATH);
    return { key: privateKey, type: SigningKeyType.Secp256k1SigningKey };
  }
};

// src/NodeKeyLoaderCache.ts
var NodeKeyLoaderCache = class {
  constructor(nodeKeyCache, cryptoImpl = DefaultCrypto) {
    this.nodeKeyCache = nodeKeyCache;
    this.cryptoImpl = cryptoImpl;
    this.idToLoader = /* @__PURE__ */ new Map();
  }
  idToLoader;
  /**
   * Sets the signing key loader for a node.
   * Instantiates a signing key loader based on the type of args passed in by
   * the user.
   *
   * @param nodeId The ID of the node to get the key for
   * @param loaderArgs Loader arguments for loading the key
   * @param requester Requester used for loading the key
   */
  setLoader(nodeId, loaderArgs, requester) {
    let loader;
    if (isNodeIdAndPasswordSigningKeyLoaderArgs(loaderArgs)) {
      loader = new NodeIdAndPasswordSigningKeyLoader(
        { nodeId, ...loaderArgs },
        requester,
        this.cryptoImpl
      );
    } else if (isMasterSeedSigningKeyLoaderArgs(loaderArgs)) {
      loader = new MasterSeedSigningKeyLoader({ ...loaderArgs });
    } else {
      throw new LightsparkSigningException2("Invalid signing key loader args");
    }
    this.idToLoader.set(nodeId, loader);
  }
  /**
   * Gets the key for a node using the loader set by [setLoader]
   *
   * @param id The ID of the node to get the key for
   * @returns The loaded key
   */
  async getKeyWithLoader(id) {
    if (this.nodeKeyCache.hasKey(id)) {
      return this.nodeKeyCache.getKey(id);
    }
    const loader = this.idToLoader.get(id);
    if (!loader) {
      throw new LightsparkSigningException2(
        "No signing key loader found for node " + id
      );
    }
    const loaderResult = await loader.loadSigningKey();
    if (!loaderResult) {
      return;
    }
    const key = await this.nodeKeyCache.loadKey(
      id,
      { key: loaderResult.key },
      loaderResult.type
    );
    return key || void 0;
  }
};

// src/graphql/BitcoinFeeEstimate.ts
var BitcoinFeeEstimate = `
  query BitcoinFeeEstimate($bitcoin_network: BitcoinNetwork!) {
    bitcoin_fee_estimate(network: $bitcoin_network) {
      ...FeeEstimateFragment
    }
  }

  ${FRAGMENT2}
`;

// src/graphql/CancelInvoice.ts
var CancelInvoice = `
  mutation CancelInvoice(
    $invoice_id: ID!
  ) {
    cancel_invoice(input: { invoice_id: $invoice_id }) {
      invoice {
        ...InvoiceFragment
      }
    }
  }

  ${FRAGMENT4}
`;

// src/graphql/ClaimUmaInvitation.ts
var ClaimUmaInvitation = `
    mutation ClaimUmaInvitation(
        $invitationCode: String!
        $inviteeUma: String!
    ) {
        claim_uma_invitation(input: {
            invitation_code: $invitationCode
            invitee_uma: $inviteeUma
        }) {
            invitation {
                ...UmaInvitationFragment
            }
        }
    }

${FRAGMENT5}
`;

// src/graphql/ClaimUmaInvitationWithIncentives.ts
var ClaimUmaInvitationWithIncentives = `
    mutation ClaimUmaInvitationWithIncentives(
        $invitationCode: String!
        $inviteeUma: String!
        $inviteePhoneHash: String!
        $inviteeRegion: RegionCode!
    ) {
        claim_uma_invitation_with_incentives(input: {
            invitation_code: $invitationCode
            invitee_uma: $inviteeUma
            invitee_phone_hash: $inviteePhoneHash
            invitee_region: $inviteeRegion
        }) {
            invitation {
                ...UmaInvitationFragment
            }
        }
    }

${FRAGMENT5}
`;

// src/graphql/CreateApiToken.ts
var CreateApiToken = `
    mutation CreateApiToken(
        $name: String!
        $permissions: [Permission!]!
    ) {
        create_api_token(input: {
            name: $name
            permissions: $permissions
        }) {
            api_token {
                ...ApiTokenFragment
            }
            client_secret
        }
    }

${FRAGMENT6}
`;

// src/graphql/CreateInvoice.ts
var CreateInvoice = `
  mutation CreateInvoice(
    $node_id: ID!
    $amount_msats: Long!
    $memo: String
    $type: InvoiceType = null
    $expiry_secs: Int = null
  ) {
    create_invoice(input: { node_id: $node_id, amount_msats: $amount_msats, memo: $memo, invoice_type: $type, expiry_secs: $expiry_secs }) {
      invoice {
        data {
          encoded_payment_request
        }
      }
    }
  }
`;

// src/graphql/CreateLnurlInvoice.ts
var CreateLnurlInvoice = `
mutation CreateLnurlInvoice(
  $node_id: ID!
  $amount_msats: Long!
  $metadata_hash: String!
  $expiry_secs: Int = null
) {
  create_lnurl_invoice(input: {
      node_id: $node_id
      amount_msats: $amount_msats
      metadata_hash: $metadata_hash
      expiry_secs: $expiry_secs
  }) {
      invoice {
          ...InvoiceFragment
      }
  }
}
${FRAGMENT4}
`;

// src/graphql/CreateNodeWalletAddress.ts
var CreateNodeWalletAddress = `
  mutation CreateNodeWalletAddress(
    $node_id: ID!
  ) {
    create_node_wallet_address(input: {
        node_id: $node_id
    }) {
        wallet_address
    }
  }
`;

// src/graphql/CreateTestModeInvoice.ts
var CreateTestModeInvoice = `
mutation CreateTestModeInvoice(
  $local_node_id: ID!
  $amount_msats: Long!
  $memo: String
  $invoice_type: InvoiceType
) {
  create_test_mode_invoice(input: {
      local_node_id: $local_node_id
      amount_msats: $amount_msats
      memo: $memo
      invoice_type: $invoice_type
  }) {
      encoded_payment_request
  }
}
`;

// src/graphql/CreateTestModePayment.ts
var CreateTestModePayment = `
mutation CreateTestModePayment(
  $local_node_id: ID!
  $encoded_invoice: String!
  $amount_msats: Long
) {
  create_test_mode_payment(input: {
      local_node_id: $local_node_id
      encoded_invoice: $encoded_invoice
      amount_msats: $amount_msats
  }) {
      incoming_payment {
          ...IncomingPaymentFragment
      }
  }
}

${FRAGMENT7}
`;

// src/graphql/CreateUmaInvitation.ts
var CreateUmaInvitation = `
    mutation CreateUmaInvitation(
        $inviterUma: String!
    ) {
        create_uma_invitation(input: {
            inviter_uma: $inviterUma
        }) {
            invitation {
                ...UmaInvitationFragment
            }
        }
    }

${FRAGMENT5}
`;

// src/graphql/CreateUmaInvitationWithIncentives.ts
var CreateUmaInvitationWithIncentives = `
    mutation CreateUmaInvitationWithIncentives(
        $inviterUma: String!
        $inviterPhoneHash: String!
        $inviterRegion: RegionCode!
    ) {
        create_uma_invitation_with_incentives(input: {
            inviter_uma: $inviterUma
            inviter_phone_hash: $inviterPhoneHash
            inviter_region: $inviterRegion
        }) {
            invitation {
                ...UmaInvitationFragment
            }
        }
    }

${FRAGMENT5}
`;

// src/graphql/CreateUmaInvoice.ts
var CreateUmaInvoice = `
mutation CreateUmaInvoice(
  $node_id: ID!
  $amount_msats: Long!
  $metadata_hash: String!
  $expiry_secs: Int = null
) {
  create_uma_invoice(input: {
      node_id: $node_id
      amount_msats: $amount_msats
      metadata_hash: $metadata_hash
      expiry_secs: $expiry_secs
  }) {
      invoice {
          ...InvoiceFragment
      }
  }
}
${FRAGMENT4}
`;

// src/graphql/DecodeInvoice.ts
var DecodeInvoice = `
  query DecodeInvoice($encoded_payment_request: String!) {
    decoded_payment_request(encoded_payment_request: $encoded_payment_request) {
      __typename
      ... on InvoiceData {
        ...InvoiceDataFragment
      }
    }
  }

  ${FRAGMENT3}
`;

// src/graphql/DeleteApiToken.ts
var DeleteApiToken = `
    mutation DeleteApiToken(
        $api_token_id: ID!
    ) {
        delete_api_token(input: {
            api_token_id: $api_token_id
        }) {
            __typename
        }
    }
`;

// src/graphql/FetchUmaInvitation.ts
var FetchUmaInvitation = `
    query FetchUmaInvitation(
        $invitationCode: String!
    ) {
        uma_invitation_by_code(code: $invitationCode) {
            ...UmaInvitationFragment
        }
    }

${FRAGMENT5}
`;

// src/graphql/FundNode.ts
var FundNode = `
    mutation FundNode(
        $node_id: ID!,
        $amount_sats: Long
    ) {
        fund_node(input: { node_id: $node_id, amount_sats: $amount_sats }) {
            amount {
                ...CurrencyAmountFragment
            }
        }
    }

${FRAGMENT}
`;

// src/graphql/InvoiceForPaymentHash.ts
var InvoiceForPaymentHash = `
query InvoiceForPaymentHash($payment_hash: Hash32!) {
	invoice_for_payment_hash(input: {
		payment_hash: $payment_hash
	}) {
		invoice {
			...InvoiceFragment
		}
	}
}

  ${FRAGMENT4}
`;

// src/graphql/LightningFeeEstimateForInvoice.ts
var LightningFeeEstimateForInvoice = `
  query LightningFeeEstimateForInvoice(
    $node_id: ID!
    $encoded_payment_request: String!
    $amount_msats: Long
  ) {
    lightning_fee_estimate_for_invoice(input: {
      node_id: $node_id,
      encoded_payment_request: $encoded_payment_request,
      amount_msats: $amount_msats
    }) {
      ...LightningFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT8}
`;

// src/graphql/LightningFeeEstimateForNode.ts
var LightningFeeEstimateForNode = `
  query LightningFeeEstimateForNode(
    $node_id: ID!
    $destination_node_public_key: String!
    $amount_msats: Long!
  ) {
    lightning_fee_estimate_for_node(input: {
      node_id: $node_id,
      destination_node_public_key: $destination_node_public_key,
      amount_msats: $amount_msats
    }) {
      ...LightningFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT8}
`;

// src/graphql/MultiNodeDashboard.ts
var MultiNodeDashboard = `
  query MultiNodeDashboard(
    $network: BitcoinNetwork!,
    $nodeIds: [ID!]
  ) {
    current_account {
      id
      name
      dashboard_overview_nodes: nodes(
        bitcoin_networks: [$network]
        node_ids: $nodeIds
      ) {
        count
        entities {
          color
          display_name
          id
          addresses(first: 1) {
            entities {
              address
              type
              __typename
            }
            count
            __typename
          }
          public_key
          status
          local_balance {
            ...CurrencyAmountFragment
          }
          remote_balance {
            ...CurrencyAmountFragment
          }
          blockchain_balance {
            available_balance {
              ...CurrencyAmountFragment
            }
            total_balance {
              ...CurrencyAmountFragment
            }
            __typename
          }
          __typename
        }
        __typename
      }
      blockchain_balance(bitcoin_networks: [$network], node_ids: $nodeIds) {
        l1_balance: total_balance {
          ...CurrencyAmountFragment
        }
        required_reserve {
          ...CurrencyAmountFragment
        }
        available_balance {
          ...CurrencyAmountFragment
        }
        unconfirmed_balance {
          ...CurrencyAmountFragment
        }
        __typename
      }
      local_balance(bitcoin_networks: [$network], node_ids: $nodeIds) {
        ...CurrencyAmountFragment
      }
      remote_balance(bitcoin_networks: [$network], node_ids: $nodeIds) {
        ...CurrencyAmountFragment
      }
    }
  }

  ${FRAGMENT}
`;

// src/graphql/OutgoingPaymentsForPaymentHash.ts
var OutgoingPaymentsForPaymentHash = `
query OutgoingPaymentsForPaymentHash(
	$payment_hash: Hash32!
	$statuses: [TransactionStatus!]
) {
	outgoing_payments_for_payment_hash(input: {
		payment_hash: $payment_hash
		statuses: $statuses
	}) {
		payments {
			...OutgoingPaymentFragment
		}
	}
}

  ${FRAGMENT9}
`;

// src/graphql/PayInvoice.ts
var PayInvoice = `
  mutation PayInvoice(
    $node_id: ID!
    $encoded_invoice: String!
    $timeout_secs: Int!
    $maximum_fees_msats: Long!
    $amount_msats: Long
  ) {
    pay_invoice(
      input: {
        node_id: $node_id
        encoded_invoice: $encoded_invoice
        timeout_secs: $timeout_secs
        maximum_fees_msats: $maximum_fees_msats
        amount_msats: $amount_msats
      }
    ) {
      payment {
        ...OutgoingPaymentFragment
      }
    }
  }

  ${FRAGMENT9}
`;

// src/graphql/PayUmaInvoice.ts
var PayUmaInvoice = `
  mutation PayUmaInvoice(
    $node_id: ID!
    $encoded_invoice: String!
    $timeout_secs: Int!
    $maximum_fees_msats: Long!
    $amount_msats: Long
  ) {
    pay_uma_invoice(
      input: {
        node_id: $node_id
        encoded_invoice: $encoded_invoice
        timeout_secs: $timeout_secs
        maximum_fees_msats: $maximum_fees_msats
        amount_msats: $amount_msats
      }
    ) {
      payment {
        ...OutgoingPaymentFragment
      }
    }
  }

  ${FRAGMENT9}
`;

// src/graphql/PaymentRequestsForNode.ts
var PaymentRequestsForNode = `
query PaymentRequestsForNode(
    $network: BitcoinNetwork!,
    $nodeId: ID!,
    $numTransactions: Int,
    $afterDate: DateTime,
) {
    current_account {
        id
        name
        recent_payment_requests: payment_requests(
            first: $numTransactions
            bitcoin_network: $network
            lightning_node_id: $nodeId
            after_date: $afterDate
        ) {
            count
            entities {
                ...PaymentRequestFragment
                __typename
            }
            __typename
        }
        __typename
    }
}

${FRAGMENT10}
`;

// src/graphql/RegisterPayment.ts
var RegisterPayment = `
mutation RegisterPayment(
  $provider: ComplianceProvider!
  $payment_id: ID!
  $node_pubkey: String!
  $direction: PaymentDirection!
) {
  register_payment(input: {
      provider: $provider
      payment_id: $payment_id
      node_pubkey: $node_pubkey
      direction: $direction
  }) {
      payment {
          id
      }
  }
}
`;

// src/graphql/RequestWithdrawal.ts
var RequestWithdrawal = `
  mutation RequestWithdrawal(
    $node_id: ID!
    $bitcoin_address: String!
    $amount_sats: Long!
    $withdrawal_mode: WithdrawalMode!
  ) {
    request_withdrawal(input: {
      node_id: $node_id
      bitcoin_address: $bitcoin_address
      amount_sats: $amount_sats
      withdrawal_mode: $withdrawal_mode
    }) {
        request {
            ...WithdrawalRequestFragment
        }
    }
  }

  ${FRAGMENT11}
`;

// src/graphql/ScreenNode.ts
var ScreenNode = `
mutation ScreenNode(
  $provider: ComplianceProvider!
  $node_pubkey: String!
) {
  screen_node(input: {
      provider: $provider
      node_pubkey: $node_pubkey
  }) {
      rating
  }
}
`;

// src/graphql/SendPayment.ts
var SendPayment = `
  mutation SendPayment(
    $node_id: ID!
    $destination_public_key: String!
    $timeout_secs: Int!
    $amount_msats: Long!
    $maximum_fees_msats: Long!
  ) {
    send_payment(
      input: {
        node_id: $node_id
        destination_public_key: $destination_public_key
        timeout_secs: $timeout_secs
        amount_msats: $amount_msats
        maximum_fees_msats: $maximum_fees_msats
      }
    ) {
      payment {
        ...OutgoingPaymentFragment
      }
    }
  }

  ${FRAGMENT9}
`;

// src/graphql/SingleNodeDashboard.ts
var SingleNodeDashboard = `
query SingleNodeDashboard(
    $network: BitcoinNetwork!,
    $nodeId: ID!,
    $numTransactions: Int,
    $transactionsAfterDate: DateTime,
    $transactionTypes: [TransactionType!] = [PAYMENT, PAYMENT_REQUEST, ROUTE, L1_WITHDRAW, L1_DEPOSIT]
    $transaction_statuses: [TransactionStatus!] = null
) {
    current_account {
        id
        name
        dashboard_overview_nodes: nodes(
            first: 1
            bitcoin_networks: [$network]
            node_ids: [$nodeId]
        ) {
            count
            entities {
                color
                display_name
                id
                addresses(first: 1) {
                    entities {
                        address
                        type
                        __typename
                    }
                    count
                    __typename
                }
                public_key
                status
                total_local_balance {
                    ...CurrencyAmountFragment
                }
                local_balance {
                    ...CurrencyAmountFragment
                }
                remote_balance {
                    ...CurrencyAmountFragment
                }
                blockchain_balance {
                    confirmed_balance {
                        ...CurrencyAmountFragment
                    }
                    unconfirmed_balance {
                        ...CurrencyAmountFragment
                    }
                    available_balance {
                        ...CurrencyAmountFragment
                    }
                    total_balance {
                        ...CurrencyAmountFragment
                    }
                    __typename
                }
                __typename
            }
            __typename
        }
        blockchain_balance(bitcoin_networks: [$network], node_ids: [$nodeId]) {
            total_balance: total_balance {
                ...CurrencyAmountFragment
            }
            required_reserve {
                ...CurrencyAmountFragment
            }
            available_balance {
                ...CurrencyAmountFragment
            }
            unconfirmed_balance {
                ...CurrencyAmountFragment
            }
            confirmed_balance {
                ...CurrencyAmountFragment
            }
            __typename
        }
        local_balance(bitcoin_networks: [$network], node_ids: [$nodeId]) {
            ...CurrencyAmountFragment
        }
        remote_balance(bitcoin_networks: [$network], node_ids: [$nodeId]) {
            ...CurrencyAmountFragment
        }
        recent_transactions: transactions(
            first: $numTransactions
            types: $transactionTypes
            bitcoin_network: $network
            lightning_node_id: $nodeId
            statuses: $transaction_statuses
            after_date: $transactionsAfterDate
        ) {
            count
            total_amount_transacted {
                ...CurrencyAmountFragment
            }
            entities {
                ...TransactionFragment
                __typename
            }
            __typename
        }
        __typename
    }
}

${FRAGMENT12}
${FRAGMENT}
`;

// src/graphql/TransactionSubscription.ts
var TransactionSubscription = `
subscription TransactionSubscription(
    $nodeIds: [ID!]!
) {
    transactions(node_ids: $nodeIds) {
        ...TransactionUpdateFragment
        __typename
    }
}

${FRAGMENT13}
`;

// src/graphql/TransactionsForNode.ts
var TransactionsForNode = `
query TransactionsForNode(
    $network: BitcoinNetwork!,
    $nodeId: ID!,
    $numTransactions: Int,
    $afterDate: DateTime,
    $transactionTypes: [TransactionType!] = [PAYMENT, PAYMENT_REQUEST, ROUTE, L1_WITHDRAW, L1_DEPOSIT]
    $transaction_statuses: [TransactionStatus!] = null
) {
    current_account {
        id
        name
        recent_transactions: transactions(
            first: $numTransactions
            types: $transactionTypes
            bitcoin_network: $network
            lightning_node_id: $nodeId
            statuses: $transaction_statuses
            after_date: $afterDate
        ) {
            count
            total_amount_transacted {
                ...CurrencyAmountFragment
            }
            entities {
                ...TransactionFragment
                __typename
            }
            __typename
        }
        __typename
    }
}

${FRAGMENT12}
${FRAGMENT}
`;

// src/graphql/WithdrawalFeeEstimate.ts
var WithdrawalFeeEstimate = `
  query WithdrawalFeeEstimate(
    $node_id: ID!
    $amount_sats: Long!
    $withdrawal_mode: WithdrawalMode!
  ) {
    withdrawal_fee_estimate(input: {
      node_id: $node_id,
      amount_sats: $amount_sats,
      withdrawal_mode: $withdrawal_mode
    }) {
      ...WithdrawalFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT14}
`;

// src/client.ts
var sdkVersion = package_default.version;
var LightsparkClient = class {
  /**
   * Constructs a new LightsparkClient.
   *
   * @param authProvider The auth provider to use for authentication. Defaults to a stub auth provider.
   * For server-side
   *     use, you should use the `AccountTokenAuthProvider`.
   * @param serverUrl The base URL of the server to connect to. Defaults to lightspark production.
   * @param cryptoImpl The crypto implementation to use. Defaults to web and node compatible crypto.
   *     For React Native, you should use the `ReactNativeCrypto`
   *     implementation from `@lightsparkdev/react-native`.
   */
  constructor(authProvider = new StubAuthProvider(), serverUrl = "api.lightspark.com", cryptoImpl = DefaultCrypto2) {
    this.authProvider = authProvider;
    this.serverUrl = serverUrl;
    this.cryptoImpl = cryptoImpl;
    this.nodeKeyCache = new NodeKeyCache(this.cryptoImpl);
    this.nodeKeyLoaderCache = new NodeKeyLoaderCache(
      this.nodeKeyCache,
      this.cryptoImpl
    );
    this.requester = new Requester(
      this.nodeKeyCache,
      this.LIGHTSPARK_SDK_ENDPOINT,
      `js-lightspark-sdk/${sdkVersion}`,
      authProvider,
      serverUrl,
      this.cryptoImpl
    );
    autoBind(this);
  }
  requester;
  nodeKeyCache;
  nodeKeyLoaderCache;
  LIGHTSPARK_SDK_ENDPOINT = process.env.LIGHTSPARK_SDK_ENDPOINT || "graphql/server/2023-09-13";
  /**
   * Sets the key loader for a node. This unlocks client operations that
   * require a private key. Passing in [NodeIdAndPasswordSigningKeyLoaderArgs]
   * loads the RSA key for an OSK node.
   * Passing in [MasterSeedSigningKeyLoaderArgs] loads the Secp256k1 key for a
   * remote signing node.
   *
   * @param nodeId The ID of the node the key is for
   * @param loader The loader for the key
   */
  async loadNodeSigningKey(nodeId, loaderArgs) {
    this.nodeKeyLoaderCache.setLoader(nodeId, loaderArgs, this.requester);
    const key = await this.getNodeSigningKey(nodeId);
    return !!key;
  }
  /**
   * Gets the signing key for a node. Must have previously called
   * [loadNodeSigningKey].
   *
   * @param nodeId The ID of the node the key is for
   * @returns The signing key for the node
   */
  async getNodeSigningKey(nodeId) {
    return await this.nodeKeyLoaderCache.getKeyWithLoader(nodeId);
  }
  /**
   * Sets the auth provider for the client.
   * This is useful for switching between auth providers if you are using
   * multiple accounts or waiting for the user to log in.
   *
   * @param authProvider
   */
  setAuthProvider(authProvider) {
    this.requester = new Requester(
      this.nodeKeyCache,
      this.LIGHTSPARK_SDK_ENDPOINT,
      `js-lightspark-sdk/${sdkVersion}`,
      authProvider,
      this.serverUrl,
      this.cryptoImpl
    );
    this.authProvider = authProvider;
  }
  /**
   * @returns Whether or not the client is authorized. This is useful for determining if the user is logged in or not.
   */
  async isAuthorized() {
    return this.authProvider.isAuthorized();
  }
  /**
   * @returns The current account, if one exists.
   */
  async getCurrentAccount() {
    return await this.requester.executeQuery(
      Account_default.getAccountQuery()
    );
  }
  /**
   * Retrieves the most recent transactions for a given node.
   *
   * @param nodeId The node ID for which to read transactions
   * @param numTransactions The maximum number of transactions to read. Defaults to 20.
   * @param bitcoinNetwork The bitcoin network on which to read transactions. Defaults to MAINNET.
   * @param afterDate Filters transactions to those after the given date. Defaults to undefined (no limit).
   * @returns An array of transactions for the given node ID.
   */
  async getRecentTransactions(nodeId, numTransactions = 20, bitcoinNetwork = BitcoinNetwork_default.MAINNET, afterDate = void 0) {
    const response = await this.requester.makeRawRequest(TransactionsForNode, {
      nodeId,
      network: bitcoinNetwork,
      numTransactions,
      afterDate
    });
    return response.current_account?.recent_transactions.entities.map(
      (transaction) => TransactionFromJson(transaction)
    ) ?? [];
  }
  getTransaction(transactionId) {
    return this.requester.executeQuery(
      getTransactionQuery(transactionId)
    );
  }
  /**
   * Retrieves the most recent payment requests for a given node.
   *
   * @param nodeId The node ID for which to read transactions
   * @param numTransactions The maximum number of transactions to read. Defaults to 20.
   * @param bitcoinNetwork The bitcoin network on which to read transactions. Defaults to MAINNET.
   * @param afterDate Filters transactions to those after the given date. Defaults to undefined (no limit).
   * @returns An array of payment requests for the given node ID.
   */
  async getRecentPaymentRequests(nodeId, numTransactions = 20, bitcoinNetwork = BitcoinNetwork_default.MAINNET, afterDate = void 0) {
    const response = await this.requester.makeRawRequest(
      PaymentRequestsForNode,
      {
        nodeId,
        numTransactions,
        network: bitcoinNetwork,
        afterDate
      }
    );
    return response.current_account?.recent_payment_requests.entities.map(
      (paymentRequest) => PaymentRequestFromJson(paymentRequest)
    ) ?? [];
  }
  /**
   * Starts listening for new transactions or updates to existing transactions
   * for a list of nodes.
   *
   * @param nodeIds The node IDs for which to listen to transactions.
   * @returns A zen-observable that emits transaction updates for the given node IDs.
   */
  listenToTransactions(nodeIds) {
    const response = this.requester.subscribe(
      TransactionSubscription,
      {
        nodeIds
      }
    );
    return response.map(
      (response2) => response2?.data?.transactions && TransactionUpdateFromJson(response2.data.transactions)
    );
  }
  /**
   * Retrieves a dashboard of basic info for the authenticated account.
   * See `AccountDashboard` for which info is included.
   *
   * @param nodeIds The node IDs to include in the dashboard. Defaults to undefined (all nodes).
   * @param bitcoinNetwork The bitcoin network to include in the dashboard. Defaults to MAINNET.
   * @returns A basic account dashboard for the given node IDs.
   * @throws LightsparkAuthException if the user is not logged in or a LightsparkException if no nodes are found.
   */
  async getAccountDashboard(nodeIds = void 0, bitcoinNetwork = BitcoinNetwork_default.MAINNET) {
    const response = await this.requester.makeRawRequest(MultiNodeDashboard, {
      nodeIds,
      network: bitcoinNetwork
    });
    if (!response.current_account) {
      throw new LightsparkAuthException("No current account");
    }
    if (!response.current_account.dashboard_overview_nodes || response.current_account.dashboard_overview_nodes.entities.length === 0) {
      throw new LightsparkException(
        "NO_NODES_FOUND",
        `No nodes found for this dashboard request. This could mean one of a few things:
        1. You are requesting MAINNET nodes, but you have no MAINNET nodes yet. In this case, request BitcoinNetwork.REGTEST instead.
        2. You are specifying specific node IDs, but those IDs don't exist or are not on the bitcoid network you requested.
        3. The api token or authentication mechanism you are using is not authorized to access the nodes you requested. If you're using
           an API token, make sure it has the correct permissions for the desired network (only test tokens have access to REGTEST nodes).`
      );
    }
    const account = response.current_account;
    return {
      id: account.id,
      name: account.name,
      nodes: account.dashboard_overview_nodes.entities.map((node) => {
        return {
          color: node.color,
          displayName: node.display_name,
          id: node.id,
          publicKey: node.public_key,
          status: node.status,
          addresses: {
            count: node.addresses.count,
            entities: node.addresses.entities.map((address) => {
              return {
                address: address.address,
                type: address.type
              };
            })
          },
          localBalance: node.local_balance && CurrencyAmountFromJson(node.local_balance),
          remoteBalance: node.remote_balance && CurrencyAmountFromJson(node.remote_balance),
          blockchainBalance: node.blockchain_balance && CurrencyAmountFromJson(node.blockchain_balance)
        };
      }),
      blockchainBalance: !!account.blockchain_balance ? {
        l1Balance: account.blockchain_balance.l1_balance && CurrencyAmountFromJson(account.blockchain_balance.l1_balance),
        requiredReserve: account.blockchain_balance.required_reserve && CurrencyAmountFromJson(
          account.blockchain_balance.required_reserve
        ),
        availableBalance: account.blockchain_balance.available_balance && CurrencyAmountFromJson(
          account.blockchain_balance.available_balance
        ),
        unconfirmedBalance: account.blockchain_balance.unconfirmed_balance && CurrencyAmountFromJson(
          account.blockchain_balance.unconfirmed_balance
        )
      } : null,
      localBalance: account.local_balance && CurrencyAmountFromJson(account.local_balance),
      remoteBalance: account.remote_balance && CurrencyAmountFromJson(account.remote_balance)
    };
  }
  /**
   * Gets a basic dashboard for a single node, including recent transactions.
   * See `SingleNodeDashboard` for which info is included.
   *
   * @param nodeId The node ID for which to get a dashboard.
   * @param bitcoinNetwork The bitcoin network for which to get a dashboard. Defaults to MAINNET.
   * @param transactionsAfterDate Filters recent transactions to those after the given date.
   *     Defaults to undefined (no limit).
   * @returns A basic dashboard for the given node ID.
   */
  async getSingleNodeDashboard(nodeId, bitcoinNetwork = BitcoinNetwork_default.MAINNET, transactionsAfterDate = void 0) {
    const response = await this.requester.makeRawRequest(
      SingleNodeDashboard,
      {
        nodeId,
        network: bitcoinNetwork,
        numTransactions: 20,
        transactionsAfterDate
      }
    );
    if (!response.current_account) {
      throw new LightsparkAuthException("No current account");
    }
    const account = response.current_account;
    if (!account.dashboard_overview_nodes || !account.dashboard_overview_nodes.entities || account.dashboard_overview_nodes.entities.length === 0) {
      throw new LightsparkException(
        "InvalidOrMissingNode",
        "No nodes found for node dashboard"
      );
    }
    const node = account.dashboard_overview_nodes.entities[0];
    const nodeAddresses = node.addresses.entities.map((address) => {
      return {
        address: address.address,
        type: address.type
      };
    });
    const currencyAmountOrUndefined = (json) => {
      return json && CurrencyAmountFromJson(json);
    };
    return {
      color: node.color,
      displayName: account.name,
      id: node.id,
      publicKey: node.public_key,
      status: node.status,
      addresses: nodeAddresses,
      totalBalance: currencyAmountOrUndefined(node.total_balance),
      totalLocalBalance: currencyAmountOrUndefined(node.total_local_balance),
      onlineLocalBalance: currencyAmountOrUndefined(node.local_balance),
      remoteBalance: currencyAmountOrUndefined(node.remote_balance),
      blockchainBalance: node.blockchain_balance && {
        availableBalance: currencyAmountOrUndefined(
          node.blockchain_balance.available_balance
        ),
        confirmedBalance: currencyAmountOrUndefined(
          node.blockchain_balance.confirmed_balance
        ),
        unconfirmedBalance: currencyAmountOrUndefined(
          node.blockchain_balance.unconfirmed_balance
        ),
        totalBalance: currencyAmountOrUndefined(
          node.blockchain_balance.total_balance
        )
      },
      recentTransactions: account.recent_transactions?.entities.map((tx) => {
        return TransactionFromJson(tx);
      }) || []
    };
  }
  /**
   * Creates an invoice for the given node.
   *
   * Test mode note: You can simulate a payment of this invoice in test move
   * using [createTestModePayment].
   *
   * @param nodeId The node ID for which to create an invoice.
   * @param amountMsats The amount of the invoice in msats. You can create a zero-amount invoice to accept any payment amount.
   * @param memo A string memo to include in the invoice as a description.
   * @param type The type of invoice to create. Defaults to a normal payment invoice, but you can pass InvoiceType.AMP
   *     to create an [AMP invoice](https://docs.lightning.engineering/lightning-network-tools/lnd/amp), which can be
   *     paid multiple times.
   * @param expirySecs The number of seconds until the invoice expires. Defaults to 86400 (1 day).
   * @returns An encoded payment request for the invoice, or undefined if the invoice could not be created.
   */
  async createInvoice(nodeId, amountMsats, memo, type = void 0, expirySecs = void 0) {
    const variables = {
      node_id: nodeId,
      amount_msats: amountMsats,
      memo,
      type
    };
    if (expirySecs !== void 0) {
      variables["expiry_secs"] = expirySecs;
    }
    const response = await this.requester.makeRawRequest(
      CreateInvoice,
      variables
    );
    return response.create_invoice?.invoice.data?.encoded_payment_request;
  }
  /**
   * Generates a Lightning Invoice (follows the Bolt 11 specification) to
   * request a payment from another Lightning Node.
   * This should only be used for generating invoices for LNURLs,
   * with [createInvoice] preferred in the general case.
   *
   * Test mode note: You can simulate a payment of this invoice in test move
   * using [createTestModePayment].
   *
   * @param nodeId The node ID for which to create an invoice.
   * @param amountMsats The amount of the invoice in msats. You can create a zero-amount invoice to accept any payment amount.
   * @param metadata The LNURL metadata payload field in the initial payreq response. This wil be hashed and present in the
   *     h-tag (SHA256 purpose of payment) of the resulting Bolt 11 invoice. See
   *     [this spec](https://github.com/lnurl/luds/blob/luds/06.md#pay-to-static-qrnfclink) for details.
   * @param expirySecs The number of seconds until the invoice expires. Defaults to 86400 (1 day).
   * @returns An Invoice object representing the generated invoice.
   */
  async createLnurlInvoice(nodeId, amountMsats, metadata, expirySecs = void 0) {
    const metadataHash = await createSha256Hash(metadata, true);
    const variables = {
      node_id: nodeId,
      amount_msats: amountMsats,
      metadata_hash: metadataHash
    };
    if (expirySecs !== void 0) {
      variables["expiry_secs"] = expirySecs;
    }
    const response = await this.requester.makeRawRequest(
      CreateLnurlInvoice,
      variables
    );
    const invoiceJson = response.create_lnurl_invoice?.invoice;
    if (!invoiceJson) {
      return void 0;
    }
    return InvoiceFromJson(invoiceJson);
  }
  /**
   * Creates a new invoice for the UMA protocol.
   * The metadata is hashed and included in the invoice.
   * This API generates a Lightning Invoice (follows the Bolt 11 specification)
   * to request a payment from another Lightning Node.
   * This should only be used for generating invoices for UMA,
   * with `createInvoice` preferred in the general case.
   *
   * @param nodeId The node ID for which to create an invoice.
   * @param amountMsats The amount of the invoice in msats. You can create a zero-amount invoice to accept any payment amount.
   * @param metadata The LNURL metadata payload field in the initial payreq response. This wil be hashed and present in the
   *     h-tag (SHA256 purpose of payment) of the resulting Bolt 11 invoice. See
   *     [this spec](https://github.com/lnurl/luds/blob/luds/06.md#pay-to-static-qrnfclink) for details.
   * @param expirySecs The number of seconds until the invoice expires. Defaults to 3600 (1 hour).
   * @returns An Invoice object representing the generated invoice.
   */
  async createUmaInvoice(nodeId, amountMsats, metadata, expirySecs = void 0) {
    const metadataHash = await createSha256Hash(metadata, true);
    const variables = {
      node_id: nodeId,
      amount_msats: amountMsats,
      metadata_hash: metadataHash,
      expiry_secs: expirySecs !== void 0 ? expirySecs : 3600
    };
    const response = await this.requester.makeRawRequest(
      CreateUmaInvoice,
      variables
    );
    const invoiceJson = response.create_uma_invoice?.invoice;
    if (!invoiceJson) {
      return void 0;
    }
    return InvoiceFromJson(invoiceJson);
  }
  /**
   * Cancels an existing unpaid invoice and returns that invoice. Cancelled invoices cannot be paid.
   *
   * @param invoiceId The ID of the invoice to cancel.
   * @returns The cancelled invoice, or undefined if the invoice could not be cancelled.
   */
  async cancelInvoice(invoiceId) {
    const response = await this.requester.makeRawRequest(CancelInvoice, {
      invoice_id: invoiceId
    });
    const invoiceJson = response.cancel_invoice?.invoice;
    if (!invoiceJson) {
      return void 0;
    }
    return InvoiceFromJson(invoiceJson);
  }
  /**
   * Decodes an encoded lightning invoice string.
   *
   * @param encodedInvoice The string encoded invoice to decode.
   * @returns Decoded invoice data.
   */
  async decodeInvoice(encodedInvoice) {
    const response = await this.requester.makeRawRequest(DecodeInvoice, {
      encoded_payment_request: encodedInvoice
    });
    return InvoiceDataFromJson(response.decoded_payment_request);
  }
  /**
   * Gets an estimate of the fee for sending a payment over the given bitcoin
   * network.
   *
   * @param bitcoinNetwork The bitcoin network for which to get a fee estimate. Defaults to MAINNET.
   * @returns A fee estimate for the given bitcoin network including a minimum fee rate, and a max-speed fee rate.
   */
  async getBitcoinFeeEstimate(bitcoinNetwork = BitcoinNetwork_default.MAINNET) {
    const response = await this.requester.makeRawRequest(
      BitcoinFeeEstimate,
      {
        bitcoin_network: bitcoinNetwork
      }
    );
    return FeeEstimateFromJson(response.bitcoin_fee_estimate);
  }
  /**
   * Gets an estimate of the fees that will be paid for a Lightning invoice.
   *
   * @param nodeId The node from where you want to send the payment.
   * @param encodedPaymentRequest The invoice you want to pay (as defined by the BOLT11 standard).
   * @param amountMsats If the invoice does not specify a payment amount, then the amount that you wish to pay,
   *     expressed in msats.
   * @returns An estimate of the fees that will be paid for a Lightning invoice.
   */
  async getLightningFeeEstimateForInvoice(nodeId, encodedPaymentRequest, amountMsats = void 0) {
    const response = await this.requester.makeRawRequest(
      LightningFeeEstimateForInvoice,
      {
        node_id: nodeId,
        encoded_payment_request: encodedPaymentRequest,
        amount_msats: amountMsats
      }
    );
    return CurrencyAmountFromJson(
      response.lightning_fee_estimate_for_invoice.lightning_fee_estimate_output_fee_estimate
    );
  }
  /**
   * Returns an estimate of the fees that will be paid to send a payment to
   * another Lightning node.
   *
   * @param nodeId The node from where you want to send the payment.
   * @param destinationNodePublicKey The public key of the node that you want to pay.
   * @param amountMsats The payment amount expressed in msats.
   * @returns An estimate of the fees that will be paid to send a payment to another Lightning node.
   */
  async getLightningFeeEstimateForNode(nodeId, destinationNodePublicKey, amountMsats) {
    const response = await this.requester.makeRawRequest(
      LightningFeeEstimateForNode,
      {
        node_id: nodeId,
        destination_node_public_key: destinationNodePublicKey,
        amount_msats: amountMsats
      }
    );
    return CurrencyAmountFromJson(
      response.lightning_fee_estimate_for_node.lightning_fee_estimate_output_fee_estimate
    );
  }
  /**
   * Returns an estimated amount for the L1 withdrawal fees for the specified node, amount, and
   * strategy.
   *
   * @param nodeId The node from which you'd like to make the withdrawal.
   * @param amountSats The amount you want to withdraw from this node in Satoshis. Use the special value -1 to withdrawal all funds from this node.
   * @param withdrawalMode The strategy that should be used to withdraw the funds from this node.
   * @returns An estimated amount for the L1 withdrawal fees for the specified node, amount, and strategy.
   */
  async getWithrawalFeeEstimate(nodeId, amountSats, withdrawalMode) {
    const response = await this.executeRawQuery({
      queryPayload: WithdrawalFeeEstimate,
      variables: {
        node_id: nodeId,
        amount_sats: amountSats,
        withdrawal_mode: withdrawalMode
      },
      constructObject: (response2) => {
        return WithdrawalFeeEstimateOutputFromJson(
          response2.withdrawal_fee_estimate
        );
      }
    });
    if (!response) {
      throw new LightsparkException(
        "WithdrawalFeeEstimateError",
        "Null or invalid fee estimate response from server"
      );
    }
    return response.feeEstimate;
  }
  /**
   * Directly unlocks a node with a signing private key or alias.
   *
   * @param nodeId The ID of the node to unlock.
   * @param signingPrivateKeyPEM The PEM-encoded signing private key.
   */
  async loadNodeKey(nodeId, signingPrivateKeyOrAlias) {
    await this.nodeKeyCache.loadKey(
      nodeId,
      signingPrivateKeyOrAlias,
      SigningKeyType2.RSASigningKey
    );
  }
  /**
   * Sends a lightning payment for a given invoice.
   *
   * Test mode note: For test mode, you can use the [createTestModeInvoice]
   * function to create an invoice you can pay in test mode.
   *
   * @param payerNodeId The ID of the node that will pay the invoice.
   * @param encodedInvoice The encoded invoice to pay.
   * @param maximumFeesMsats Maximum fees (in msats) to pay for the payment. This parameter is required.
   *     As guidance, a maximum fee of 16 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 16 to 160 sats.
   * @param timeoutSecs A timeout for the payment in seconds. Defaults to 60 seconds.
   * @param amountMsats The amount to pay in msats for a zero-amount invoice. Defaults to the full amount of the
   *     invoice. NOTE: This parameter can only be passed for a zero-amount
   *     invoice. Otherwise, the call will fail.
   * @returns An `OutgoingPayment` object if the payment was successful, or undefined if the payment failed.
   */
  async payInvoice(payerNodeId, encodedInvoice, maximumFeesMsats, timeoutSecs = 60, amountMsats = void 0) {
    if (!this.nodeKeyCache.hasKey(payerNodeId)) {
      throw new LightsparkSigningException3("Paying node is not unlocked");
    }
    const variables = {
      node_id: payerNodeId,
      encoded_invoice: encodedInvoice,
      timeout_secs: timeoutSecs,
      maximum_fees_msats: maximumFeesMsats
    };
    if (amountMsats !== void 0) {
      variables.amount_msats = amountMsats;
    }
    const response = await this.requester.makeRawRequest(
      PayInvoice,
      variables,
      payerNodeId
    );
    if (response.pay_invoice?.payment.outgoing_payment_failure_message) {
      throw new LightsparkException(
        "PaymentError",
        response.pay_invoice?.payment.outgoing_payment_failure_message.rich_text_text
      );
    }
    return response.pay_invoice && OutgoingPaymentFromJson(response.pay_invoice.payment);
  }
  /**
   * sends an UMA payment to a node on the Lightning Network,
   * based on the invoice (as defined by the BOLT11 specification) that you
   * provide.
   * This should only be used for paying UMA invoices,
   * with `payInvoice` preferred in the general case.
   *
   * @param payerNodeId The ID of the node that will pay the invoice.
   * @param encodedInvoice The encoded invoice to pay.
   * @param maximumFeesMsats Maximum fees (in msats) to pay for the payment. This parameter is required.
   *     As guidance, a maximum fee of 16 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 16 to 160 sats.
   * @param timeoutSecs A timeout for the payment in seconds. Defaults to 60 seconds.
   * @param amountMsats The amount to pay in msats for a zero-amount invoice. Defaults to the full amount of the
   *     invoice. NOTE: This parameter can only be passed for a zero-amount
   *     invoice. Otherwise, the call will fail.
   * @returns An `OutgoingPayment` object if the payment was successful, or undefined if the payment failed.
   */
  async payUmaInvoice(payerNodeId, encodedInvoice, maximumFeesMsats, timeoutSecs = 60, amountMsats = void 0) {
    if (!this.nodeKeyCache.hasKey(payerNodeId)) {
      throw new LightsparkSigningException3("Paying node is not unlocked");
    }
    const variables = {
      node_id: payerNodeId,
      encoded_invoice: encodedInvoice,
      timeout_secs: timeoutSecs,
      maximum_fees_msats: maximumFeesMsats
    };
    if (amountMsats !== void 0) {
      variables.amount_msats = amountMsats;
    }
    const response = await this.requester.makeRawRequest(
      PayUmaInvoice,
      variables,
      payerNodeId
    );
    if (response.pay_uma_invoice?.payment.outgoing_payment_failure_message) {
      throw new LightsparkException(
        "PaymentError",
        response.pay_uma_invoice?.payment.outgoing_payment_failure_message.rich_text_text
      );
    }
    return response.pay_uma_invoice && OutgoingPaymentFromJson(response.pay_uma_invoice.payment);
  }
  /**
   * Waits for a transaction to have a completed status, and returns the
   * transaction.
   *
   * @param transactionId The ID of the transaction to wait for
   * @param pollTimeoutSecs The timeout in seconds that we will wait before throwing an exception
   */
  async waitForTransactionComplete(transactionId, pollTimeoutSecs = 60) {
    const pollIntervalMs = 250;
    const pollMaxTimeouts = pollTimeoutSecs * 1e3 / pollIntervalMs;
    const pollIgnoreErrors = false;
    const transaction = await pollUntil(
      () => {
        return this.getTransaction(transactionId);
      },
      (current, response) => {
        if (current && [
          TransactionStatus_default.SUCCESS,
          TransactionStatus_default.CANCELLED,
          TransactionStatus_default.FAILED
        ].includes(current.status)) {
          return {
            stopPolling: true,
            value: current
          };
        }
        return response;
      },
      pollIntervalMs,
      pollMaxTimeouts,
      pollIgnoreErrors,
      () => new LightsparkException(
        "Timeout",
        "Timeout waiting for transaction to complete."
      )
    );
    return transaction;
  }
  /**
   * Sends a payment directly to a node on the Lightning Network through the
   * public key of the node without an invoice.
   *
   * @param payerNodeId The ID of the node that will send the payment.
   * @param destinationPublicKey The public key of the destination node.
   * @param timeoutSecs The timeout in seconds that we will try to make the payment.
   * @param amountMsats The amount to pay in msats.
   * @param maximumFeesMsats Maximum fees (in msats) to pay for the payment. This parameter is required.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @returns An `OutgoingPayment` object if the payment was successful, or undefined if the payment failed.
   */
  async sendPayment(payerNodeId, destinationPublicKey, timeoutSecs = 60, amountMsats, maximumFeesMsats) {
    if (!this.nodeKeyCache.hasKey(payerNodeId)) {
      throw new LightsparkSigningException3("Paying node is not unlocked");
    }
    const response = await this.requester.makeRawRequest(
      SendPayment,
      {
        node_id: payerNodeId,
        destination_public_key: destinationPublicKey,
        timeout_secs: timeoutSecs,
        amount_msats: amountMsats,
        maximum_fees_msats: maximumFeesMsats
      },
      payerNodeId
    );
    if (response.send_payment?.payment.outgoing_payment_failure_message) {
      throw new LightsparkException(
        "PaymentError",
        response.send_payment?.payment.outgoing_payment_failure_message.rich_text_text
      );
    }
    return response.send_payment && OutgoingPaymentFromJson(response.send_payment.payment);
  }
  /**
   * Creates an L1 Bitcoin wallet address for a given node which can be used to
   * deposit or withdraw funds.
   *
   * @param nodeId The ID of the node to create a wallet address for.
   * @returns A string containing the wallet address for the given node.
   */
  async createNodeWalletAddress(nodeId) {
    const response = await this.requester.makeRawRequest(
      CreateNodeWalletAddress,
      { node_id: nodeId }
    );
    return response.create_node_wallet_address.wallet_address;
  }
  /**
   * Withdraws funds from the account and sends it to the requested bitcoin
   * address.
   *
   * Depending on the chosen mode, it will first take the funds from the
   * wallet, and if applicable, close channels appropriately to recover enough
   * funds and reopen channels with the remaining funds.
   * The process is asynchronous and may take up to a few minutes.
   * You can check the progress by polling the `WithdrawalRequest` that is
   * created, or by subscribing to a webhook.
   *
   * @param nodeId The ID of the node from which to withdraw funds.
   * @param amountSats The amount of funds to withdraw in satoshis.
   * @param bitcoinAddress The Bitcoin address to withdraw funds to.
   * @param mode The mode to use for the withdrawal. See `WithdrawalMode` for more information.
   */
  async requestWithdrawal(nodeId, amountSats, bitcoinAddress, mode) {
    const response = await this.requester.makeRawRequest(
      RequestWithdrawal,
      {
        node_id: nodeId,
        amount_sats: amountSats,
        bitcoin_address: bitcoinAddress,
        withdrawal_mode: mode
      },
      nodeId
    );
    return WithdrawalRequestFromJson(response.request_withdrawal.request);
  }
  /**
   * Adds funds to a Lightspark node on the REGTEST network.
   * If the amount is not specified, 10,000,000 SATOSHI will be added.
   * This API only functions for nodes created on the REGTEST network and will
   * return an error when called for any non-REGTEST node.
   *
   * @param nodeId The ID of the node to fund. Must be a REGTEST node.
   * @param amountSats The amount of funds to add to the node in satoshis. Defaults to 10,000,000 SATOSHI.
   * @returns
   */
  async fundNode(nodeId, amountSats = void 0) {
    const response = await this.requester.makeRawRequest(FundNode, {
      node_id: nodeId,
      amount_sats: amountSats
    });
    return CurrencyAmountFromJson(response.fund_node.amount);
  }
  /**
   * Creates a new API token that can be used to authenticate requests for this
   * account when using the Lightspark APIs and SDKs.
   *
   * @param name Creates a new API token that can be used to authenticate requests for this account when using the
   *     Lightspark APIs and SDKs.
   * @param transact Whether the token should be able to transact or only view data.
   * @param testMode True if the token should be able to access only testnet false to access only mainnet.
   * @returns An object containing the API token and client secret.
   */
  async createApiToken(name, transact = true, testMode = true) {
    let permissions;
    if (transact && testMode) {
      permissions = [Permission_default.REGTEST_VIEW, Permission_default.REGTEST_TRANSACT];
    } else if (transact && !testMode) {
      permissions = [Permission_default.MAINNET_VIEW, Permission_default.MAINNET_TRANSACT];
    } else if (!transact && testMode) {
      permissions = [Permission_default.REGTEST_VIEW];
    } else {
      permissions = [Permission_default.MAINNET_VIEW];
    }
    const response = await this.requester.makeRawRequest(CreateApiToken, {
      name,
      permissions
    });
    return {
      apiToken: ApiTokenFromJson(response.create_api_token.api_token),
      clientSecret: response.create_api_token.client_secret
    };
  }
  /**
   * Deletes an existing API token from this account.
   *
   * @param id The ID of the API token to delete.
   */
  async deleteApiToken(id) {
    await this.requester.makeRawRequest(DeleteApiToken, { api_token_id: id });
  }
  /**
   * In test mode, generates a Lightning Invoice which can be paid by a local
   * node. This call is only valid in test mode.
   * You can then pay the invoice using [payInvoice].
   *
   * @param localNodeId The ID of the node that will pay the invoice.
   * @param amountMsats The amount to pay in milli-satoshis.
   * @param memo An optional memo to attach to the invoice.
   * @param invoiceType The type of invoice to create.
   */
  async createTestModeInvoice(localNodeId, amountMsats, memo = void 0, invoiceType = InvoiceType_default.STANDARD) {
    return await this.executeRawQuery({
      queryPayload: CreateTestModeInvoice,
      variables: {
        local_node_id: localNodeId,
        amount_msats: amountMsats,
        memo,
        invoice_type: invoiceType
      },
      constructObject: (responseJson) => {
        const encodedPaymentRequest = responseJson.create_test_mode_invoice?.encoded_payment_request;
        if (!encodedPaymentRequest) {
          throw new LightsparkException(
            "CreateTestModeInvoiceError",
            "Unable to create test mode invoice"
          );
        }
        return encodedPaymentRequest;
      }
    });
  }
  /**
   * In test mode, simulates a payment of a Lightning Invoice from another
   * node. This can only be used in test mode and should be used with invoices
   * generated by [createInvoice].
   *
   * @param localNodeId The ID of the node that will receive the payment.
   * @param encodedInvoice The encoded invoice to pay.
   * @param amountMsats The amount to pay in milli-satoshis for 0-amount invoices. This should be null for non-zero
   *     amount invoices.
   */
  async createTestModePayment(localNodeId, encodedInvoice, amountMsats = void 0) {
    return await this.executeRawQuery({
      queryPayload: CreateTestModePayment,
      variables: {
        local_node_id: localNodeId,
        encoded_invoice: encodedInvoice,
        amount_msats: amountMsats
      },
      constructObject: (responseJson) => {
        return IncomingPaymentFromJson(
          responseJson.create_test_mode_payment?.incoming_payment
        );
      }
    });
  }
  /**
   * Performs sanction screening on a lightning node against a given compliance provider.
   *
   * @param complianceProvider The provider that you want to use to perform the screening. You must have a valid
   *     API token for the provider set in your Lightspark account settings.
   * @param nodePubKey The public key of the node that needs to be screened.
   * @returns A RiskRating for the node.
   */
  async screenNode(complianceProvider, nodePubKey) {
    return await this.requester.executeQuery({
      queryPayload: ScreenNode,
      variables: {
        node_pubkey: nodePubKey,
        provider: complianceProvider
      },
      constructObject: (responseJson) => {
        if (responseJson.screen_node?.rating === void 0) {
          throw new LightsparkException(
            "ScreenNodeError",
            "Unable to screen node"
          );
        }
        const rating = responseJson.screen_node.rating;
        return RiskRating_default[rating] ?? RiskRating_default.FUTURE_VALUE;
      }
    });
  }
  /**
   * Registers a succeeded payment with a compliance provider for monitoring.
   *
   * @param complianceProvider The provider that you want to use to register the payment. You must have
   *     a valid API token for the provider set in your Lightspark account settings.
   * @param paymentId The unique ID of the payment
   * @param nodePubKey The public key of the counterparty node which is the recipient node if the
   *     payment is an outgoing payment and the sender node if the payment is an incoming payment.
   * @param paymentDirection Indicates whether the payment is an incoming or outgoing payment.
   * @returns The ID of the payment that was registered.
   */
  async registerPayment(complianceProvider, paymentId, nodePubKey, paymentDirection) {
    return await this.requester.executeQuery({
      queryPayload: RegisterPayment,
      variables: {
        payment_id: paymentId,
        node_pubkey: nodePubKey,
        direction: paymentDirection,
        provider: complianceProvider
      },
      constructObject: (responseJson) => {
        if (!responseJson.register_payment?.payment?.id) {
          throw new LightsparkException(
            "RegisterPaymentError",
            "Unable to register payment"
          );
        }
        return responseJson.register_payment.payment.id;
      }
    });
  }
  /**
   * Creates an UMA invitation. If you are part of the incentive program,
   * you should use [createUmaInvitationWithIncentives].
   *
   * @param inviterUma The UMA of the inviter.
   * @returns The invitation that was created.
   */
  async createUmaInvitation(inviterUma) {
    return await this.executeRawQuery({
      queryPayload: CreateUmaInvitation,
      variables: {
        inviterUma
      },
      constructObject: (responseJson) => {
        if (!responseJson.create_uma_invitation?.invitation) {
          throw new LightsparkException(
            "CreateUmaInvitationError",
            "Unable to create UMA invitation"
          );
        }
        return UmaInvitationFromJson(
          responseJson.create_uma_invitation?.invitation
        );
      }
    });
  }
  /**
   * Creates an UMA invitation as part of the incentive program.
   * @param inviterUma The UMA of the inviter.
   * @param inviterPhoneNumber The phone number of the inviter in E164 format.
   * @param inviterRegion The region of the inviter.
   * @returns The invitation that was created.
   */
  async createUmaInvitationWithIncentives(inviterUma, inviterPhoneNumber, inviterRegion) {
    const inviterPhoneHash = await this.hashPhoneNumber(inviterPhoneNumber);
    return await this.executeRawQuery({
      queryPayload: CreateUmaInvitationWithIncentives,
      variables: {
        inviterUma,
        inviterPhoneHash,
        inviterRegion
      },
      constructObject: (responseJson) => {
        if (!responseJson.create_uma_invitation_with_incentives?.invitation) {
          throw new LightsparkException(
            "CreateUmaInvitationError",
            "Unable to create UMA invitation"
          );
        }
        return UmaInvitationFromJson(
          responseJson.create_uma_invitation_with_incentives?.invitation
        );
      }
    });
  }
  /**
   * Claims an UMA invitation. If you are part of the incentive program,
   * you should use [claimUmaInvitationWithIncentives].
   *
   * @param invitationCode The invitation code to claim.
   * @param inviteeUma The UMA of the invitee.
   * @returns The invitation that was claimed.
   */
  async claimUmaInvitation(invitationCode, inviteeUma) {
    return await this.executeRawQuery({
      queryPayload: ClaimUmaInvitation,
      variables: {
        invitationCode,
        inviteeUma
      },
      constructObject: (responseJson) => {
        if (!responseJson.claim_uma_invitation?.invitation) {
          throw new LightsparkException(
            "ClaimUmaInvitationError",
            "Unable to claim UMA invitation"
          );
        }
        return UmaInvitationFromJson(
          responseJson.claim_uma_invitation?.invitation
        );
      }
    });
  }
  /**
   * Claims an UMA invitation as part of the incentive program.
   *
   * @param invitationCode The invitation code to claim.
   * @param inviteeUma The UMA of the invitee.
   * @param inviteePhoneNumber The phone number of the invitee in E164 format.
   * @param inviteeRegion The region of the invitee.
   * @returns The invitation that was claimed.
   */
  async claimUmaInvitationWithIncentives(invitationCode, inviteeUma, inviteePhoneNumber, inviteeRegion) {
    const inviteePhoneHash = await this.hashPhoneNumber(inviteePhoneNumber);
    return await this.executeRawQuery({
      queryPayload: ClaimUmaInvitationWithIncentives,
      variables: {
        invitationCode,
        inviteeUma,
        inviteePhoneHash,
        inviteeRegion
      },
      constructObject: (responseJson) => {
        if (!responseJson.claim_uma_invitation_with_incentives?.invitation) {
          throw new LightsparkException(
            "ClaimUmaInvitationError",
            "Unable to claim UMA invitation"
          );
        }
        return UmaInvitationFromJson(
          responseJson.claim_uma_invitation_with_incentives?.invitation
        );
      }
    });
  }
  /**
   * Fetches an UMA invitation by its invitation code.
   *
   * @param invitationCode The code of the invitation to fetch.
   * @returns The invitation with the given code, or null if no invitation exists with that code.
   */
  async fetchUmaInvitation(invitationCode) {
    return await this.executeRawQuery({
      queryPayload: FetchUmaInvitation,
      variables: {
        invitationCode
      },
      constructObject: (responseJson) => {
        if (!responseJson.uma_invitation_by_code) {
          return null;
        }
        return UmaInvitationFromJson(responseJson.uma_invitation_by_code);
      }
    });
  }
  /**
   * Fetches a created invoice by its payment hash.
   *
   * @param paymentHash
   * @returns The invoice if there is one corresponding to the payment hash, or null if no invoice exists with that payment hash.
   */
  async invoiceForPaymentHash(paymentHash) {
    return await this.executeRawQuery({
      queryPayload: InvoiceForPaymentHash,
      variables: {
        payment_hash: paymentHash
      },
      constructObject: (responseJson) => {
        if (!responseJson.invoice_for_payment_hash || !responseJson.invoice_for_payment_hash.invoice) {
          return null;
        }
        return InvoiceFromJson(responseJson.invoice_for_payment_hash.invoice);
      }
    });
  }
  /**
   * Fetches outgoing payments for a given payment hash if there are any.
   *
   * @param paymentHash
   * @param statuses Filter to only include payments with the given statuses. If not provided, all statuses are included.
   */
  async outgoingPaymentsForPaymentHash(paymentHash, statuses = void 0) {
    return await this.executeRawQuery({
      queryPayload: OutgoingPaymentsForPaymentHash,
      variables: {
        payment_hash: paymentHash,
        statuses
      },
      constructObject: (responseJson) => {
        if (!responseJson.outgoing_payments_for_payment_hash || !responseJson.outgoing_payments_for_payment_hash.payments) {
          return [];
        }
        return responseJson.outgoing_payments_for_payment_hash.payments.map(
          (payment) => OutgoingPaymentFromJson(payment)
        );
      }
    });
  }
  async hashPhoneNumber(e164PhoneNumber) {
    const e164PhoneRegex = /^\+[1-9]\d{1,14}$/;
    if (!e164PhoneRegex.test(e164PhoneNumber)) {
      throw new LightsparkException(
        "InvalidPhoneNumber",
        "Invalid phone number. Phone number must be in E164 format."
      );
    }
    return await createSha256Hash(e164PhoneNumber, true);
  }
  /**
   * Executes a raw `Query` against the Lightspark API.
   *
   * This generally should not be used directly,
   * but is exposed for advanced use cases and for internal use to retrieve
   * complex fields from objects.
   *
   * @param query The `Query` to execute.
   * @returns The result of the query.
   */
  executeRawQuery(query) {
    return this.requester.executeQuery(query);
  }
};
var client_default = LightsparkClient;

// src/webhooks.ts
import { LightsparkSigningException as LightsparkSigningException4, isNode } from "@lightsparkdev/core";
var WEBHOOKS_SIGNATURE_HEADER = "lightspark-signature";
var verifyAndParseWebhook = async (data, hexdigest, webhook_secret) => {
  const { createHmac } = await import("crypto");
  const sig = createHmac("sha256", webhook_secret).update(data).digest("hex");
  if (sig.toLowerCase() !== hexdigest.toLowerCase()) {
    throw new Error("Webhook message hash does not match signature");
  }
  return parseWebhook(data);
};
var parseWebhook = async (data) => {
  let td = TextDecoder;
  if (typeof td === "undefined") {
    const tdModule = await import("./text-encoding-26SMKBAQ.js");
    td = tdModule.TextDecoder;
  }
  const dataStr = new td().decode(data);
  const event = JSON.parse(dataStr);
  return {
    event_type: WebhookEventType[event.event_type],
    event_id: event.event_id,
    timestamp: new Date(event.timestamp),
    entity_id: event.entity_id,
    wallet_id: event.wallet_id
  };
};
var RemoteSigningWebhookHandler = class {
  client;
  #masterSeed;
  validator;
  constructor(client, masterSeed, validator) {
    this.client = client;
    this.#masterSeed = masterSeed;
    this.validator = validator;
  }
  async handleWebhookRequest(data, webhookSignature, webhookSecret) {
    if (!isNode) {
      throw new LightsparkSigningException4(
        "Environment not supported for handling webhooks."
      );
    }
    const { wasm_handle_remote_signing_webhook_event } = await import("@lightsparkdev/crypto-wasm");
    const response = wasm_handle_remote_signing_webhook_event(
      data,
      webhookSignature,
      webhookSecret,
      this.#masterSeed,
      this.validator
    );
    if (!response) {
      return;
    }
    const variables = JSON.parse(response.variables);
    return this.client.executeRawQuery({
      queryPayload: response.query,
      variables,
      constructObject: (rawData) => rawData
    });
  }
};
export {
  Account_default as Account,
  AccountTokenAuthProvider_default as AccountTokenAuthProvider,
  BitcoinNetwork_default as BitcoinNetwork,
  Channel_default as Channel,
  ChannelStatus_default as ChannelStatus,
  ComplianceProvider_default as ComplianceProvider,
  CurrencyUnit_default as CurrencyUnit,
  GraphNode_default as GraphNode,
  HtlcAttemptFailureCode_default as HtlcAttemptFailureCode,
  IncentivesIneligibilityReason_default as IncentivesIneligibilityReason,
  IncentivesStatus_default as IncentivesStatus,
  IncomingPayment_default as IncomingPayment,
  IncomingPaymentAttemptStatus_default as IncomingPaymentAttemptStatus,
  InvoiceType_default as InvoiceType,
  LightningPaymentDirection_default as LightningPaymentDirection,
  client_default as LightsparkClient,
  LightsparkNodeStatus_default as LightsparkNodeStatus,
  LightsparkNodeWithOSK_default as LightsparkNodeWithOSK,
  LightsparkNodeWithRemoteSigning_default as LightsparkNodeWithRemoteSigning,
  NodeAddressType_default as NodeAddressType,
  OnChainFeeTarget_default as OnChainFeeTarget,
  OutgoingPayment_default as OutgoingPayment,
  OutgoingPaymentAttempt_default as OutgoingPaymentAttempt,
  OutgoingPaymentAttemptStatus_default as OutgoingPaymentAttemptStatus,
  PaymentDirection_default as PaymentDirection,
  PaymentFailureReason_default as PaymentFailureReason,
  PaymentRequestStatus_default as PaymentRequestStatus,
  Permission_default as Permission,
  RegionCode_default as RegionCode,
  RemoteSigningSubEventType_default as RemoteSigningSubEventType,
  RemoteSigningWebhookHandler,
  RiskRating_default as RiskRating,
  RoutingTransactionFailureReason_default as RoutingTransactionFailureReason,
  SignablePayloadStatus_default as SignablePayloadStatus,
  TransactionStatus_default as TransactionStatus,
  TransactionType_default as TransactionType,
  WEBHOOKS_SIGNATURE_HEADER,
  Wallet_default as Wallet,
  WalletStatus_default as WalletStatus,
  WebhookEventType_default as WebhookEventType,
  WithdrawalMode_default as WithdrawalMode,
  WithdrawalRequest_default as WithdrawalRequest,
  WithdrawalRequestStatus_default as WithdrawalRequestStatus,
  assertValidBitcoinNetwork,
  getApiTokenQuery,
  getAuditLogActorQuery,
  getBitcoinNetworkOrThrow,
  getChannelClosingTransactionQuery,
  getChannelOpeningTransactionQuery,
  getChannelSnapshotQuery,
  getDepositQuery,
  getHopQuery,
  getIncomingPaymentAttemptQuery,
  getInvoiceQuery,
  getLightningTransactionQuery,
  getLightsparkNodeOwnerQuery,
  getLightsparkNodeQuery,
  getNodeQuery,
  getOnChainTransactionQuery,
  getPaymentRequestQuery,
  getRoutingTransactionQuery,
  getSignablePayloadQuery,
  getSignableQuery,
  getTransactionQuery,
  getUmaInvitationQuery,
  getWithdrawalQuery,
  isBitcoinNetwork,
  verifyAndParseWebhook
};
