declare const ConfigKeys: {
    readonly LoggingEnabled: "lightspark-logging-enabled";
    readonly ConsoleToolsEnabled: "lightspark-console-tools-enabled";
};
type ConfigKeys = (typeof ConfigKeys)[keyof typeof ConfigKeys];

declare const b64decode: (encoded: string) => Uint8Array;
declare const urlsafe_b64decode: (encoded: string) => Uint8Array;
declare const b64encode: (data: ArrayBuffer) => string;

type SourceData = Uint8Array | string;
declare function createSha256Hash(data: SourceData): Promise<Uint8Array>;
declare function createSha256Hash(data: SourceData, asHex: true): Promise<string>;

declare const defaultCurrencyCode = "USD";
declare const CurrencyUnit: {
    readonly FUTURE_VALUE: "FUTURE_VALUE";
    readonly BITCOIN: "BITCOIN";
    readonly SATOSHI: "SATOSHI";
    readonly MILLISATOSHI: "MILLISATOSHI";
    readonly USD: "USD";
    readonly NANOBITCOIN: "NANOBITCOIN";
    readonly MICROBITCOIN: "MICROBITCOIN";
    readonly MILLIBITCOIN: "MILLIBITCOIN";
    readonly Bitcoin: "BITCOIN";
    readonly Microbitcoin: "MICROBITCOIN";
    readonly Millibitcoin: "MILLIBITCOIN";
    readonly Millisatoshi: "MILLISATOSHI";
    readonly Nanobitcoin: "NANOBITCOIN";
    readonly Satoshi: "SATOSHI";
    readonly Usd: "USD";
};
type CurrencyUnitType = (typeof CurrencyUnit)[keyof typeof CurrencyUnit];
type SDKCurrencyAmountType = {
    originalValue: number;
    originalUnit: CurrencyUnitType;
    preferredCurrencyUnit: CurrencyUnitType;
    preferredCurrencyValueRounded: number;
    preferredCurrencyValueApprox: number;
};
declare function convertCurrencyAmountValue(fromUnit: CurrencyUnitType, toUnit: CurrencyUnitType, amount: number, centsPerBtc?: number): number;
declare const convertCurrencyAmount: (from: SDKCurrencyAmountType, toUnit: CurrencyUnitType) => SDKCurrencyAmountType;
type CurrencyMap = {
    sats: number;
    msats: number;
    btc: number;
    [CurrencyUnit.BITCOIN]: number;
    [CurrencyUnit.SATOSHI]: number;
    [CurrencyUnit.MILLISATOSHI]: number;
    [CurrencyUnit.MICROBITCOIN]: number;
    [CurrencyUnit.MILLIBITCOIN]: number;
    [CurrencyUnit.NANOBITCOIN]: number;
    [CurrencyUnit.USD]: number;
    [CurrencyUnit.FUTURE_VALUE]: number;
    formatted: {
        sats: string;
        msats: string;
        btc: string;
        [CurrencyUnit.BITCOIN]: string;
        [CurrencyUnit.SATOSHI]: string;
        [CurrencyUnit.MILLISATOSHI]: string;
        [CurrencyUnit.MILLIBITCOIN]: string;
        [CurrencyUnit.MICROBITCOIN]: string;
        [CurrencyUnit.NANOBITCOIN]: string;
        [CurrencyUnit.USD]: string;
        [CurrencyUnit.FUTURE_VALUE]: string;
    };
    isZero: boolean;
    isLessThan: (other: CurrencyMap | CurrencyAmountObj | number) => boolean;
    isGreaterThan: (other: CurrencyMap | CurrencyAmountObj | number) => boolean;
    isEqualTo: (other: CurrencyMap | CurrencyAmountObj | number) => boolean;
    type: "CurrencyMap";
};
type CurrencyAmountObj = {
    value?: number | string | null;
    unit?: CurrencyUnitType;
    __typename?: "CurrencyAmount" | undefined;
};
type CurrencyAmountArg = CurrencyAmountObj | SDKCurrencyAmountType | undefined | null;
declare function isCurrencyAmountObj(arg: unknown): arg is CurrencyAmountObj;
declare function isSDKCurrencyAmount(arg: unknown): arg is SDKCurrencyAmountType;
declare function mapCurrencyAmount(currencyAmountArg: CurrencyAmountArg, centsPerBtc?: number): CurrencyMap;
declare const isCurrencyMap: (currencyMap: unknown) => currencyMap is CurrencyMap;
declare const abbrCurrencyUnit: (unit: CurrencyUnitType) => "USD" | "BTC" | "SAT" | "MSAT" | "Unsupported CurrencyUnit";
type FormatCurrencyStrOptions = {
    precision?: number | "full" | undefined;
    compact?: boolean | undefined;
    showBtcSymbol?: boolean | undefined;
};
declare function formatCurrencyStr(amount: CurrencyAmountArg, options?: FormatCurrencyStrOptions): string;
declare function separateCurrencyStrParts(currencyStr: string): {
    symbol: string;
    amount: string;
};
declare function localeToCurrencySymbol(locale: string): string;

declare const isBrowser: boolean;
declare const isNode: boolean;
declare const isTest: boolean;

type Maybe<T> = T | null | undefined;
type ExpandRecursively<T> = T extends object ? T extends infer O ? {
    [K in keyof O]: ExpandRecursively<O[K]>;
} : never : T;
type ById<T> = {
    [id: string]: T;
};
type OmitTypename<T> = Omit<T, "__typename">;
declare const isType: <T extends string>(typename: T) => <N extends {
    __typename: string;
}>(node: N | null | undefined) => node is Extract<N, {
    __typename: T;
}>;
type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
type JSONLiteral = string | number | boolean | null;
type JSONType = JSONLiteral | JSONType[] | {
    [key: string]: JSONType;
};
type JSONObject = {
    [key: string]: JSONType;
};
type NN<T> = NonNullable<T>;
declare function notNullUndefined<TValue>(value: TValue | null | undefined): value is TValue;
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type Complete<T> = {
    [P in keyof T]-?: NonNullable<T[P]>;
};

declare const isError: (e: unknown) => e is Error;
type ErrorWithMessage = {
    message: string;
};
declare const isErrorWithMessage: (e: unknown) => e is ErrorWithMessage;
declare const getErrorMsg: (e: unknown) => string;
declare const isErrorMsg: (e: unknown, msg: string) => boolean;
declare function errorToJSON(err: unknown): JSONType;

declare const bytesToHex: (bytes: Uint8Array) => string;
declare const hexToBytes: (hex: string) => Uint8Array;

declare function getLocalStorageConfigItem(key: ConfigKeys): boolean;
declare function getLocalStorageBoolean(key: string): boolean;
declare function setLocalStorageBoolean(key: string, value: boolean): void;
declare const deleteLocalStorageItem: (key: string) => void;

declare function getCurrentLocale(): string;

declare const countryCodesToCurrencyCodes: {
    readonly AD: "EUR";
    readonly AR: "ARS";
    readonly AS: "USD";
    readonly AT: "EUR";
    readonly AU: "AUD";
    readonly AX: "EUR";
    readonly BE: "EUR";
    readonly BL: "EUR";
    readonly BQ: "USD";
    readonly BR: "BRL";
    readonly CA: "CAD";
    readonly CO: "COP";
    readonly CY: "EUR";
    readonly DE: "EUR";
    readonly EC: "USD";
    readonly EE: "EUR";
    readonly ES: "EUR";
    readonly FI: "EUR";
    readonly FM: "USD";
    readonly FR: "EUR";
    readonly GB: "GBP";
    readonly GF: "EUR";
    readonly GG: "GBP";
    readonly GP: "EUR";
    readonly GR: "EUR";
    readonly GS: "GBP";
    readonly GU: "USD";
    readonly IE: "EUR";
    readonly IM: "GBP";
    readonly IN: "INR";
    readonly IO: "USD";
    readonly IT: "EUR";
    readonly JE: "GBP";
    readonly LT: "EUR";
    readonly LU: "EUR";
    readonly LV: "EUR";
    readonly MC: "EUR";
    readonly ME: "EUR";
    readonly MF: "EUR";
    readonly MH: "USD";
    readonly MP: "USD";
    readonly MQ: "EUR";
    readonly MT: "EUR";
    readonly MX: "MXN";
    readonly NF: "AUD";
    readonly NL: "EUR";
    readonly NR: "AUD";
    readonly PM: "EUR";
    readonly PR: "USD";
    readonly PT: "EUR";
    readonly PW: "USD";
    readonly RE: "EUR";
    readonly SI: "EUR";
    readonly SK: "EUR";
    readonly SM: "EUR";
    readonly TC: "USD";
    readonly TF: "EUR";
    readonly TL: "USD";
    readonly TV: "AUD";
    readonly UM: "USD";
    readonly US: "USD";
    readonly VA: "EUR";
    readonly VG: "USD";
    readonly VI: "USD";
    readonly YT: "EUR";
};
type CurrencyLocales = keyof typeof countryCodesToCurrencyCodes;
type CurrencyCodes = (typeof countryCodesToCurrencyCodes)[CurrencyLocales];
declare function localeToCurrencyCode(locale: string): CurrencyCodes;

declare function clamp(val: number, min: number, max: number): number;
declare function linearInterpolate(value: number, fromRangeStart: number, fromRangeEnd: number, toRangeStart: number, toRangeEnd: number): number;
declare function round(num: number, decimalPlaces?: number): number;
declare function isNumber(value: unknown): value is number;

type GetValueResult<T> = {
    stopPolling: boolean;
    value: null | T;
};
declare function pollUntil<D extends () => Promise<unknown>, T>(asyncFn: D, getValue: (data: Awaited<ReturnType<D>>, response: {
    stopPolling: boolean;
    value: null | T;
}) => GetValueResult<T>, maxPolls?: number, pollIntervalMs?: number, ignoreErrors?: boolean | ((e: unknown) => boolean), getMaxPollsError?: (maxPolls: number) => Error): Promise<T>;

declare function sleep(ms: number): Promise<unknown>;

declare function lsidToUUID(lsid: string): string;

declare function isUint8Array(variable: unknown): variable is Uint8Array;

export { isType as $, isErrorMsg as A, errorToJSON as B, ConfigKeys as C, bytesToHex as D, hexToBytes as E, getLocalStorageConfigItem as F, getLocalStorageBoolean as G, setLocalStorageBoolean as H, deleteLocalStorageItem as I, getCurrentLocale as J, countryCodesToCurrencyCodes as K, CurrencyLocales as L, CurrencyCodes as M, localeToCurrencyCode as N, clamp as O, linearInterpolate as P, round as Q, isNumber as R, SDKCurrencyAmountType as S, pollUntil as T, sleep as U, lsidToUUID as V, isUint8Array as W, Maybe as X, ExpandRecursively as Y, ById as Z, OmitTypename as _, b64encode as a, DeepPartial as a0, JSONLiteral as a1, JSONType as a2, JSONObject as a3, NN as a4, notNullUndefined as a5, PartialBy as a6, Complete as a7, b64decode as b, createSha256Hash as c, defaultCurrencyCode as d, CurrencyUnit as e, CurrencyUnitType as f, convertCurrencyAmountValue as g, convertCurrencyAmount as h, CurrencyMap as i, CurrencyAmountObj as j, CurrencyAmountArg as k, isCurrencyAmountObj as l, isSDKCurrencyAmount as m, mapCurrencyAmount as n, isCurrencyMap as o, abbrCurrencyUnit as p, formatCurrencyStr as q, localeToCurrencySymbol as r, separateCurrencyStrParts as s, isBrowser as t, urlsafe_b64decode as u, isNode as v, isTest as w, isError as x, isErrorWithMessage as y, getErrorMsg as z };
