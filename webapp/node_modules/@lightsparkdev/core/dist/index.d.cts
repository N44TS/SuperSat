export { Z as ById, a7 as Complete, C as ConfigKeys, k as CurrencyAmountArg, j as CurrencyAmountObj, M as CurrencyCodes, L as CurrencyLocales, i as CurrencyMap, e as CurrencyUnit, f as CurrencyUnitType, a0 as DeepPartial, Y as ExpandRecursively, a1 as JSONLiteral, a3 as JSONObject, a2 as JSONType, X as Maybe, a4 as NN, _ as OmitTypename, a6 as PartialBy, S as SDKCurrencyAmountType, p as abbrCurrencyUnit, b as b64decode, a as b64encode, D as bytesToHex, O as clamp, h as convertCurrencyAmount, g as convertCurrencyAmountValue, K as countryCodesToCurrencyCodes, c as createSha256Hash, d as defaultCurrencyCode, I as deleteLocalStorageItem, B as errorToJSON, q as formatCurrencyStr, J as getCurrentLocale, z as getErrorMsg, G as getLocalStorageBoolean, F as getLocalStorageConfigItem, E as hexToBytes, t as isBrowser, l as isCurrencyAmountObj, o as isCurrencyMap, x as isError, A as isErrorMsg, y as isErrorWithMessage, v as isNode, R as isNumber, m as isSDKCurrencyAmount, w as isTest, $ as isType, W as isUint8Array, P as linearInterpolate, N as localeToCurrencyCode, r as localeToCurrencySymbol, V as lsidToUUID, n as mapCurrencyAmount, a5 as notNullUndefined, T as pollUntil, Q as round, s as separateCurrencyStrParts, H as setLocalStorageBoolean, U as sleep, u as urlsafe_b64decode } from './index-4698c2db.js';
import { Observable } from 'zen-observable-ts';

declare class LightsparkException extends Error {
    code: string;
    message: string;
    extraInfo: Record<string, unknown> | undefined;
    constructor(code: string, message: string, extraInfo?: Record<string, unknown>);
}

type GetLoggingEnabled = (() => Promise<boolean> | boolean) | undefined;
declare enum LoggingLevel {
    Trace = 0,
    Info = 1
}
declare class Logger {
    context: string;
    loggingEnabled: boolean;
    loggingLevel: LoggingLevel;
    constructor(loggerContext: string, getLoggingEnabled?: GetLoggingEnabled);
    setLevel(level: LoggingLevel): void;
    updateLoggingEnabled(getLoggingEnabled: GetLoggingEnabled): Promise<void>;
    trace(message: string, ...rest: unknown[]): void;
    info(message: string, ...rest: unknown[]): void;
}

declare enum ServerEnvironment {
    PRODUCTION = "production",
    DEV = "dev"
}
declare const apiDomainForEnvironment: (environment: ServerEnvironment) => string;

type Headers = Record<string, string>;
type WsConnectionParams = Record<string, unknown>;
interface AuthProvider {
    addAuthHeaders(headers: Headers): Promise<Headers>;
    isAuthorized(): Promise<boolean>;
    addWsConnectionParams(params: WsConnectionParams): Promise<WsConnectionParams>;
}

declare class LightsparkAuthException extends LightsparkException {
    constructor(message: string, extraInfo?: Record<string, unknown>);
}

declare class StubAuthProvider implements AuthProvider {
    addAuthHeaders(headers: Headers): Promise<Headers>;
    isAuthorized(): Promise<boolean>;
    addWsConnectionParams(params: WsConnectionParams): Promise<WsConnectionParams>;
}

type OnlyKey = {
    key: string;
    alias?: never;
};
type OnlyAlias = {
    key?: never;
    alias: string;
};
type KeyOrAliasType = OnlyKey | OnlyAlias;
declare const KeyOrAlias: {
    key: (key: string) => OnlyKey;
    alias: (alias: string) => OnlyAlias;
};

declare class LightsparkSigningException extends LightsparkException {
    constructor(message: string, extraInfo?: Record<string, unknown>);
}

type GeneratedKeyPair = {
    publicKey: CryptoKey | string;
    privateKey: CryptoKey | string;
    keyAlias?: string;
};
type CryptoInterface = {
    decryptSecretWithNodePassword: (cipher: string, encryptedSecret: string, nodePassword: string) => Promise<ArrayBuffer | null>;
    generateSigningKeyPair: () => Promise<GeneratedKeyPair>;
    serializeSigningKey: (key: CryptoKey | string, format: "pkcs8" | "spki") => Promise<ArrayBuffer>;
    getNonce: () => Promise<number>;
    sign: (keyOrAlias: CryptoKey | string, data: Uint8Array) => Promise<ArrayBuffer>;
    importPrivateSigningKey: (keyData: Uint8Array) => Promise<CryptoKey | string>;
};
declare function decryptSecretWithNodePassword(cipher: string, encryptedSecret: string, nodePassword: string): Promise<ArrayBuffer | null>;
declare const DefaultCrypto: {
    decryptSecretWithNodePassword: typeof decryptSecretWithNodePassword;
    generateSigningKeyPair: () => Promise<GeneratedKeyPair>;
    serializeSigningKey: (key: CryptoKey | string, format: "pkcs8" | "spki") => Promise<ArrayBuffer>;
    getNonce: () => Promise<number>;
    sign: (keyOrAlias: CryptoKey | string, data: Uint8Array) => Promise<ArrayBuffer>;
    importPrivateSigningKey: (keyData: Uint8Array) => Promise<CryptoKey | string>;
};

interface Alias {
    alias: string;
}
declare abstract class SigningKey {
    readonly type: SigningKeyType;
    constructor(type: SigningKeyType);
    abstract sign(data: Uint8Array): Promise<ArrayBuffer>;
}
declare class RSASigningKey extends SigningKey {
    private readonly privateKey;
    private readonly cryptoImpl;
    constructor(privateKey: CryptoKey | Alias, cryptoImpl: CryptoInterface);
    sign(data: Uint8Array): Promise<ArrayBuffer>;
}
declare class Secp256k1SigningKey extends SigningKey {
    private readonly privateKey;
    constructor(privateKey: string);
    sign(data: Uint8Array): Promise<Uint8Array>;
}

declare enum SigningKeyType {
    RSASigningKey = "RSASigningKey",
    Secp256k1SigningKey = "Secp256k1SigningKey"
}

declare class NodeKeyCache {
    private readonly cryptoImpl;
    private idToKey;
    constructor(cryptoImpl?: CryptoInterface);
    loadKey(id: string, keyOrAlias: KeyOrAliasType, signingKeyType: SigningKeyType): Promise<SigningKey | null>;
    getKey(id: string): SigningKey | undefined;
    hasKey(id: string): boolean;
    private stripPemTags;
}

type Query<T> = {
    /** The string representation of the query payload for graphQL. **/
    queryPayload: string;
    /** The variables that will be passed to the query. **/
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The function that will be called to construct the object from the
     * response. *
     */
    constructObject: (rawData: any) => T;
    /** The id of the node that will be used to sign the query. **/
    signingNodeId?: string;
    /** True if auth headers should be omitted for this query. **/
    skipAuth?: boolean;
};

declare class Requester {
    private readonly nodeKeyCache;
    private readonly schemaEndpoint;
    private readonly sdkUserAgent;
    private readonly authProvider;
    private readonly baseUrl;
    private readonly cryptoImpl;
    private readonly wsClient;
    constructor(nodeKeyCache: NodeKeyCache, schemaEndpoint: string, sdkUserAgent: string, authProvider?: AuthProvider, baseUrl?: string, cryptoImpl?: CryptoInterface);
    executeQuery<T>(query: Query<T>): Promise<T | null>;
    subscribe<T>(queryPayload: string, variables?: {
        [key: string]: unknown;
    }): Observable<{
        data: T;
    }>;
    makeRawRequest(queryPayload: string, variables?: {
        [key: string]: unknown;
    }, signingNodeId?: string | undefined, skipAuth?: boolean): Promise<any>;
    private getSdkUserAgent;
    private stripProtocol;
    private addSigningDataIfNeeded;
}

export { AuthProvider, CryptoInterface, DefaultCrypto, GeneratedKeyPair, KeyOrAlias, KeyOrAliasType, LightsparkAuthException, LightsparkException, LightsparkSigningException, Logger, LoggingLevel, NodeKeyCache, Query, RSASigningKey, Requester, Secp256k1SigningKey, ServerEnvironment, SigningKey, SigningKeyType, StubAuthProvider, apiDomainForEnvironment };
