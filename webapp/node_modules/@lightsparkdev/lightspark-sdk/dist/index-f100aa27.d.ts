import { Maybe, Query, AuthProvider, CryptoInterface, SigningKey, KeyOrAliasType } from '@lightsparkdev/core';
import Observable from 'zen-observable';
import { B as BitcoinNetwork } from './BitcoinNetwork-4f6ea015.js';

/**
 * Args for creating a new SigningKeyLoader. Must be one of the sub types.
 */
type SigningKeyLoaderArgs = NodeIdAndPasswordSigningKeyLoaderArgs | MasterSeedSigningKeyLoaderArgs;
/**
 * Args for creating a new SigningKeyLoader from a node ID and password.
 * This cannot be used if you are using remote signing.
 * It is used to recover an RSA operation signing key using the password you
 * chose when setting up your node. For REGTEST nodes, the password is
 * "1234!@#$".
 */
interface NodeIdAndPasswordSigningKeyLoaderArgs {
    password: string;
}
/**
 * Args for creating a new SigningKeyLoader from a master seed and network.
 * This should be used if you are using remote signing,
 * rather than an RSA operation signing key.
 */
interface MasterSeedSigningKeyLoaderArgs {
    masterSeed: Uint8Array;
    network: BitcoinNetwork;
}

/** This enum identifies the unit of currency associated with a CurrencyAmount. **/
declare enum CurrencyUnit {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /**
     * Bitcoin is the cryptocurrency native to the Bitcoin network. It is used as the native medium
     * for value transfer for the Lightning Network. *
     */
    BITCOIN = "BITCOIN",
    /**
     * 0.00000001 (10e-8) Bitcoin or one hundred millionth of a Bitcoin. This is the unit most
     * commonly used in Lightning transactions. *
     */
    SATOSHI = "SATOSHI",
    /**
     * 0.001 Satoshi, or 10e-11 Bitcoin. We recommend using the Satoshi unit instead when possible. *
     */
    MILLISATOSHI = "MILLISATOSHI",
    /** United States Dollar. **/
    USD = "USD",
    /**
     * 0.000000001 (10e-9) Bitcoin or a billionth of a Bitcoin. We recommend using the Satoshi unit
     * instead when possible. *
     */
    NANOBITCOIN = "NANOBITCOIN",
    /**
     * 0.000001 (10e-6) Bitcoin or a millionth of a Bitcoin. We recommend using the Satoshi unit
     * instead when possible. *
     */
    MICROBITCOIN = "MICROBITCOIN",
    /**
     * 0.001 (10e-3) Bitcoin or a thousandth of a Bitcoin. We recommend using the Satoshi unit instead
     * when possible. *
     */
    MILLIBITCOIN = "MILLIBITCOIN"
}

/** This object represents the value and unit for an amount of currency. **/
interface CurrencyAmount {
    /** The original numeric value for this CurrencyAmount. **/
    originalValue: number;
    /** The original unit of currency for this CurrencyAmount. **/
    originalUnit: CurrencyUnit;
    /** The unit of user's preferred currency. **/
    preferredCurrencyUnit: CurrencyUnit;
    /**
     * The rounded numeric value for this CurrencyAmount in the very base level of user's preferred
     * currency. For example, for USD, the value will be in cents.
     **/
    preferredCurrencyValueRounded: number;
    /**
     * The approximate float value for this CurrencyAmount in the very base level of user's
     * preferred currency. For example, for USD, the value will be in cents.
     **/
    preferredCurrencyValueApprox: number;
}

declare enum LightsparkNodeStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    CREATED = "CREATED",
    DEPLOYED = "DEPLOYED",
    STARTED = "STARTED",
    SYNCING = "SYNCING",
    READY = "READY",
    STOPPED = "STOPPED",
    TERMINATED = "TERMINATED",
    TERMINATING = "TERMINATING",
    WALLET_LOCKED = "WALLET_LOCKED",
    FAILED_TO_DEPLOY = "FAILED_TO_DEPLOY"
}

/**
 * This is an enum of the potential types of addresses that a node on the Lightning Network can
 * have. *
 */
declare enum NodeAddressType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    IPV4 = "IPV4",
    IPV6 = "IPV6",
    TOR = "TOR"
}

type AccountDashboard = {
    id: string;
    name: Maybe<string>;
    nodes: {
        id: string;
        color: Maybe<string>;
        displayName: string;
        publicKey: Maybe<string>;
        status: Maybe<LightsparkNodeStatus>;
        addresses: {
            count: number;
            entities: {
                address: string;
                type: NodeAddressType;
            }[];
        };
        localBalance: Maybe<CurrencyAmount>;
        remoteBalance: Maybe<CurrencyAmount>;
        blockchainBalance: {
            availableBalance: Maybe<CurrencyAmount>;
            totalBalance: Maybe<CurrencyAmount>;
        } | null;
    }[];
    blockchainBalance: Maybe<{
        l1Balance: Maybe<CurrencyAmount>;
        requiredReserve: Maybe<CurrencyAmount>;
        availableBalance: Maybe<CurrencyAmount>;
        unconfirmedBalance: Maybe<CurrencyAmount>;
    }>;
    localBalance: Maybe<CurrencyAmount>;
    remoteBalance: Maybe<CurrencyAmount>;
};

/**
 * This is an enum of the potential permissions that a Lightspark user can have in regards to
 * account management. *
 */
declare enum Permission {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    ALL = "ALL",
    MAINNET_VIEW = "MAINNET_VIEW",
    MAINNET_TRANSACT = "MAINNET_TRANSACT",
    MAINNET_MANAGE = "MAINNET_MANAGE",
    TESTNET_VIEW = "TESTNET_VIEW",
    TESTNET_TRANSACT = "TESTNET_TRANSACT",
    TESTNET_MANAGE = "TESTNET_MANAGE",
    REGTEST_VIEW = "REGTEST_VIEW",
    REGTEST_TRANSACT = "REGTEST_TRANSACT",
    REGTEST_MANAGE = "REGTEST_MANAGE",
    USER_VIEW = "USER_VIEW",
    USER_MANAGE = "USER_MANAGE",
    ACCOUNT_VIEW = "ACCOUNT_VIEW",
    ACCOUNT_MANAGE = "ACCOUNT_MANAGE"
}

/**
 * This is an object representing a Lightspark API token, that can be used to authenticate this
 * account when making API calls or using our SDKs. See the “Authentication” section of our API
 * docs for more details on its usage. *
 */
interface ApiToken {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /**
     * An opaque identifier that should be used as a client_id (or username) in the HTTP Basic
     * Authentication scheme when issuing requests against the Lightspark API.
     **/
    clientId: string;
    /**
     * An arbitrary name chosen by the creator of the token to help identify the token in the list
     * of tokens that have been created for the account.
     **/
    name: string;
    /** A list of permissions granted to the token. **/
    permissions: Permission[];
    /** The typename of the object **/
    typename: string;
}
declare const getApiTokenQuery: (id: string) => Query<ApiToken>;

/**
 * This is an object representing information about a page returned by the Lightspark API. For more
 * information, please see the “Pagination” section of our API docs for more information about its
 * usage. *
 */
interface PageInfo {
    hasNextPage?: boolean | undefined;
    hasPreviousPage?: boolean | undefined;
    startCursor?: string | undefined;
    endCursor?: string | undefined;
}

interface AccountToApiTokensConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The API tokens for the current page of this connection. **/
    entities: ApiToken[];
    /** The typename of the object **/
    typename: string;
}

/** This is an enum representing the status of a channel on the Lightning Network. **/
declare enum ChannelStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** The channel is online and ready to send and receive funds. **/
    OK = "OK",
    /**
     * The channel has been created, but the Bitcoin transaction that initiates it still needs to be
     * confirmed on the Bitcoin blockchain. *
     */
    PENDING = "PENDING",
    /** The channel is not available, likely because the peer is not online. **/
    OFFLINE = "OFFLINE",
    /**
     * The channel is behaving properly, but its remote balance is much higher than its local balance
     * so it is not balanced properly for sending funds out. *
     */
    UNBALANCED_FOR_SEND = "UNBALANCED_FOR_SEND",
    /**
     * The channel is behaving properly, but its remote balance is much lower than its local balance
     * so it is not balanced properly for receiving funds. *
     */
    UNBALANCED_FOR_RECEIVE = "UNBALANCED_FOR_RECEIVE",
    /**
     * The channel has been closed. Information about the channel is still available for historical
     * purposes but the channel cannot be used anymore. *
     */
    CLOSED = "CLOSED",
    /**
     * Something unexpected happened and we cannot determine the status of this channel. Please try
     * again later or contact the support. *
     */
    ERROR = "ERROR"
}

/** This represents the fee policies set for a channel on the Lightning Network. **/
interface ChannelFees {
    baseFee?: CurrencyAmount | undefined;
    feeRatePerMil?: number | undefined;
}

interface ChannelToTransactionsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /**
     * The average fee for the transactions that transited through this channel, according to the
     * filters and constraints of the connection.
     **/
    averageFee?: CurrencyAmount | undefined;
    /**
     * The total amount transacted for the transactions that transited through this channel,
     * according to the filters and constraints of the connection.
     **/
    totalAmountTransacted?: CurrencyAmount | undefined;
    /**
     * The total amount of fees for the transactions that transited through this channel, according
     * to the filters and constraints of the connection.
     **/
    totalFees?: CurrencyAmount | undefined;
}

/**
 * This interface is used by all the entities in the Lightspark system. It defines a few core
 * fields that are available everywhere. Any object that implements this interface can be queried
 * using the `entity` query and its ID. *
 */
interface Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The typename of the object **/
    typename: string;
}

/**
 * This is an enum of the potential types of transactions that can be associated with your
 * Lightspark Node. *
 */
declare enum TransactionType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** Transactions initiated from a Lightspark node on Lightning Network. **/
    OUTGOING_PAYMENT = "OUTGOING_PAYMENT",
    /** Transactions received by a Lightspark node on Lightning Network. **/
    INCOMING_PAYMENT = "INCOMING_PAYMENT",
    /** Transactions that forwarded payments through Lightspark nodes on Lightning Network. **/
    ROUTED = "ROUTED",
    /**
     * Transactions on the Bitcoin blockchain to withdraw funds from a Lightspark node to a Bitcoin
     * wallet. *
     */
    L1_WITHDRAW = "L1_WITHDRAW",
    /** Transactions on Bitcoin blockchain to fund a Lightspark node's wallet. **/
    L1_DEPOSIT = "L1_DEPOSIT",
    /**
     * Transactions on Bitcoin blockchain to open a channel on Lightning Network funded by the local
     * Lightspark node. *
     */
    CHANNEL_OPEN = "CHANNEL_OPEN",
    /**
     * Transactions on Bitcoin blockchain to close a channel on Lightning Network where the balances
     * are allocated back to local and remote nodes. *
     */
    CHANNEL_CLOSE = "CHANNEL_CLOSE",
    /** Transactions initiated from a Lightspark node on Lightning Network. **/
    PAYMENT = "PAYMENT",
    /** Payment requests from a Lightspark node on Lightning Network **/
    PAYMENT_REQUEST = "PAYMENT_REQUEST",
    /** Transactions that forwarded payments through Lightspark nodes on Lightning Network. **/
    ROUTE = "ROUTE"
}

/**
 * This is an object representing a channel on the Lightning Network. You can retrieve this object
 * to get detailed information on a specific Lightning Network channel. *
 */
declare class Channel implements Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The local Lightspark node of the channel. **/
    readonly localNodeId: string;
    /** The typename of the object **/
    readonly typename: string;
    /** The transaction that funded the channel upon channel opening. **/
    readonly fundingTransactionId?: string | undefined;
    /**
     * The total amount of funds in this channel, including the channel balance on the local node,
     * the channel balance on the remote node and the on-chain fees to close the channel.
     **/
    readonly capacity?: CurrencyAmount | undefined;
    /** The channel balance on the local node. **/
    readonly localBalance?: CurrencyAmount | undefined;
    /**
     * The channel balance on the local node that is currently allocated to in-progress payments. *
     */
    readonly localUnsettledBalance?: CurrencyAmount | undefined;
    /** The channel balance on the remote node. **/
    readonly remoteBalance?: CurrencyAmount | undefined;
    /**
     * The channel balance on the remote node that is currently allocated to in-progress payments.
     * *
     */
    readonly remoteUnsettledBalance?: CurrencyAmount | undefined;
    /** The channel balance that is currently allocated to in-progress payments. **/
    readonly unsettledBalance?: CurrencyAmount | undefined;
    /**
     * The total balance in this channel, including the channel balance on both local and remote
     * nodes. *
     */
    readonly totalBalance?: CurrencyAmount | undefined;
    /** The current status of this channel. **/
    readonly status?: ChannelStatus | undefined;
    /**
     * The estimated time to wait for the channel's hash timelock contract to expire when force
     * closing the channel. It is in unit of minutes.
     **/
    readonly estimatedForceClosureWaitMinutes?: number | undefined;
    /** The amount to be paid in fees for the current set of commitment transactions. **/
    readonly commitFee?: CurrencyAmount | undefined;
    /** The fees charged for routing payments through this channel. **/
    readonly fees?: ChannelFees | undefined;
    /** If known, the remote node of the channel. **/
    readonly remoteNodeId?: string | undefined;
    /**
     * The unique identifier of the channel on Lightning Network, which is the location in the
     * chain that the channel was confirmed. The format is <block-height>:<tx-index>:<tx-output>.
     **/
    readonly shortChannelId?: string | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The local Lightspark node of the channel. **/
    localNodeId: string, 
    /** The typename of the object **/
    typename: string, 
    /** The transaction that funded the channel upon channel opening. **/
    fundingTransactionId?: string | undefined, 
    /**
     * The total amount of funds in this channel, including the channel balance on the local node,
     * the channel balance on the remote node and the on-chain fees to close the channel.
     **/
    capacity?: CurrencyAmount | undefined, 
    /** The channel balance on the local node. **/
    localBalance?: CurrencyAmount | undefined, 
    /**
     * The channel balance on the local node that is currently allocated to in-progress payments. *
     */
    localUnsettledBalance?: CurrencyAmount | undefined, 
    /** The channel balance on the remote node. **/
    remoteBalance?: CurrencyAmount | undefined, 
    /**
     * The channel balance on the remote node that is currently allocated to in-progress payments.
     * *
     */
    remoteUnsettledBalance?: CurrencyAmount | undefined, 
    /** The channel balance that is currently allocated to in-progress payments. **/
    unsettledBalance?: CurrencyAmount | undefined, 
    /**
     * The total balance in this channel, including the channel balance on both local and remote
     * nodes. *
     */
    totalBalance?: CurrencyAmount | undefined, 
    /** The current status of this channel. **/
    status?: ChannelStatus | undefined, 
    /**
     * The estimated time to wait for the channel's hash timelock contract to expire when force
     * closing the channel. It is in unit of minutes.
     **/
    estimatedForceClosureWaitMinutes?: number | undefined, 
    /** The amount to be paid in fees for the current set of commitment transactions. **/
    commitFee?: CurrencyAmount | undefined, 
    /** The fees charged for routing payments through this channel. **/
    fees?: ChannelFees | undefined, 
    /** If known, the remote node of the channel. **/
    remoteNodeId?: string | undefined, 
    /**
     * The unique identifier of the channel on Lightning Network, which is the location in the
     * chain that the channel was confirmed. The format is <block-height>:<tx-index>:<tx-output>.
     **/
    shortChannelId?: string | undefined);
    getUptimePercentage(client: LightsparkClient, afterDate?: string | undefined, beforeDate?: string | undefined): Promise<number>;
    getTransactions(client: LightsparkClient, types?: TransactionType[] | undefined, afterDate?: string | undefined, beforeDate?: string | undefined): Promise<ChannelToTransactionsConnection>;
    static getChannelQuery(id: string): Query<Channel>;
    toJson(): {
        __typename: string;
        channel_id: string;
        channel_created_at: string;
        channel_updated_at: string;
        channel_funding_transaction: {
            id: string | undefined;
        };
        channel_capacity: any;
        channel_local_balance: any;
        channel_local_unsettled_balance: any;
        channel_remote_balance: any;
        channel_remote_unsettled_balance: any;
        channel_unsettled_balance: any;
        channel_total_balance: any;
        channel_status: ChannelStatus | undefined;
        channel_estimated_force_closure_wait_minutes: number | undefined;
        channel_commit_fee: any;
        channel_fees: any;
        channel_remote_node: {
            id: string | undefined;
        };
        channel_local_node: {
            id: string;
        };
        channel_short_channel_id: string | undefined;
    };
}

declare class AccountToChannelsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    readonly count: number;
    /** The channels for the current page of this connection. **/
    readonly entities: Channel[];
    constructor(
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number, 
    /** The channels for the current page of this connection. **/
    entities: Channel[]);
    toJson(): {
        account_to_channels_connection_count: number;
        account_to_channels_connection_entities: {
            __typename: string;
            channel_id: string;
            channel_created_at: string;
            channel_updated_at: string;
            channel_funding_transaction: {
                id: string | undefined;
            };
            channel_capacity: any;
            channel_local_balance: any;
            channel_local_unsettled_balance: any;
            channel_remote_balance: any;
            channel_remote_unsettled_balance: any;
            channel_unsettled_balance: any;
            channel_total_balance: any;
            channel_status: ChannelStatus | undefined;
            channel_estimated_force_closure_wait_minutes: number | undefined;
            channel_commit_fee: any;
            channel_fees: any;
            channel_remote_node: {
                id: string | undefined;
            };
            channel_local_node: {
                id: string;
            };
            channel_short_channel_id: string | undefined;
        }[];
    };
}

/**
 * This is an object representing the balance associated with your Lightspark account. You can
 * retrieve this object to see your balance, which can be broken down into several different
 * categorizations. *
 */
interface Balances {
    /**
     * This represents the balance that should be displayed when asked "how much do I own right
     * now?". It represents the amount currently owned, including things that may not be owned soon
     * (e.g. in-flight outgoing payments, in-flight withdrawals, commit fees, etc.). It really is a
     * snapshot of what is officially owned at this instant.
     **/
    ownedBalance: CurrencyAmount;
    /**
     * This represents the balance that should be displayed when asked "how much can I send on
     * Lightning right now?". It represents the amount currently available to be sent on the
     * Lightning network. We remove from the balance all the funds that are temporarily locked
     * (e.g. channel reserves).
     **/
    availableToSendBalance: CurrencyAmount;
    /**
     * This represents the balance that should be displayed when asked "how much money can I
     * withdraw on the Bitcoin network right now?". It represents the amount currently available to
     * withdraw and is usually equal to the `owned_balance` but it does not include in-flight
     * operations (which would likely succeed and therefore likely make your withdrawal fail).
     **/
    availableToWithdrawBalance: CurrencyAmount;
}

/** This is an object representing a detailed breakdown of the balance for a Lightspark Node. **/
interface BlockchainBalance {
    /** The total wallet balance, including unconfirmed UTXOs. **/
    totalBalance?: CurrencyAmount | undefined;
    /** The balance of confirmed UTXOs in the wallet. **/
    confirmedBalance?: CurrencyAmount | undefined;
    /** The balance of unconfirmed UTXOs in the wallet. **/
    unconfirmedBalance?: CurrencyAmount | undefined;
    /** The balance that's locked by an on-chain transaction. **/
    lockedBalance?: CurrencyAmount | undefined;
    /** Funds required to be held in reserve for channel bumping. **/
    requiredReserve?: CurrencyAmount | undefined;
    /** Funds available for creating channels or withdrawing. **/
    availableBalance?: CurrencyAmount | undefined;
}

interface LightsparkNodeToChannelsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The channels for the current page of this connection. **/
    entities: Channel[];
    /** The typename of the object **/
    typename: string;
}

/** This object represents the address of a node on the Lightning Network. **/
interface NodeAddress {
    /** The string representation of the address. **/
    address: string;
    /** The type, or protocol, of this address. **/
    type: NodeAddressType;
}

/**
 * A connection between a node and the addresses it has announced for itself on Lightning Network.
 * *
 */
interface NodeToAddressesConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** The addresses for the current page of this connection. **/
    entities: NodeAddress[];
}

/**
 * This is an object representing a node managed by Lightspark and owned by the current connected
 * account. This object contains information about the node’s configuration, state, and metadata. *
 */
interface LightsparkNode {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The Bitcoin Network this node is deployed in. **/
    bitcoinNetwork: BitcoinNetwork;
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    displayName: string;
    /** The owner of this LightsparkNode. **/
    ownerId: string;
    /**
     * The utxos of the channels that are connected to this node. This is used in uma flow for
     * pre-screening.
     **/
    umaPrescreeningUtxos: string[];
    /** The typename of the object **/
    typename: string;
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    alias?: string | undefined;
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    color?: string | undefined;
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    conductivity?: number | undefined;
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    publicKey?: string | undefined;
    /** The current status of this node. **/
    status?: LightsparkNodeStatus | undefined;
    /**
     * The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this
     * node.
     *
     * @deprecated Use `balances` instead.
     **/
    totalBalance?: CurrencyAmount | undefined;
    /**
     * The total sum of the channel balances (online and offline) on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    totalLocalBalance?: CurrencyAmount | undefined;
    /**
     * The sum of the channel balances (online only) that are available to send on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    localBalance?: CurrencyAmount | undefined;
    /**
     * The sum of the channel balances that are available to receive on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    remoteBalance?: CurrencyAmount | undefined;
    /**
     * The details of the balance of this node on the Bitcoin Network.
     *
     * @deprecated Use `balances` instead.
     **/
    blockchainBalance?: BlockchainBalance | undefined;
    /** The balances that describe the funds in this node. **/
    balances?: Balances | undefined;
    getAddresses(client: LightsparkClient, first?: number | undefined, types?: NodeAddressType[] | undefined): Promise<NodeToAddressesConnection>;
    getChannels(client: LightsparkClient, first?: number | undefined, statuses?: ChannelStatus[] | undefined, after?: string | undefined): Promise<LightsparkNodeToChannelsConnection>;
}
declare const getLightsparkNodeQuery: (id: string) => Query<LightsparkNode>;

/** A connection between an account and the nodes it manages. **/
interface AccountToNodesConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The nodes for the current page of this connection. **/
    entities: LightsparkNode[];
    /** The typename of the object **/
    typename: string;
}

/**
 * This object is an interface of a payment request on the Lightning Network (i.e., a Lightning
 * Invoice). It contains data related to parsing the payment details of a Lightning Invoice. *
 */
interface PaymentRequestData {
    encodedPaymentRequest: string;
    bitcoinNetwork: BitcoinNetwork;
    /** The typename of the object **/
    typename: string;
}

/**
 * This is an enum of the potential states that a payment request on the Lightning Network can
 * take. *
 */
declare enum PaymentRequestStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    OPEN = "OPEN",
    CLOSED = "CLOSED"
}

/**
 * This object contains information related to a payment request generated or received by a
 * LightsparkNode. You can retrieve this object to receive payment information about a specific
 * invoice. *
 */
interface PaymentRequest {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The details of the payment request. **/
    data: PaymentRequestData;
    /** The status of the payment request. **/
    status: PaymentRequestStatus;
    /** The typename of the object **/
    typename: string;
}
declare const getPaymentRequestQuery: (id: string) => Query<PaymentRequest>;

interface AccountToPaymentRequestsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The payment requests for the current page of this connection. **/
    entities: PaymentRequest[];
    /** The typename of the object **/
    typename: string;
}

/**
 * This is an enum of the potential statuses a transaction associated with your Lightspark Node can
 * take. *
 */
declare enum TransactionStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** Transaction succeeded.. **/
    SUCCESS = "SUCCESS",
    /** Transaction failed. **/
    FAILED = "FAILED",
    /** Transaction has been initiated and is currently in-flight. **/
    PENDING = "PENDING",
    /**
     * For transaction type PAYMENT_REQUEST only. No payments have been made to a payment request. *
     */
    NOT_STARTED = "NOT_STARTED",
    /** For transaction type PAYMENT_REQUEST only. A payment request has expired. **/
    EXPIRED = "EXPIRED",
    /** For transaction type PAYMENT_REQUEST only. **/
    CANCELLED = "CANCELLED"
}

/**
 * This object represents a payment transaction. The transaction can occur either on a Bitcoin
 * Network, or over the Lightning Network. You can retrieve this object to receive specific
 * information about a particular transaction tied to your Lightspark Node. *
 */
interface Transaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
}
declare const getTransactionQuery: (id: string) => Query<Transaction>;

interface AccountToTransactionsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The transactions for the current page of this connection. **/
    entities: Transaction[];
    /** The typename of the object **/
    typename: string;
    /**
     * Profit (or loss) generated by the transactions in this connection, with the set of filters
     * and constraints provided.
     **/
    profitLoss?: CurrencyAmount | undefined;
    /**
     * Average fee earned for the transactions in this connection, with the set of filters and
     * constraints provided.
     **/
    averageFeeEarned?: CurrencyAmount | undefined;
    /**
     * Total amount transacted by the transactions in this connection, with the set of filters and
     * constraints provided.
     **/
    totalAmountTransacted?: CurrencyAmount | undefined;
}

/** This is an object representing the owner of a LightsparkNode. **/
interface LightsparkNodeOwner {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The typename of the object **/
    typename: string;
}
declare const getLightsparkNodeOwnerQuery: (id: string) => Query<LightsparkNodeOwner>;

/** This is an enum of the potential statuses that your Lightspark wallet can take.  **/
declare enum WalletStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /**
     * The wallet has not been set up yet and is ready to be deployed. This is the default status
     * after the first login. *
     */
    NOT_SETUP = "NOT_SETUP",
    /** The wallet is currently being deployed in the Lightspark infrastructure. **/
    DEPLOYING = "DEPLOYING",
    /**
     * The wallet has been deployed in the Lightspark infrastructure and is ready to be initialized. *
     */
    DEPLOYED = "DEPLOYED",
    /** The wallet is currently being initialized. **/
    INITIALIZING = "INITIALIZING",
    /** The wallet is available and ready to be used. **/
    READY = "READY",
    /** The wallet is temporarily available, due to a transient issue or a scheduled maintenance. **/
    UNAVAILABLE = "UNAVAILABLE",
    /**
     * The wallet had an unrecoverable failure. This status is not expected to happend and will be
     * investigated by the Lightspark team. *
     */
    FAILED = "FAILED",
    /** The wallet is being terminated. **/
    TERMINATING = "TERMINATING",
    /**
     * The wallet has been terminated and is not available in the Lightspark infrastructure anymore.
     * It is not connected to the Lightning network and its funds can only be accessed using the
     * Funds Recovery flow. *
     */
    TERMINATED = "TERMINATED"
}

interface WalletToPaymentRequestsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The payment requests for the current page of this connection. **/
    entities: PaymentRequest[];
    /** The typename of the object **/
    typename: string;
}

interface WalletToTransactionsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The transactions for the current page of this connection. **/
    entities: Transaction[];
    /** The typename of the object **/
    typename: string;
}

/** This is an enum of the potential modes that your Bitcoin withdrawal can take. **/
declare enum WithdrawalMode {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    WALLET_ONLY = "WALLET_ONLY",
    WALLET_THEN_CHANNELS = "WALLET_THEN_CHANNELS"
}

/** This is an enum of the potential statuses that a Withdrawal can take. **/
declare enum WithdrawalRequestStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    CREATED = "CREATED",
    FAILED = "FAILED",
    IN_PROGRESS = "IN_PROGRESS",
    SUCCESSFUL = "SUCCESSFUL"
}

/**
 * This is an object representing a transaction which closes a channel on the Lightning Network.
 * This operation allocates balances back to the local and remote nodes. *
 */
interface ChannelClosingTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /**
     * The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin
     * blockchain.
     **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
    /** If known, the channel this transaction is closing. **/
    channelId?: string | undefined;
}
declare const getChannelClosingTransactionQuery: (id: string) => Query<ChannelClosingTransaction>;

interface WithdrawalRequestToChannelClosingTransactionsConnection {
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** The channel closing transactions for the current page of this connection. **/
    entities: ChannelClosingTransaction[];
}

/**
 * This is an object representing a transaction which opens a channel on the Lightning Network.
 * This object occurs only for channels funded by the local Lightspark node. *
 */
interface ChannelOpeningTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /**
     * The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin
     * blockchain.
     **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
    /** If known, the channel this transaction is opening. **/
    channelId?: string | undefined;
}
declare const getChannelOpeningTransactionQuery: (id: string) => Query<ChannelOpeningTransaction>;

interface WithdrawalRequestToChannelOpeningTransactionsConnection {
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** The channel opening transactions for the current page of this connection. **/
    entities: ChannelOpeningTransaction[];
}

/**
 * This object represents a request made for an L1 withdrawal from your Lightspark Node to any
 * Bitcoin wallet. You can retrieve this object to receive detailed information about any
 * withdrawal request made from your Lightspark account. *
 */
declare class WithdrawalRequest implements Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /**
     * The requested amount of money to be withdrawn. If the requested amount is -1, it means to
     * withdraw all.
     **/
    readonly requestedAmount: CurrencyAmount;
    /**
     * The amount of money that should be withdrawn in this request.
     *
     * @deprecated Use `requested_amount` instead
     **/
    readonly amount: CurrencyAmount;
    /** The bitcoin address where the funds should be sent. **/
    readonly bitcoinAddress: string;
    /** The strategy that should be used to withdraw the funds from the account. **/
    readonly withdrawalMode: WithdrawalMode;
    /** The current status of this withdrawal request. **/
    readonly status: WithdrawalRequestStatus;
    /** The typename of the object **/
    readonly typename: string;
    /**
     * If the requested amount is `-1` (i.e. everything), this field may contain an estimate of the
     * amount for the withdrawal.
     **/
    readonly estimatedAmount?: CurrencyAmount | undefined;
    /** The actual amount that is withdrawn. It will be set once the request is completed. **/
    readonly amountWithdrawn?: CurrencyAmount | undefined;
    /** The time at which this request was completed. **/
    readonly completedAt?: string | undefined;
    /** The withdrawal transaction that has been generated by this request. **/
    readonly withdrawalId?: string | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /**
     * The requested amount of money to be withdrawn. If the requested amount is -1, it means to
     * withdraw all.
     **/
    requestedAmount: CurrencyAmount, 
    /**
     * The amount of money that should be withdrawn in this request.
     *
     * @deprecated Use `requested_amount` instead
     **/
    amount: CurrencyAmount, 
    /** The bitcoin address where the funds should be sent. **/
    bitcoinAddress: string, 
    /** The strategy that should be used to withdraw the funds from the account. **/
    withdrawalMode: WithdrawalMode, 
    /** The current status of this withdrawal request. **/
    status: WithdrawalRequestStatus, 
    /** The typename of the object **/
    typename: string, 
    /**
     * If the requested amount is `-1` (i.e. everything), this field may contain an estimate of the
     * amount for the withdrawal.
     **/
    estimatedAmount?: CurrencyAmount | undefined, 
    /** The actual amount that is withdrawn. It will be set once the request is completed. **/
    amountWithdrawn?: CurrencyAmount | undefined, 
    /** The time at which this request was completed. **/
    completedAt?: string | undefined, 
    /** The withdrawal transaction that has been generated by this request. **/
    withdrawalId?: string | undefined);
    getChannelClosingTransactions(client: LightsparkClient, first?: number | undefined): Promise<WithdrawalRequestToChannelClosingTransactionsConnection>;
    getChannelOpeningTransactions(client: LightsparkClient, first?: number | undefined): Promise<WithdrawalRequestToChannelOpeningTransactionsConnection>;
    static getWithdrawalRequestQuery(id: string): Query<WithdrawalRequest>;
    toJson(): {
        __typename: string;
        withdrawal_request_id: string;
        withdrawal_request_created_at: string;
        withdrawal_request_updated_at: string;
        withdrawal_request_requested_amount: any;
        withdrawal_request_amount: any;
        withdrawal_request_estimated_amount: any;
        withdrawal_request_amount_withdrawn: any;
        withdrawal_request_bitcoin_address: string;
        withdrawal_request_withdrawal_mode: WithdrawalMode;
        withdrawal_request_status: WithdrawalRequestStatus;
        withdrawal_request_completed_at: string | undefined;
        withdrawal_request_withdrawal: {
            id: string | undefined;
        };
    };
}

interface WalletToWithdrawalRequestsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The withdrawal requests for the current page of this connection. **/
    entities: WithdrawalRequest[];
    /** The typename of the object **/
    typename: string;
}

/**
 * This object represents a Lightspark Wallet, tied to your Lightspark account. Wallets can be used
 * to send or receive funds over the Lightning Network. You can retrieve this object to receive
 * information about a specific wallet tied to your Lightspark account. *
 */
declare class Wallet implements LightsparkNodeOwner, Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /**
     * The unique identifier of this wallet, as provided by the Lightspark Customer during login. *
     */
    readonly thirdPartyIdentifier: string;
    /** The status of this wallet. **/
    readonly status: WalletStatus;
    /** The typename of the object **/
    readonly typename: string;
    /** The date and time when the wallet user last logged in. **/
    readonly lastLoginAt?: string | undefined;
    /** The balances that describe the funds in this wallet. **/
    readonly balances?: Balances | undefined;
    /** The account this wallet belongs to. **/
    readonly accountId?: string | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /**
     * The unique identifier of this wallet, as provided by the Lightspark Customer during login. *
     */
    thirdPartyIdentifier: string, 
    /** The status of this wallet. **/
    status: WalletStatus, 
    /** The typename of the object **/
    typename: string, 
    /** The date and time when the wallet user last logged in. **/
    lastLoginAt?: string | undefined, 
    /** The balances that describe the funds in this wallet. **/
    balances?: Balances | undefined, 
    /** The account this wallet belongs to. **/
    accountId?: string | undefined);
    getTransactions(client: LightsparkClient, first?: number | undefined, after?: string | undefined, createdAfterDate?: string | undefined, createdBeforeDate?: string | undefined, statuses?: TransactionStatus[] | undefined, types?: TransactionType[] | undefined): Promise<WalletToTransactionsConnection>;
    getPaymentRequests(client: LightsparkClient, first?: number | undefined, after?: string | undefined, createdAfterDate?: string | undefined, createdBeforeDate?: string | undefined): Promise<WalletToPaymentRequestsConnection>;
    getTotalAmountReceived(client: LightsparkClient, createdAfterDate?: string | undefined, createdBeforeDate?: string | undefined): Promise<CurrencyAmount>;
    getWithdrawalRequests(client: LightsparkClient, first?: number | undefined, after?: string | undefined, statuses?: WithdrawalRequestStatus[] | undefined, createdAfterDate?: string | undefined, createdBeforeDate?: string | undefined): Promise<WalletToWithdrawalRequestsConnection>;
    getTotalAmountSent(client: LightsparkClient, createdAfterDate?: string | undefined, createdBeforeDate?: string | undefined): Promise<CurrencyAmount>;
    static getWalletQuery(id: string): Query<Wallet>;
    toJson(): {
        __typename: string;
        wallet_id: string;
        wallet_created_at: string;
        wallet_updated_at: string;
        wallet_last_login_at: string | undefined;
        wallet_balances: any;
        wallet_third_party_identifier: string;
        wallet_account: {
            id: string | undefined;
        };
        wallet_status: WalletStatus;
    };
}

interface AccountToWalletsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The wallets for the current page of this connection. **/
    entities: Wallet[];
    /** The typename of the object **/
    typename: string;
}

/** A connection between an account and its past and present withdrawal requests. **/
interface AccountToWithdrawalRequestsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The withdrawal requests for the current page of this connection. **/
    entities: WithdrawalRequest[];
    /** The typename of the object **/
    typename: string;
}

/**
 * This is an enum of the potential reasons why an OutgoingPayment sent from a Lightspark Node may
 * have failed. *
 */
declare enum PaymentFailureReason {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    NONE = "NONE",
    TIMEOUT = "TIMEOUT",
    NO_ROUTE = "NO_ROUTE",
    ERROR = "ERROR",
    INCORRECT_PAYMENT_DETAILS = "INCORRECT_PAYMENT_DETAILS",
    INSUFFICIENT_BALANCE = "INSUFFICIENT_BALANCE",
    INVOICE_ALREADY_PAID = "INVOICE_ALREADY_PAID",
    SELF_PAYMENT = "SELF_PAYMENT",
    INVOICE_EXPIRED = "INVOICE_EXPIRED",
    RISK_SCREENING_FAILED = "RISK_SCREENING_FAILED"
}

/**
 * This is an enum of the potential reasons that an attempted routed transaction through a
 * Lightspark node may have failed. *
 */
declare enum RoutingTransactionFailureReason {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    INCOMING_LINK_FAILURE = "INCOMING_LINK_FAILURE",
    OUTGOING_LINK_FAILURE = "OUTGOING_LINK_FAILURE",
    FORWARDING_FAILURE = "FORWARDING_FAILURE"
}

/** This object represents payment failures associated with your Lightspark Node. **/
interface TransactionFailures {
    paymentFailures?: PaymentFailureReason[] | undefined;
    routingTransactionFailures?: RoutingTransactionFailureReason[] | undefined;
}

/**
 * This is an object representing the connected Lightspark account. You can retrieve this object to
 * see your account information and objects tied to your account. *
 */
declare class Account implements LightsparkNodeOwner, Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The typename of the object **/
    readonly typename: string;
    /** The name of this account. **/
    readonly name?: string | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The typename of the object **/
    typename: string, 
    /** The name of this account. **/
    name?: string | undefined);
    getApiTokens(client: LightsparkClient, first?: number | undefined, after?: string | undefined): Promise<AccountToApiTokensConnection>;
    getBlockchainBalance(client: LightsparkClient, bitcoinNetworks?: BitcoinNetwork[] | undefined, nodeIds?: string[] | undefined): Promise<BlockchainBalance | null>;
    getConductivity(client: LightsparkClient, bitcoinNetworks?: BitcoinNetwork[] | undefined, nodeIds?: string[] | undefined): Promise<number>;
    getLocalBalance(client: LightsparkClient, bitcoinNetworks?: BitcoinNetwork[] | undefined, nodeIds?: string[] | undefined): Promise<CurrencyAmount | null>;
    getNodes(client: LightsparkClient, first?: number | undefined, bitcoinNetworks?: BitcoinNetwork[] | undefined, nodeIds?: string[] | undefined, after?: string | undefined): Promise<AccountToNodesConnection>;
    getRemoteBalance(client: LightsparkClient, bitcoinNetworks?: BitcoinNetwork[] | undefined, nodeIds?: string[] | undefined): Promise<CurrencyAmount | null>;
    getUptimePercentage(client: LightsparkClient, afterDate?: string | undefined, beforeDate?: string | undefined, bitcoinNetworks?: BitcoinNetwork[] | undefined, nodeIds?: string[] | undefined): Promise<number>;
    getChannels(client: LightsparkClient, bitcoinNetwork: BitcoinNetwork, lightningNodeId?: string | undefined, afterDate?: string | undefined, beforeDate?: string | undefined, first?: number | undefined): Promise<AccountToChannelsConnection>;
    getTransactions(client: LightsparkClient, first?: number | undefined, after?: string | undefined, types?: TransactionType[] | undefined, afterDate?: string | undefined, beforeDate?: string | undefined, bitcoinNetwork?: BitcoinNetwork | undefined, lightningNodeId?: string | undefined, statuses?: TransactionStatus[] | undefined, excludeFailures?: TransactionFailures | undefined): Promise<AccountToTransactionsConnection>;
    getPaymentRequests(client: LightsparkClient, first?: number | undefined, after?: string | undefined, afterDate?: string | undefined, beforeDate?: string | undefined, bitcoinNetwork?: BitcoinNetwork | undefined, lightningNodeId?: string | undefined): Promise<AccountToPaymentRequestsConnection>;
    getWithdrawalRequests(client: LightsparkClient, first?: number | undefined, after?: string | undefined, bitcoinNetworks?: BitcoinNetwork[] | undefined, statuses?: WithdrawalRequestStatus[] | undefined, nodeIds?: string[] | undefined, afterDate?: string | undefined, beforeDate?: string | undefined): Promise<AccountToWithdrawalRequestsConnection>;
    getWallets(client: LightsparkClient, first?: number | undefined, after?: string | undefined, thirdPartyIds?: string[] | undefined): Promise<AccountToWalletsConnection>;
    static getAccountQuery(): Query<Account>;
    toJson(): {
        __typename: string;
        account_id: string;
        account_created_at: string;
        account_updated_at: string;
        account_name: string | undefined;
    };
}

/** This is an enum identifying a type of compliance provider. **/
declare enum ComplianceProvider {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    CHAINALYSIS = "CHAINALYSIS"
}

interface CreateApiTokenOutput {
    /** The API Token that has been created. **/
    apiToken: ApiToken;
    /**
     * The secret that should be used to authenticate against our API. This secret is not stored
     * and will never be available again after this. You must keep this secret secure as it grants
     * access to your account.
     **/
    clientSecret: string;
}

/**
 * This object represents the estimated L1 transaction fees for the Bitcoin network. Fee estimates
 * are separated by potential confirmation speeds for settlement. *
 */
interface FeeEstimate {
    feeFast: CurrencyAmount;
    feeMin: CurrencyAmount;
}

/** This is an enum that enumerates all potential statuses for an incoming payment attempt. **/
declare enum IncomingPaymentAttemptStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    ACCEPTED = "ACCEPTED",
    SETTLED = "SETTLED",
    CANCELED = "CANCELED",
    UNKNOWN = "UNKNOWN"
}

/**
 * This object represents any attempted payment sent to a Lightspark node on the Lightning Network.
 * You can retrieve this object to receive payment related information about a specific incoming
 * payment attempt. *
 */
interface IncomingPaymentAttempt {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The status of the incoming payment attempt. **/
    status: IncomingPaymentAttemptStatus;
    /** The total amount of that was attempted to send. **/
    amount: CurrencyAmount;
    /** The channel this attempt was made on. **/
    channelId: string;
    /** The typename of the object **/
    typename: string;
    /** The time the incoming payment attempt failed or succeeded. **/
    resolvedAt?: string | undefined;
}
declare const getIncomingPaymentAttemptQuery: (id: string) => Query<IncomingPaymentAttempt>;

/** The connection from incoming payment to all attempts. **/
interface IncomingPaymentToAttemptsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The incoming payment attempts for the current page of this connection. **/
    entities: IncomingPaymentAttempt[];
    /** The typename of the object **/
    typename: string;
}

/**
 * This is an object representing a transaction made over the Lightning Network. You can retrieve
 * this object to receive information about a specific transaction made over Lightning for a
 * Lightspark node. *
 */
interface LightningTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
}
declare const getLightningTransactionQuery: (id: string) => Query<LightningTransaction>;

/** This object represents post-transaction data that could be used to register payment for KYT. **/
interface PostTransactionData {
    /**
     * The utxo of the channel over which the payment went through in the format of
     * <transaction_hash>:<output_index>.
     **/
    utxo: string;
    /** The amount of funds transferred in the payment. **/
    amount: CurrencyAmount;
}

/**
 * This object represents any payment sent to a Lightspark node on the Lightning Network. You can
 * retrieve this object to receive payment related information about a specific payment received by
 * a Lightspark node. *
 */
declare class IncomingPayment implements LightningTransaction, Transaction, Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when this transaction was initiated. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The current status of this transaction. **/
    readonly status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    readonly amount: CurrencyAmount;
    /** The recipient Lightspark node this payment was sent to. **/
    readonly destinationId: string;
    /** The typename of the object **/
    readonly typename: string;
    /** The date and time when this transaction was completed or failed. **/
    readonly resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    readonly transactionHash?: string | undefined;
    /**
     * The optional payment request for this incoming payment, which will be null if the payment is
     * sent through keysend.
     **/
    readonly paymentRequestId?: string | undefined;
    /** The post transaction data which can be used in KYT payment registration. **/
    readonly umaPostTransactionData?: PostTransactionData[] | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when this transaction was initiated. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The current status of this transaction. **/
    status: TransactionStatus, 
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount, 
    /** The recipient Lightspark node this payment was sent to. **/
    destinationId: string, 
    /** The typename of the object **/
    typename: string, 
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined, 
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined, 
    /**
     * The optional payment request for this incoming payment, which will be null if the payment is
     * sent through keysend.
     **/
    paymentRequestId?: string | undefined, 
    /** The post transaction data which can be used in KYT payment registration. **/
    umaPostTransactionData?: PostTransactionData[] | undefined);
    getAttempts(client: LightsparkClient, first?: number | undefined, statuses?: IncomingPaymentAttemptStatus[] | undefined, after?: string | undefined): Promise<IncomingPaymentToAttemptsConnection>;
    static getIncomingPaymentQuery(id: string): Query<IncomingPayment>;
    toJson(): {
        __typename: string;
        incoming_payment_id: string;
        incoming_payment_created_at: string;
        incoming_payment_updated_at: string;
        incoming_payment_status: TransactionStatus;
        incoming_payment_resolved_at: string | undefined;
        incoming_payment_amount: any;
        incoming_payment_transaction_hash: string | undefined;
        incoming_payment_destination: {
            id: string;
        };
        incoming_payment_payment_request: {
            id: string | undefined;
        };
        incoming_payment_uma_post_transaction_data: any[] | undefined;
    };
}

/**
 * This object is an interface representing a Lightning Node on the Lightning Network, and could
 * either be a Lightspark node or a node managed by a third party. *
 */
interface Node {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The Bitcoin Network this node is deployed in. **/
    bitcoinNetwork: BitcoinNetwork;
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    displayName: string;
    /** The typename of the object **/
    typename: string;
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    alias?: string | undefined;
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    color?: string | undefined;
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    conductivity?: number | undefined;
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    publicKey?: string | undefined;
    getAddresses(client: LightsparkClient, first?: number | undefined, types?: NodeAddressType[] | undefined): Promise<NodeToAddressesConnection>;
}
declare const getNodeQuery: (id: string) => Query<Node>;

/**
 * This object represents the data associated with a BOLT #11 invoice. You can retrieve this object
 * to receive the relevant data associated with a specific invoice. *
 */
interface InvoiceData {
    encodedPaymentRequest: string;
    bitcoinNetwork: BitcoinNetwork;
    /** The payment hash of this invoice. **/
    paymentHash: string;
    /**
     * The requested amount in this invoice. If it is equal to 0, the sender should choose the
     * amount to send.
     **/
    amount: CurrencyAmount;
    /** The date and time when this invoice was created. **/
    createdAt: string;
    /** The date and time when this invoice will expire. **/
    expiresAt: string;
    /** The lightning node that will be paid when fulfilling this invoice. **/
    destination: Node;
    /** The typename of the object **/
    typename: string;
    /** A short, UTF-8 encoded, description of the purpose of this invoice. **/
    memo?: string | undefined;
}

/** This object represents a BOLT #11 invoice (https://github.com/lightning/bolts/blob/master/11-payment-encoding.md) created by a Lightspark Node. You can retrieve this object to receive relevant payment information for a specific invoice generated by a Lightspark node. **/
interface Invoice {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The details of the invoice. **/
    data: InvoiceData;
    /** The status of the payment request. **/
    status: PaymentRequestStatus;
    /** The typename of the object **/
    typename: string;
    /** The total amount that has been paid to this invoice. **/
    amountPaid?: CurrencyAmount | undefined;
}
declare const getInvoiceQuery: (id: string) => Query<Invoice>;

/** This is an enum for potential invoice types. **/
declare enum InvoiceType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** A standard Bolt 11 invoice. **/
    STANDARD = "STANDARD",
    /** An AMP (Atomic Multi-path Payment) invoice. **/
    AMP = "AMP"
}

interface ChannelSnapshot {
    channelId: string;
    timestamp: string;
    localBalance?: CurrencyAmount | undefined;
    localUnsettledBalance?: CurrencyAmount | undefined;
    localChannelReserve?: CurrencyAmount | undefined;
    remoteBalance?: CurrencyAmount | undefined;
    remoteUnsettledBalance?: CurrencyAmount | undefined;
}

/**
 * This is an enum representing a particular reason why an htlc sent over the Lightning Network may
 * have failed. *
 */
declare enum HtlcAttemptFailureCode {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS",
    INCORRECT_PAYMENT_AMOUNT = "INCORRECT_PAYMENT_AMOUNT",
    FINAL_INCORRECT_CLTV_EXPIRY = "FINAL_INCORRECT_CLTV_EXPIRY",
    FINAL_INCORRECT_HTLC_AMOUNT = "FINAL_INCORRECT_HTLC_AMOUNT",
    FINAL_EXPIRY_TOO_SOON = "FINAL_EXPIRY_TOO_SOON",
    INVALID_REALM = "INVALID_REALM",
    EXPIRY_TOO_SOON = "EXPIRY_TOO_SOON",
    INVALID_ONION_VERSION = "INVALID_ONION_VERSION",
    INVALID_ONION_HMAC = "INVALID_ONION_HMAC",
    INVALID_ONION_KEY = "INVALID_ONION_KEY",
    AMOUNT_BELOW_MINIMUM = "AMOUNT_BELOW_MINIMUM",
    FEE_INSUFFICIENT = "FEE_INSUFFICIENT",
    INCORRECT_CLTV_EXPIRY = "INCORRECT_CLTV_EXPIRY",
    CHANNEL_DISABLED = "CHANNEL_DISABLED",
    TEMPORARY_CHANNEL_FAILURE = "TEMPORARY_CHANNEL_FAILURE",
    REQUIRED_NODE_FEATURE_MISSING = "REQUIRED_NODE_FEATURE_MISSING",
    REQUIRED_CHANNEL_FEATURE_MISSING = "REQUIRED_CHANNEL_FEATURE_MISSING",
    UNKNOWN_NEXT_PEER = "UNKNOWN_NEXT_PEER",
    TEMPORARY_NODE_FAILURE = "TEMPORARY_NODE_FAILURE",
    PERMANENT_NODE_FAILURE = "PERMANENT_NODE_FAILURE",
    PERMANENT_CHANNEL_FAILURE = "PERMANENT_CHANNEL_FAILURE",
    EXPIRY_TOO_FAR = "EXPIRY_TOO_FAR",
    MPP_TIMEOUT = "MPP_TIMEOUT",
    INVALID_ONION_PAYLOAD = "INVALID_ONION_PAYLOAD",
    INVALID_ONION_BLINDING = "INVALID_ONION_BLINDING",
    INTERNAL_FAILURE = "INTERNAL_FAILURE",
    UNKNOWN_FAILURE = "UNKNOWN_FAILURE",
    UNREADABLE_FAILURE = "UNREADABLE_FAILURE"
}

/** This is an enum of all potential statuses of a payment attempt made from a Lightspark Node. **/
declare enum OutgoingPaymentAttemptStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    IN_FLIGHT = "IN_FLIGHT",
    SUCCEEDED = "SUCCEEDED",
    FAILED = "FAILED"
}

/**
 * This object represents a specific node that existed on a particular payment route. You can
 * retrieve this object to get information about a node on a particular payment path and all
 * payment-relevant information for that node. *
 */
interface Hop {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The zero-based index position of this hop in the path **/
    index: number;
    /** The typename of the object **/
    typename: string;
    /** The destination node of the hop. **/
    destinationId?: string | undefined;
    /** The public key of the node to which the hop is bound. **/
    publicKey?: string | undefined;
    /** The amount that is to be forwarded to the destination node. **/
    amountToForward?: CurrencyAmount | undefined;
    /** The fees to be collected by the source node for forwarding the payment over the hop. **/
    fee?: CurrencyAmount | undefined;
    /** The block height at which an unsettled HTLC is considered expired. **/
    expiryBlockHeight?: number | undefined;
}
declare const getHopQuery: (id: string) => Query<Hop>;

/**
 * The connection from an outgoing payment attempt to the list of sequential hops that define the
 * path from sender node to recipient node. *
 */
interface OutgoingPaymentAttemptToHopsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The hops for the current page of this connection. **/
    entities: Hop[];
    /** The typename of the object **/
    typename: string;
}

/**
 * This object represents an attempted Lightning Network payment sent from a Lightspark Node. You
 * can retrieve this object to receive payment related information about any payment attempt sent
 * from your Lightspark Node on the Lightning Network, including any potential reasons the payment
 * may have failed. *
 */
declare class OutgoingPaymentAttempt implements Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The status of an outgoing payment attempt. **/
    readonly status: OutgoingPaymentAttemptStatus;
    /** The date and time when the attempt was initiated. **/
    readonly attemptedAt: string;
    /** The outgoing payment for this attempt. **/
    readonly outgoingPaymentId: string;
    /** The typename of the object **/
    readonly typename: string;
    /** If the payment attempt failed, then this contains the Bolt #4 failure code. **/
    readonly failureCode?: HtlcAttemptFailureCode | undefined;
    /**
     * If the payment attempt failed, then this contains the index of the hop at which the problem
     * occurred.
     **/
    readonly failureSourceIndex?: number | undefined;
    /** The time the outgoing payment attempt failed or succeeded. **/
    readonly resolvedAt?: string | undefined;
    /**
     * The total amount of funds required to complete a payment over this route. This value
     * includes the cumulative fees for each hop. As a result, the attempt extended to the
     * first-hop in the route will need to have at least this much value, otherwise the route will
     * fail at an intermediate node due to an insufficient amount.
     **/
    readonly amount?: CurrencyAmount | undefined;
    /**
     * The sum of the fees paid at each hop within the route of this attempt. In the case of a
     * one-hop payment, this value will be zero as we don't need to pay a fee to ourselves.
     **/
    readonly fees?: CurrencyAmount | undefined;
    /** The channel snapshot at the time the outgoing payment attempt was made. **/
    readonly channelSnapshot?: ChannelSnapshot | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The status of an outgoing payment attempt. **/
    status: OutgoingPaymentAttemptStatus, 
    /** The date and time when the attempt was initiated. **/
    attemptedAt: string, 
    /** The outgoing payment for this attempt. **/
    outgoingPaymentId: string, 
    /** The typename of the object **/
    typename: string, 
    /** If the payment attempt failed, then this contains the Bolt #4 failure code. **/
    failureCode?: HtlcAttemptFailureCode | undefined, 
    /**
     * If the payment attempt failed, then this contains the index of the hop at which the problem
     * occurred.
     **/
    failureSourceIndex?: number | undefined, 
    /** The time the outgoing payment attempt failed or succeeded. **/
    resolvedAt?: string | undefined, 
    /**
     * The total amount of funds required to complete a payment over this route. This value
     * includes the cumulative fees for each hop. As a result, the attempt extended to the
     * first-hop in the route will need to have at least this much value, otherwise the route will
     * fail at an intermediate node due to an insufficient amount.
     **/
    amount?: CurrencyAmount | undefined, 
    /**
     * The sum of the fees paid at each hop within the route of this attempt. In the case of a
     * one-hop payment, this value will be zero as we don't need to pay a fee to ourselves.
     **/
    fees?: CurrencyAmount | undefined, 
    /** The channel snapshot at the time the outgoing payment attempt was made. **/
    channelSnapshot?: ChannelSnapshot | undefined);
    getHops(client: LightsparkClient, first?: number | undefined, after?: string | undefined): Promise<OutgoingPaymentAttemptToHopsConnection>;
    static getOutgoingPaymentAttemptQuery(id: string): Query<OutgoingPaymentAttempt>;
    toJson(): {
        __typename: string;
        outgoing_payment_attempt_id: string;
        outgoing_payment_attempt_created_at: string;
        outgoing_payment_attempt_updated_at: string;
        outgoing_payment_attempt_status: OutgoingPaymentAttemptStatus;
        outgoing_payment_attempt_failure_code: HtlcAttemptFailureCode | undefined;
        outgoing_payment_attempt_failure_source_index: number | undefined;
        outgoing_payment_attempt_attempted_at: string;
        outgoing_payment_attempt_resolved_at: string | undefined;
        outgoing_payment_attempt_amount: any;
        outgoing_payment_attempt_fees: any;
        outgoing_payment_attempt_outgoing_payment: {
            id: string;
        };
        outgoing_payment_attempt_channel_snapshot: any;
    };
}

/** The connection from outgoing payment to all attempts. **/
interface OutgoingPaymentToAttemptsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The attempts for the current page of this connection. **/
    entities: OutgoingPaymentAttempt[];
    /** The typename of the object **/
    typename: string;
}

interface RichText {
    text: string;
}

/**
 * This object represents a Lightning Network payment sent from a Lightspark Node. You can retrieve
 * this object to receive payment related information about any payment sent from your Lightspark
 * Node on the Lightning Network. *
 */
declare class OutgoingPayment implements LightningTransaction, Transaction, Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when this transaction was initiated. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The current status of this transaction. **/
    readonly status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    readonly amount: CurrencyAmount;
    /** The Lightspark node this payment originated from. **/
    readonly originId: string;
    /** The typename of the object **/
    readonly typename: string;
    /** The date and time when this transaction was completed or failed. **/
    readonly resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    readonly transactionHash?: string | undefined;
    /** If known, the final recipient node this payment was sent to. **/
    readonly destinationId?: string | undefined;
    /** The fees paid by the sender node to send the payment. **/
    readonly fees?: CurrencyAmount | undefined;
    /** The data of the payment request that was paid by this transaction, if known. **/
    readonly paymentRequestData?: PaymentRequestData | undefined;
    /** If applicable, the reason why the payment failed. **/
    readonly failureReason?: PaymentFailureReason | undefined;
    /** If applicable, user-facing error message describing why the payment failed. **/
    readonly failureMessage?: RichText | undefined;
    /** The post transaction data which can be used in KYT payment registration. **/
    readonly umaPostTransactionData?: PostTransactionData[] | undefined;
    /** The preimage of the payment. **/
    readonly paymentPreimage?: string | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when this transaction was initiated. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The current status of this transaction. **/
    status: TransactionStatus, 
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount, 
    /** The Lightspark node this payment originated from. **/
    originId: string, 
    /** The typename of the object **/
    typename: string, 
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined, 
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined, 
    /** If known, the final recipient node this payment was sent to. **/
    destinationId?: string | undefined, 
    /** The fees paid by the sender node to send the payment. **/
    fees?: CurrencyAmount | undefined, 
    /** The data of the payment request that was paid by this transaction, if known. **/
    paymentRequestData?: PaymentRequestData | undefined, 
    /** If applicable, the reason why the payment failed. **/
    failureReason?: PaymentFailureReason | undefined, 
    /** If applicable, user-facing error message describing why the payment failed. **/
    failureMessage?: RichText | undefined, 
    /** The post transaction data which can be used in KYT payment registration. **/
    umaPostTransactionData?: PostTransactionData[] | undefined, 
    /** The preimage of the payment. **/
    paymentPreimage?: string | undefined);
    getAttempts(client: LightsparkClient, first?: number | undefined, after?: string | undefined): Promise<OutgoingPaymentToAttemptsConnection>;
    static getOutgoingPaymentQuery(id: string): Query<OutgoingPayment>;
    toJson(): {
        __typename: string;
        outgoing_payment_id: string;
        outgoing_payment_created_at: string;
        outgoing_payment_updated_at: string;
        outgoing_payment_status: TransactionStatus;
        outgoing_payment_resolved_at: string | undefined;
        outgoing_payment_amount: any;
        outgoing_payment_transaction_hash: string | undefined;
        outgoing_payment_origin: {
            id: string;
        };
        outgoing_payment_destination: {
            id: string | undefined;
        };
        outgoing_payment_fees: any;
        outgoing_payment_payment_request_data: any;
        outgoing_payment_failure_reason: PaymentFailureReason | undefined;
        outgoing_payment_failure_message: any;
        outgoing_payment_uma_post_transaction_data: any[] | undefined;
        outgoing_payment_payment_preimage: string | undefined;
    };
}

/** This is an enum indicating the direction of the payment. **/
declare enum PaymentDirection {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    SENT = "SENT",
    RECEIVED = "RECEIVED"
}

/** The alpha-2 representation of a country, as defined by the ISO 3166-1 standard. **/
declare enum RegionCode {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** The code representing the country of Afghanistan. **/
    AF = "AF",
    /** The code representing the country of Åland Islands. **/
    AX = "AX",
    /** The code representing the country of Albania. **/
    AL = "AL",
    /** The code representing the country of Algeria. **/
    DZ = "DZ",
    /** The code representing the country of American Samoa. **/
    AS = "AS",
    /** The code representing the country of Andorra. **/
    AD = "AD",
    /** The code representing the country of Angola. **/
    AO = "AO",
    /** The code representing the country of Anguilla. **/
    AI = "AI",
    /** The code representing the country of Antarctica. **/
    AQ = "AQ",
    /** The code representing the country of Antigua and Barbuda. **/
    AG = "AG",
    /** The code representing the country of Argentina. **/
    AR = "AR",
    /** The code representing the country of Armenia. **/
    AM = "AM",
    /** The code representing the country of Aruba. **/
    AW = "AW",
    /** The code representing the country of Australia. **/
    AU = "AU",
    /** The code representing the country of Austria. **/
    AT = "AT",
    /** The code representing the country of Azerbaijan. **/
    AZ = "AZ",
    /** The code representing the country of Bahamas. **/
    BS = "BS",
    /** The code representing the country of Bahrain. **/
    BH = "BH",
    /** The code representing the country of Bangladesh. **/
    BD = "BD",
    /** The code representing the country of Barbados. **/
    BB = "BB",
    /** The code representing the country of Belarus. **/
    BY = "BY",
    /** The code representing the country of Belgium. **/
    BE = "BE",
    /** The code representing the country of Belize. **/
    BZ = "BZ",
    /** The code representing the country of Benin. **/
    BJ = "BJ",
    /** The code representing the country of Bermuda. **/
    BM = "BM",
    /** The code representing the country of Bhutan. **/
    BT = "BT",
    /** The code representing the country of The Plurinational State of Bolivia. **/
    BO = "BO",
    /** The code representing the country of Bonaire, Sint Eustatius, and Saba. **/
    BQ = "BQ",
    /** The code representing the country of Bosnia and Herzegovina. **/
    BA = "BA",
    /** The code representing the country of Botswana. **/
    BW = "BW",
    /** The code representing the country of Bouvet Island. **/
    BV = "BV",
    /** The code representing the country of Brazil. **/
    BR = "BR",
    /** The code representing the country of British Indian Ocean Territory. **/
    IO = "IO",
    /** The code representing the country of Brunei Darussalam. **/
    BN = "BN",
    /** The code representing the country of Bulgaria. **/
    BG = "BG",
    /** The code representing the country of Burkina Faso. **/
    BF = "BF",
    /** The code representing the country of Burundi. **/
    BI = "BI",
    /** The code representing the country of Cambodia. **/
    KH = "KH",
    /** The code representing the country of Cameroon. **/
    CM = "CM",
    /** The code representing the country of Canada. **/
    CA = "CA",
    /** The code representing the country of Cape Verde. **/
    CV = "CV",
    /** The code representing the country of Cayman Islands. **/
    KY = "KY",
    /** The code representing the country of Central African Republic. **/
    CF = "CF",
    /** The code representing the country of Chad. **/
    TD = "TD",
    /** The code representing the country of Chile. **/
    CL = "CL",
    /** The code representing the country of China. **/
    CN = "CN",
    /** The code representing the country of Christmas Island. **/
    CX = "CX",
    /** The code representing the country of Cocos (Keeling) Islands. **/
    CC = "CC",
    /** The code representing the country of Colombia. **/
    CO = "CO",
    /** The code representing the country of Comoros. **/
    KM = "KM",
    /** The code representing the country of Congo. **/
    CG = "CG",
    /** The code representing the country of The Democratic Republic of the Congo. **/
    CD = "CD",
    /** The code representing the country of Cook Islands. **/
    CK = "CK",
    /** The code representing the country of Costa Rica. **/
    CR = "CR",
    /** The code representing the country of Côte d'Ivoire. **/
    CI = "CI",
    /** The code representing the country of Croatia. **/
    HR = "HR",
    /** The code representing the country of Cuba. **/
    CU = "CU",
    /** The code representing the country of Curaçao. **/
    CW = "CW",
    /** The code representing the country of Cyprus. **/
    CY = "CY",
    /** The code representing the country of Czech Republic. **/
    CZ = "CZ",
    /** The code representing the country of Denmark. **/
    DK = "DK",
    /** The code representing the country of Djibouti. **/
    DJ = "DJ",
    /** The code representing the country of Dominica. **/
    DM = "DM",
    /** The code representing the country of Dominican Republic. **/
    DO = "DO",
    /** The code representing the country of Ecuador. **/
    EC = "EC",
    /** The code representing the country of Egypt. **/
    EG = "EG",
    /** The code representing the country of El Salvador. **/
    SV = "SV",
    /** The code representing the country of Equatorial Guinea. **/
    GQ = "GQ",
    /** The code representing the country of Eritrea. **/
    ER = "ER",
    /** The code representing the country of Estonia. **/
    EE = "EE",
    /** The code representing the country of Ethiopia. **/
    ET = "ET",
    /** The code representing the country of Falkland Islands (Malvinas). **/
    FK = "FK",
    /** The code representing the country of Faroe Islands. **/
    FO = "FO",
    /** The code representing the country of Fiji. **/
    FJ = "FJ",
    /** The code representing the country of Finland. **/
    FI = "FI",
    /** The code representing the country of France. **/
    FR = "FR",
    /** The code representing the country of French Guiana. **/
    GF = "GF",
    /** The code representing the country of French Polynesia. **/
    PF = "PF",
    /** The code representing the country of French Southern Territories. **/
    TF = "TF",
    /** The code representing the country of Gabon. **/
    GA = "GA",
    /** The code representing the country of Gambia. **/
    GM = "GM",
    /** The code representing the country of Georgia. **/
    GE = "GE",
    /** The code representing the country of Germany. **/
    DE = "DE",
    /** The code representing the country of Ghana. **/
    GH = "GH",
    /** The code representing the country of Gibraltar. **/
    GI = "GI",
    /** The code representing the country of Greece. **/
    GR = "GR",
    /** The code representing the country of Greenland. **/
    GL = "GL",
    /** The code representing the country of Grenada. **/
    GD = "GD",
    /** The code representing the country of Guadeloupe. **/
    GP = "GP",
    /** The code representing the country of Guam. **/
    GU = "GU",
    /** The code representing the country of Guatemala. **/
    GT = "GT",
    /** The code representing the country of Guernsey. **/
    GG = "GG",
    /** The code representing the country of Guinea. **/
    GN = "GN",
    /** The code representing the country of Guinea-Bissau. **/
    GW = "GW",
    /** The code representing the country of Guyana. **/
    GY = "GY",
    /** The code representing the country of Haiti. **/
    HT = "HT",
    /** The code representing the country of Heard Island and McDonald Islands. **/
    HM = "HM",
    /** The code representing the country of Holy See (Vatican City State). **/
    VA = "VA",
    /** The code representing the country of Honduras. **/
    HN = "HN",
    /** The code representing the country of Hong Kong. **/
    HK = "HK",
    /** The code representing the country of Hungary. **/
    HU = "HU",
    /** The code representing the country of Iceland. **/
    IS = "IS",
    /** The code representing the country of India. **/
    IN = "IN",
    /** The code representing the country of Indonesia. **/
    ID = "ID",
    /** The code representing the country of Islamic Republic of Iran. **/
    IR = "IR",
    /** The code representing the country of Iraq. **/
    IQ = "IQ",
    /** The code representing the country of Ireland. **/
    IE = "IE",
    /** The code representing the country of Isle of Man. **/
    IM = "IM",
    /** The code representing the country of Israel. **/
    IL = "IL",
    /** The code representing the country of Italy. **/
    IT = "IT",
    /** The code representing the country of Jamaica. **/
    JM = "JM",
    /** The code representing the country of Japan. **/
    JP = "JP",
    /** The code representing the country of Jersey. **/
    JE = "JE",
    /** The code representing the country of Jordan. **/
    JO = "JO",
    /** The code representing the country of Kazakhstan. **/
    KZ = "KZ",
    /** The code representing the country of Kenya. **/
    KE = "KE",
    /** The code representing the country of Kiribati. **/
    KI = "KI",
    /** The code representing the country of Democratic People's Republic ofKorea. **/
    KP = "KP",
    /** The code representing the country of Republic of Korea. **/
    KR = "KR",
    /** The code representing the country of Kuwait. **/
    KW = "KW",
    /** The code representing the country of Kyrgyzstan. **/
    KG = "KG",
    /** The code representing the country of Lao People's Democratic Republic. **/
    LA = "LA",
    /** The code representing the country of Latvia. **/
    LV = "LV",
    /** The code representing the country of Lebanon. **/
    LB = "LB",
    /** The code representing the country of Lesotho. **/
    LS = "LS",
    /** The code representing the country of Liberia. **/
    LR = "LR",
    /** The code representing the country of Libya. **/
    LY = "LY",
    /** The code representing the country of Liechtenstein. **/
    LI = "LI",
    /** The code representing the country of Lithuania. **/
    LT = "LT",
    /** The code representing the country of Luxembourg. **/
    LU = "LU",
    /** The code representing the country of Macao. **/
    MO = "MO",
    /** The code representing the country of The Former Yugoslav Republic of Macedonia. **/
    MK = "MK",
    /** The code representing the country of Madagascar. **/
    MG = "MG",
    /** The code representing the country of Malawi. **/
    MW = "MW",
    /** The code representing the country of Malaysia. **/
    MY = "MY",
    /** The code representing the country of Maldives. **/
    MV = "MV",
    /** The code representing the country of Mali. **/
    ML = "ML",
    /** The code representing the country of Malta. **/
    MT = "MT",
    /** The code representing the country of Marshall Islands. **/
    MH = "MH",
    /** The code representing the country of Martinique. **/
    MQ = "MQ",
    /** The code representing the country of Mauritania. **/
    MR = "MR",
    /** The code representing the country of Mauritius. **/
    MU = "MU",
    /** The code representing the country of Mayotte. **/
    YT = "YT",
    /** The code representing the country of Mexico. **/
    MX = "MX",
    /** The code representing the country of Federated States ofMicronesia. **/
    FM = "FM",
    /** The code representing the country of Republic of Moldova. **/
    MD = "MD",
    /** The code representing the country of Monaco. **/
    MC = "MC",
    /** The code representing the country of Mongolia. **/
    MN = "MN",
    /** The code representing the country of Montenegro. **/
    ME = "ME",
    /** The code representing the country of Montserrat. **/
    MS = "MS",
    /** The code representing the country of Morocco. **/
    MA = "MA",
    /** The code representing the country of Mozambique. **/
    MZ = "MZ",
    /** The code representing the country of Myanmar. **/
    MM = "MM",
    /** The code representing the country of Namibia. **/
    NA = "NA",
    /** The code representing the country of Nauru. **/
    NR = "NR",
    /** The code representing the country of Nepal. **/
    NP = "NP",
    /** The code representing the country of Netherlands. **/
    NL = "NL",
    /** The code representing the country of New Caledonia. **/
    NC = "NC",
    /** The code representing the country of New Zealand. **/
    NZ = "NZ",
    /** The code representing the country of Nicaragua. **/
    NI = "NI",
    /** The code representing the country of Niger. **/
    NE = "NE",
    /** The code representing the country of Nigeria. **/
    NG = "NG",
    /** The code representing the country of Niue. **/
    NU = "NU",
    /** The code representing the country of Norfolk Island. **/
    NF = "NF",
    /** The code representing the country of Northern Mariana Islands. **/
    MP = "MP",
    /** The code representing the country of Norway. **/
    NO = "NO",
    /** The code representing the country of Oman. **/
    OM = "OM",
    /** The code representing the country of Pakistan. **/
    PK = "PK",
    /** The code representing the country of Palau. **/
    PW = "PW",
    /** The code representing the country of State of Palestine. **/
    PS = "PS",
    /** The code representing the country of Panama. **/
    PA = "PA",
    /** The code representing the country of Papua New Guinea. **/
    PG = "PG",
    /** The code representing the country of Paraguay. **/
    PY = "PY",
    /** The code representing the country of Peru. **/
    PE = "PE",
    /** The code representing the country of Philippines. **/
    PH = "PH",
    /** The code representing the country of Pitcairn. **/
    PN = "PN",
    /** The code representing the country of Poland. **/
    PL = "PL",
    /** The code representing the country of Portugal. **/
    PT = "PT",
    /** The code representing the country of Puerto Rico. **/
    PR = "PR",
    /** The code representing the country of Qatar. **/
    QA = "QA",
    /** The code representing the country of Réunion. **/
    RE = "RE",
    /** The code representing the country of Romania. **/
    RO = "RO",
    /** The code representing the country of Russian Federation. **/
    RU = "RU",
    /** The code representing the country of Rwanda. **/
    RW = "RW",
    /** The code representing the country of Saint Barthélemy. **/
    BL = "BL",
    /** The code representing the country of Saint Helena  Ascension and Tristan da Cunha. **/
    SH = "SH",
    /** The code representing the country of Saint Kitts and Nevis. **/
    KN = "KN",
    /** The code representing the country of Saint Lucia. **/
    LC = "LC",
    /** The code representing the country of Saint Martin (French part). **/
    MF = "MF",
    /** The code representing the country of Saint Pierre and Miquelon. **/
    PM = "PM",
    /** The code representing the country of Saint Vincent and the Grenadines. **/
    VC = "VC",
    /** The code representing the country of Samoa. **/
    WS = "WS",
    /** The code representing the country of San Marino. **/
    SM = "SM",
    /** The code representing the country of Sao Tome and Principe. **/
    ST = "ST",
    /** The code representing the country of Saudi Arabia. **/
    SA = "SA",
    /** The code representing the country of Senegal. **/
    SN = "SN",
    /** The code representing the country of Serbia. **/
    RS = "RS",
    /** The code representing the country of Seychelles. **/
    SC = "SC",
    /** The code representing the country of Sierra Leone. **/
    SL = "SL",
    /** The code representing the country of Singapore. **/
    SG = "SG",
    /** The code representing the country of Sint Maarten (Dutch part). **/
    SX = "SX",
    /** The code representing the country of Slovakia. **/
    SK = "SK",
    /** The code representing the country of Slovenia. **/
    SI = "SI",
    /** The code representing the country of Solomon Islands. **/
    SB = "SB",
    /** The code representing the country of Somalia. **/
    SO = "SO",
    /** The code representing the country of South Africa. **/
    ZA = "ZA",
    /** The code representing the country of South Georgia and the South Sandwich Islands. **/
    GS = "GS",
    /** The code representing the country of South Sudan. **/
    SS = "SS",
    /** The code representing the country of Spain. **/
    ES = "ES",
    /** The code representing the country of Sri Lanka. **/
    LK = "LK",
    /** The code representing the country of Sudan. **/
    SD = "SD",
    /** The code representing the country of Suriname. **/
    SR = "SR",
    /** The code representing the country of Svalbard and Jan Mayen. **/
    SJ = "SJ",
    /** The code representing the country of Swaziland. **/
    SZ = "SZ",
    /** The code representing the country of Sweden. **/
    SE = "SE",
    /** The code representing the country of Switzerland. **/
    CH = "CH",
    /** The code representing the country of Syrian Arab Republic. **/
    SY = "SY",
    /** The code representing the country of Taiwan, Province of China. **/
    TW = "TW",
    /** The code representing the country of Tajikistan. **/
    TJ = "TJ",
    /** The code representing the country of United Republic of Tanzania. **/
    TZ = "TZ",
    /** The code representing the country of Thailand. **/
    TH = "TH",
    /** The code representing the country of Timor-Leste. **/
    TL = "TL",
    /** The code representing the country of Togo. **/
    TG = "TG",
    /** The code representing the country of Tokelau. **/
    TK = "TK",
    /** The code representing the country of Tonga. **/
    TO = "TO",
    /** The code representing the country of Trinidad and Tobago. **/
    TT = "TT",
    /** The code representing the country of Tunisia. **/
    TN = "TN",
    /** The code representing the country of Turkey. **/
    TR = "TR",
    /** The code representing the country of Turkmenistan. **/
    TM = "TM",
    /** The code representing the country of Turks and Caicos Islands. **/
    TC = "TC",
    /** The code representing the country of Tuvalu. **/
    TV = "TV",
    /** The code representing the country of Uganda. **/
    UG = "UG",
    /** The code representing the country of Ukraine. **/
    UA = "UA",
    /** The code representing the country of United Arab Emirates. **/
    AE = "AE",
    /** The code representing the country of United Kingdom. **/
    GB = "GB",
    /** The code representing the country of United States. **/
    US = "US",
    /** The code representing the country of United States Minor Outlying Islands. **/
    UM = "UM",
    /** The code representing the country of Uruguay. **/
    UY = "UY",
    /** The code representing the country of Uzbekistan. **/
    UZ = "UZ",
    /** The code representing the country of Vanuatu. **/
    VU = "VU",
    /** The code representing the country of Bolivarian Republic of Venezuela. **/
    VE = "VE",
    /** The code representing the country of Viet Nam. **/
    VN = "VN",
    /** The code representing the country of British Virgin Islands. **/
    VG = "VG",
    /** The code representing the country of U.S. Virgin Islands. **/
    VI = "VI",
    /** The code representing the country of Wallis and Futuna. **/
    WF = "WF",
    /** The code representing the country of Western Sahara. **/
    EH = "EH",
    /** The code representing the country of Yemen. **/
    YE = "YE",
    /** The code representing the country of Zambia. **/
    ZM = "ZM",
    /** The code representing the country of Zimbabwe. **/
    ZW = "ZW"
}

type SingleNodeDashboard = {
    id: string;
    displayName: string;
    color: Maybe<string>;
    publicKey: Maybe<string>;
    status: Maybe<LightsparkNodeStatus>;
    addresses: {
        address: string;
        type: NodeAddressType;
    }[];
    totalBalance: Maybe<CurrencyAmount>;
    totalLocalBalance: Maybe<CurrencyAmount>;
    onlineLocalBalance: Maybe<CurrencyAmount>;
    remoteBalance: Maybe<CurrencyAmount>;
    blockchainBalance: {
        availableBalance: Maybe<CurrencyAmount>;
        totalBalance: Maybe<CurrencyAmount>;
        confirmedBalance: Maybe<CurrencyAmount>;
        unconfirmedBalance: Maybe<CurrencyAmount>;
    } | null;
    recentTransactions: Transaction[];
};

type TransactionUpdate = {
    /**
     * The unique identifier of this entity across all Lightspark systems.
     * Should be treated as an opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string;
    /**
     * The hash of this transaction, so it can be uniquely identified on the
     * Lightning Network. *
     */
    transactionHash?: string;
};

/** Describes the reason for an invitation to not be eligible for incentives. **/
declare enum IncentivesIneligibilityReason {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /**
     * This invitation is not eligible for incentives because it has been created outside of the
     * incentives flow. *
     */
    DISABLED = "DISABLED",
    /** This invitation is not eligible for incentives because the sender is not eligible. **/
    SENDER_NOT_ELIGIBLE = "SENDER_NOT_ELIGIBLE",
    /** This invitation is not eligible for incentives because the receiver is not eligible. **/
    RECEIVER_NOT_ELIGIBLE = "RECEIVER_NOT_ELIGIBLE",
    /**
     * This invitation is not eligible for incentives because the sending VASP is not part of the
     * incentives program. *
     */
    SENDING_VASP_NOT_ELIGIBLE = "SENDING_VASP_NOT_ELIGIBLE",
    /**
     * This invitation is not eligible for incentives because the receiving VASP is not part of the
     * incentives program. *
     */
    RECEIVING_VASP_NOT_ELIGIBLE = "RECEIVING_VASP_NOT_ELIGIBLE",
    /**
     * This invitation is not eligible for incentives because the sender and receiver are in the same
     * region. *
     */
    NOT_CROSS_BORDER = "NOT_CROSS_BORDER"
}

/** Describes the status of the incentives for this invitation. **/
declare enum IncentivesStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /**
     * The invitation is eligible for incentives in its current state. When it is claimed, we will
     * reassess. *
     */
    PENDING = "PENDING",
    /** The incentives have been validated. **/
    VALIDATED = "VALIDATED",
    /**
     * This invitation is not eligible for incentives. A more detailed reason can be found in the
     * `incentives_ineligibility_reason` field. *
     */
    INELIGIBLE = "INELIGIBLE"
}

/** This is an object representing an UMA.ME invitation. **/
interface UmaInvitation {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The code that uniquely identifies this invitation. **/
    code: string;
    /** The URL where this invitation can be claimed. **/
    url: string;
    /** The UMA of the user who created the invitation. **/
    inviterUma: string;
    /** The current status of the incentives that may be tied to this invitation. **/
    incentivesStatus: IncentivesStatus;
    /** The typename of the object **/
    typename: string;
    /** The UMA of the user who claimed the invitation. **/
    inviteeUma?: string | undefined;
    /** The reason why the invitation is not eligible for incentives, if applicable. **/
    incentivesIneligibilityReason?: IncentivesIneligibilityReason | undefined;
}
declare const getUmaInvitationQuery: (id: string) => Query<UmaInvitation>;

/**
 * The LightsparkClient is the main entrypoint for interacting with the
 * Lightspark API.
 *
 * ```ts
 * const lightsparkClient = new LightsparkClient(
 *  new AccountTokenAuthProvider(TOKEN_ID, TOKEN_SECRET)
 * );
 * const encodedInvoice = await lightsparkClient.createInvoice(
 *   RECEIVING_NODE_ID,
 *   { value: 100, unit: CurrencyUnit.SATOSHI },
 *   "Whasssupppp",
 *   InvoiceType.AMP,
 * );
 *
 * const invoiceDetails = await lightsparkClient.decodeInvoice(encodedInvoice);
 * console.log(invoiceDetails);
 *
 * const payment = await lightsparkClient.payInvoice(PAYING_NODE_ID, encodedInvoice, 100000);
 * console.log(payment);
 * ```
 *
 * @class LightsparkClient
 */
declare class LightsparkClient {
    private authProvider;
    private readonly serverUrl;
    private readonly cryptoImpl;
    private requester;
    private readonly nodeKeyCache;
    private readonly nodeKeyLoaderCache;
    private readonly LIGHTSPARK_SDK_ENDPOINT;
    /**
     * Constructs a new LightsparkClient.
     *
     * @param authProvider The auth provider to use for authentication. Defaults to a stub auth provider.
     * For server-side
     *     use, you should use the `AccountTokenAuthProvider`.
     * @param serverUrl The base URL of the server to connect to. Defaults to lightspark production.
     * @param cryptoImpl The crypto implementation to use. Defaults to web and node compatible crypto.
     *     For React Native, you should use the `ReactNativeCrypto`
     *     implementation from `@lightsparkdev/react-native`.
     */
    constructor(authProvider?: AuthProvider, serverUrl?: string, cryptoImpl?: CryptoInterface);
    /**
     * Sets the key loader for a node. This unlocks client operations that
     * require a private key. Passing in [NodeIdAndPasswordSigningKeyLoaderArgs]
     * loads the RSA key for an OSK node.
     * Passing in [MasterSeedSigningKeyLoaderArgs] loads the Secp256k1 key for a
     * remote signing node.
     *
     * @param nodeId The ID of the node the key is for
     * @param loader The loader for the key
     */
    loadNodeSigningKey(nodeId: string, loaderArgs: SigningKeyLoaderArgs): Promise<boolean>;
    /**
     * Gets the signing key for a node. Must have previously called
     * [loadNodeSigningKey].
     *
     * @param nodeId The ID of the node the key is for
     * @returns The signing key for the node
     */
    getNodeSigningKey(nodeId: string): Promise<SigningKey | undefined>;
    /**
     * Sets the auth provider for the client.
     * This is useful for switching between auth providers if you are using
     * multiple accounts or waiting for the user to log in.
     *
     * @param authProvider
     */
    setAuthProvider(authProvider: AuthProvider): void;
    /**
     * @returns Whether or not the client is authorized. This is useful for determining if the user is logged in or not.
     */
    isAuthorized(): Promise<boolean>;
    /**
     * @returns The current account, if one exists.
     */
    getCurrentAccount(): Promise<Maybe<Account>>;
    /**
     * Retrieves the most recent transactions for a given node.
     *
     * @param nodeId The node ID for which to read transactions
     * @param numTransactions The maximum number of transactions to read. Defaults to 20.
     * @param bitcoinNetwork The bitcoin network on which to read transactions. Defaults to MAINNET.
     * @param afterDate Filters transactions to those after the given date. Defaults to undefined (no limit).
     * @returns An array of transactions for the given node ID.
     */
    getRecentTransactions(nodeId: string, numTransactions?: number, bitcoinNetwork?: BitcoinNetwork, afterDate?: Maybe<string>): Promise<Transaction[]>;
    getTransaction(transactionId: string): Promise<Maybe<Transaction>>;
    /**
     * Retrieves the most recent payment requests for a given node.
     *
     * @param nodeId The node ID for which to read transactions
     * @param numTransactions The maximum number of transactions to read. Defaults to 20.
     * @param bitcoinNetwork The bitcoin network on which to read transactions. Defaults to MAINNET.
     * @param afterDate Filters transactions to those after the given date. Defaults to undefined (no limit).
     * @returns An array of payment requests for the given node ID.
     */
    getRecentPaymentRequests(nodeId: string, numTransactions?: number, bitcoinNetwork?: BitcoinNetwork, afterDate?: Maybe<string>): Promise<Transaction[]>;
    /**
     * Starts listening for new transactions or updates to existing transactions
     * for a list of nodes.
     *
     * @param nodeIds The node IDs for which to listen to transactions.
     * @returns A zen-observable that emits transaction updates for the given node IDs.
     */
    listenToTransactions(nodeIds: string[]): Observable<TransactionUpdate | undefined>;
    /**
     * Retrieves a dashboard of basic info for the authenticated account.
     * See `AccountDashboard` for which info is included.
     *
     * @param nodeIds The node IDs to include in the dashboard. Defaults to undefined (all nodes).
     * @param bitcoinNetwork The bitcoin network to include in the dashboard. Defaults to MAINNET.
     * @returns A basic account dashboard for the given node IDs.
     * @throws LightsparkAuthException if the user is not logged in or a LightsparkException if no nodes are found.
     */
    getAccountDashboard(nodeIds?: string[] | undefined, bitcoinNetwork?: BitcoinNetwork): Promise<AccountDashboard>;
    /**
     * Gets a basic dashboard for a single node, including recent transactions.
     * See `SingleNodeDashboard` for which info is included.
     *
     * @param nodeId The node ID for which to get a dashboard.
     * @param bitcoinNetwork The bitcoin network for which to get a dashboard. Defaults to MAINNET.
     * @param transactionsAfterDate Filters recent transactions to those after the given date.
     *     Defaults to undefined (no limit).
     * @returns A basic dashboard for the given node ID.
     */
    getSingleNodeDashboard(nodeId: string, bitcoinNetwork?: BitcoinNetwork, transactionsAfterDate?: Maybe<string>): Promise<SingleNodeDashboard>;
    /**
     * Creates an invoice for the given node.
     *
     * Test mode note: You can simulate a payment of this invoice in test move
     * using [createTestModePayment].
     *
     * @param nodeId The node ID for which to create an invoice.
     * @param amountMsats The amount of the invoice in msats. You can create a zero-amount invoice to accept any payment amount.
     * @param memo A string memo to include in the invoice as a description.
     * @param type The type of invoice to create. Defaults to a normal payment invoice, but you can pass InvoiceType.AMP
     *     to create an [AMP invoice](https://docs.lightning.engineering/lightning-network-tools/lnd/amp), which can be
     *     paid multiple times.
     * @param expirySecs The number of seconds until the invoice expires. Defaults to 86400 (1 day).
     * @returns An encoded payment request for the invoice, or undefined if the invoice could not be created.
     */
    createInvoice(nodeId: string, amountMsats: number, memo: string, type?: InvoiceType | undefined, expirySecs?: number | undefined): Promise<string | undefined>;
    /**
     * Generates a Lightning Invoice (follows the Bolt 11 specification) to
     * request a payment from another Lightning Node.
     * This should only be used for generating invoices for LNURLs,
     * with [createInvoice] preferred in the general case.
     *
     * Test mode note: You can simulate a payment of this invoice in test move
     * using [createTestModePayment].
     *
     * @param nodeId The node ID for which to create an invoice.
     * @param amountMsats The amount of the invoice in msats. You can create a zero-amount invoice to accept any payment amount.
     * @param metadata The LNURL metadata payload field in the initial payreq response. This wil be hashed and present in the
     *     h-tag (SHA256 purpose of payment) of the resulting Bolt 11 invoice. See
     *     [this spec](https://github.com/lnurl/luds/blob/luds/06.md#pay-to-static-qrnfclink) for details.
     * @param expirySecs The number of seconds until the invoice expires. Defaults to 86400 (1 day).
     * @returns An Invoice object representing the generated invoice.
     */
    createLnurlInvoice(nodeId: string, amountMsats: number, metadata: string, expirySecs?: number | undefined): Promise<Invoice | undefined>;
    /**
     * Creates a new invoice for the UMA protocol.
     * The metadata is hashed and included in the invoice.
     * This API generates a Lightning Invoice (follows the Bolt 11 specification)
     * to request a payment from another Lightning Node.
     * This should only be used for generating invoices for UMA,
     * with `createInvoice` preferred in the general case.
     *
     * @param nodeId The node ID for which to create an invoice.
     * @param amountMsats The amount of the invoice in msats. You can create a zero-amount invoice to accept any payment amount.
     * @param metadata The LNURL metadata payload field in the initial payreq response. This wil be hashed and present in the
     *     h-tag (SHA256 purpose of payment) of the resulting Bolt 11 invoice. See
     *     [this spec](https://github.com/lnurl/luds/blob/luds/06.md#pay-to-static-qrnfclink) for details.
     * @param expirySecs The number of seconds until the invoice expires. Defaults to 3600 (1 hour).
     * @returns An Invoice object representing the generated invoice.
     */
    createUmaInvoice(nodeId: string, amountMsats: number, metadata: string, expirySecs?: number | undefined): Promise<Invoice | undefined>;
    /**
     * Cancels an existing unpaid invoice and returns that invoice. Cancelled invoices cannot be paid.
     *
     * @param invoiceId The ID of the invoice to cancel.
     * @returns The cancelled invoice, or undefined if the invoice could not be cancelled.
     */
    cancelInvoice(invoiceId: string): Promise<Invoice | undefined>;
    /**
     * Decodes an encoded lightning invoice string.
     *
     * @param encodedInvoice The string encoded invoice to decode.
     * @returns Decoded invoice data.
     */
    decodeInvoice(encodedInvoice: string): Promise<InvoiceData>;
    /**
     * Gets an estimate of the fee for sending a payment over the given bitcoin
     * network.
     *
     * @param bitcoinNetwork The bitcoin network for which to get a fee estimate. Defaults to MAINNET.
     * @returns A fee estimate for the given bitcoin network including a minimum fee rate, and a max-speed fee rate.
     */
    getBitcoinFeeEstimate(bitcoinNetwork?: BitcoinNetwork): Promise<FeeEstimate>;
    /**
     * Gets an estimate of the fees that will be paid for a Lightning invoice.
     *
     * @param nodeId The node from where you want to send the payment.
     * @param encodedPaymentRequest The invoice you want to pay (as defined by the BOLT11 standard).
     * @param amountMsats If the invoice does not specify a payment amount, then the amount that you wish to pay,
     *     expressed in msats.
     * @returns An estimate of the fees that will be paid for a Lightning invoice.
     */
    getLightningFeeEstimateForInvoice(nodeId: string, encodedPaymentRequest: string, amountMsats?: number | undefined): Promise<CurrencyAmount>;
    /**
     * Returns an estimate of the fees that will be paid to send a payment to
     * another Lightning node.
     *
     * @param nodeId The node from where you want to send the payment.
     * @param destinationNodePublicKey The public key of the node that you want to pay.
     * @param amountMsats The payment amount expressed in msats.
     * @returns An estimate of the fees that will be paid to send a payment to another Lightning node.
     */
    getLightningFeeEstimateForNode(nodeId: string, destinationNodePublicKey: string, amountMsats: number): Promise<CurrencyAmount>;
    /**
     * Returns an estimated amount for the L1 withdrawal fees for the specified node, amount, and
     * strategy.
     *
     * @param nodeId The node from which you'd like to make the withdrawal.
     * @param amountSats The amount you want to withdraw from this node in Satoshis. Use the special value -1 to withdrawal all funds from this node.
     * @param withdrawalMode The strategy that should be used to withdraw the funds from this node.
     * @returns An estimated amount for the L1 withdrawal fees for the specified node, amount, and strategy.
     */
    getWithrawalFeeEstimate(nodeId: string, amountSats: number, withdrawalMode: WithdrawalMode): Promise<CurrencyAmount>;
    /**
     * Directly unlocks a node with a signing private key or alias.
     *
     * @param nodeId The ID of the node to unlock.
     * @param signingPrivateKeyPEM The PEM-encoded signing private key.
     */
    loadNodeKey(nodeId: string, signingPrivateKeyOrAlias: KeyOrAliasType): Promise<void>;
    /**
     * Sends a lightning payment for a given invoice.
     *
     * Test mode note: For test mode, you can use the [createTestModeInvoice]
     * function to create an invoice you can pay in test mode.
     *
     * @param payerNodeId The ID of the node that will pay the invoice.
     * @param encodedInvoice The encoded invoice to pay.
     * @param maximumFeesMsats Maximum fees (in msats) to pay for the payment. This parameter is required.
     *     As guidance, a maximum fee of 16 basis points should make almost all
     *     transactions succeed. For example,
     *     for a transaction between 10k sats and 100k sats,
     *     this would mean a fee limit of 16 to 160 sats.
     * @param timeoutSecs A timeout for the payment in seconds. Defaults to 60 seconds.
     * @param amountMsats The amount to pay in msats for a zero-amount invoice. Defaults to the full amount of the
     *     invoice. NOTE: This parameter can only be passed for a zero-amount
     *     invoice. Otherwise, the call will fail.
     * @returns An `OutgoingPayment` object if the payment was successful, or undefined if the payment failed.
     */
    payInvoice(payerNodeId: string, encodedInvoice: string, maximumFeesMsats: number, timeoutSecs?: number, amountMsats?: number | undefined): Promise<OutgoingPayment | undefined>;
    /**
     * sends an UMA payment to a node on the Lightning Network,
     * based on the invoice (as defined by the BOLT11 specification) that you
     * provide.
     * This should only be used for paying UMA invoices,
     * with `payInvoice` preferred in the general case.
     *
     * @param payerNodeId The ID of the node that will pay the invoice.
     * @param encodedInvoice The encoded invoice to pay.
     * @param maximumFeesMsats Maximum fees (in msats) to pay for the payment. This parameter is required.
     *     As guidance, a maximum fee of 16 basis points should make almost all
     *     transactions succeed. For example,
     *     for a transaction between 10k sats and 100k sats,
     *     this would mean a fee limit of 16 to 160 sats.
     * @param timeoutSecs A timeout for the payment in seconds. Defaults to 60 seconds.
     * @param amountMsats The amount to pay in msats for a zero-amount invoice. Defaults to the full amount of the
     *     invoice. NOTE: This parameter can only be passed for a zero-amount
     *     invoice. Otherwise, the call will fail.
     * @returns An `OutgoingPayment` object if the payment was successful, or undefined if the payment failed.
     */
    payUmaInvoice(payerNodeId: string, encodedInvoice: string, maximumFeesMsats: number, timeoutSecs?: number, amountMsats?: number | undefined): Promise<OutgoingPayment | undefined>;
    /**
     * Waits for a transaction to have a completed status, and returns the
     * transaction.
     *
     * @param transactionId The ID of the transaction to wait for
     * @param pollTimeoutSecs The timeout in seconds that we will wait before throwing an exception
     */
    waitForTransactionComplete<T = Transaction>(transactionId: string, pollTimeoutSecs?: number): Promise<T>;
    /**
     * Sends a payment directly to a node on the Lightning Network through the
     * public key of the node without an invoice.
     *
     * @param payerNodeId The ID of the node that will send the payment.
     * @param destinationPublicKey The public key of the destination node.
     * @param timeoutSecs The timeout in seconds that we will try to make the payment.
     * @param amountMsats The amount to pay in msats.
     * @param maximumFeesMsats Maximum fees (in msats) to pay for the payment. This parameter is required.
     *     As guidance, a maximum fee of 15 basis points should make almost all
     *     transactions succeed. For example,
     *     for a transaction between 10k sats and 100k sats,
     *     this would mean a fee limit of 15 to 150 sats.
     * @returns An `OutgoingPayment` object if the payment was successful, or undefined if the payment failed.
     */
    sendPayment(payerNodeId: string, destinationPublicKey: string, timeoutSecs: number | undefined, amountMsats: number, maximumFeesMsats: number): Promise<OutgoingPayment | undefined>;
    /**
     * Creates an L1 Bitcoin wallet address for a given node which can be used to
     * deposit or withdraw funds.
     *
     * @param nodeId The ID of the node to create a wallet address for.
     * @returns A string containing the wallet address for the given node.
     */
    createNodeWalletAddress(nodeId: string): Promise<string>;
    /**
     * Withdraws funds from the account and sends it to the requested bitcoin
     * address.
     *
     * Depending on the chosen mode, it will first take the funds from the
     * wallet, and if applicable, close channels appropriately to recover enough
     * funds and reopen channels with the remaining funds.
     * The process is asynchronous and may take up to a few minutes.
     * You can check the progress by polling the `WithdrawalRequest` that is
     * created, or by subscribing to a webhook.
     *
     * @param nodeId The ID of the node from which to withdraw funds.
     * @param amountSats The amount of funds to withdraw in satoshis.
     * @param bitcoinAddress The Bitcoin address to withdraw funds to.
     * @param mode The mode to use for the withdrawal. See `WithdrawalMode` for more information.
     */
    requestWithdrawal(nodeId: string, amountSats: number, bitcoinAddress: string, mode: WithdrawalMode): Promise<WithdrawalRequest>;
    /**
     * Adds funds to a Lightspark node on the REGTEST network.
     * If the amount is not specified, 10,000,000 SATOSHI will be added.
     * This API only functions for nodes created on the REGTEST network and will
     * return an error when called for any non-REGTEST node.
     *
     * @param nodeId The ID of the node to fund. Must be a REGTEST node.
     * @param amountSats The amount of funds to add to the node in satoshis. Defaults to 10,000,000 SATOSHI.
     * @returns
     */
    fundNode(nodeId: string, amountSats?: number | undefined): Promise<CurrencyAmount>;
    /**
     * Creates a new API token that can be used to authenticate requests for this
     * account when using the Lightspark APIs and SDKs.
     *
     * @param name Creates a new API token that can be used to authenticate requests for this account when using the
     *     Lightspark APIs and SDKs.
     * @param transact Whether the token should be able to transact or only view data.
     * @param testMode True if the token should be able to access only testnet false to access only mainnet.
     * @returns An object containing the API token and client secret.
     */
    createApiToken(name: string, transact?: boolean, testMode?: boolean): Promise<CreateApiTokenOutput>;
    /**
     * Deletes an existing API token from this account.
     *
     * @param id The ID of the API token to delete.
     */
    deleteApiToken(id: string): Promise<void>;
    /**
     * In test mode, generates a Lightning Invoice which can be paid by a local
     * node. This call is only valid in test mode.
     * You can then pay the invoice using [payInvoice].
     *
     * @param localNodeId The ID of the node that will pay the invoice.
     * @param amountMsats The amount to pay in milli-satoshis.
     * @param memo An optional memo to attach to the invoice.
     * @param invoiceType The type of invoice to create.
     */
    createTestModeInvoice(localNodeId: string, amountMsats: number, memo?: string | undefined, invoiceType?: InvoiceType): Promise<string | null>;
    /**
     * In test mode, simulates a payment of a Lightning Invoice from another
     * node. This can only be used in test mode and should be used with invoices
     * generated by [createInvoice].
     *
     * @param localNodeId The ID of the node that will receive the payment.
     * @param encodedInvoice The encoded invoice to pay.
     * @param amountMsats The amount to pay in milli-satoshis for 0-amount invoices. This should be null for non-zero
     *     amount invoices.
     */
    createTestModePayment(localNodeId: string, encodedInvoice: string, amountMsats?: number | undefined): Promise<IncomingPayment | null>;
    /**
     * Performs sanction screening on a lightning node against a given compliance provider.
     *
     * @param complianceProvider The provider that you want to use to perform the screening. You must have a valid
     *     API token for the provider set in your Lightspark account settings.
     * @param nodePubKey The public key of the node that needs to be screened.
     * @returns A RiskRating for the node.
     */
    screenNode(complianceProvider: ComplianceProvider, nodePubKey: string): Promise<RiskRating | null>;
    /**
     * Registers a succeeded payment with a compliance provider for monitoring.
     *
     * @param complianceProvider The provider that you want to use to register the payment. You must have
     *     a valid API token for the provider set in your Lightspark account settings.
     * @param paymentId The unique ID of the payment
     * @param nodePubKey The public key of the counterparty node which is the recipient node if the
     *     payment is an outgoing payment and the sender node if the payment is an incoming payment.
     * @param paymentDirection Indicates whether the payment is an incoming or outgoing payment.
     * @returns The ID of the payment that was registered.
     */
    registerPayment(complianceProvider: ComplianceProvider, paymentId: string, nodePubKey: string, paymentDirection: PaymentDirection): Promise<string | null>;
    /**
     * Creates an UMA invitation. If you are part of the incentive program,
     * you should use [createUmaInvitationWithIncentives].
     *
     * @param inviterUma The UMA of the inviter.
     * @returns The invitation that was created.
     */
    createUmaInvitation(inviterUma: string): Promise<UmaInvitation | null>;
    /**
     * Creates an UMA invitation as part of the incentive program.
     * @param inviterUma The UMA of the inviter.
     * @param inviterPhoneNumber The phone number of the inviter in E164 format.
     * @param inviterRegion The region of the inviter.
     * @returns The invitation that was created.
     */
    createUmaInvitationWithIncentives(inviterUma: string, inviterPhoneNumber: string, inviterRegion: RegionCode): Promise<UmaInvitation | null>;
    /**
     * Claims an UMA invitation. If you are part of the incentive program,
     * you should use [claimUmaInvitationWithIncentives].
     *
     * @param invitationCode The invitation code to claim.
     * @param inviteeUma The UMA of the invitee.
     * @returns The invitation that was claimed.
     */
    claimUmaInvitation(invitationCode: string, inviteeUma: string): Promise<UmaInvitation | null>;
    /**
     * Claims an UMA invitation as part of the incentive program.
     *
     * @param invitationCode The invitation code to claim.
     * @param inviteeUma The UMA of the invitee.
     * @param inviteePhoneNumber The phone number of the invitee in E164 format.
     * @param inviteeRegion The region of the invitee.
     * @returns The invitation that was claimed.
     */
    claimUmaInvitationWithIncentives(invitationCode: string, inviteeUma: string, inviteePhoneNumber: string, inviteeRegion: RegionCode): Promise<UmaInvitation | null>;
    /**
     * Fetches an UMA invitation by its invitation code.
     *
     * @param invitationCode The code of the invitation to fetch.
     * @returns The invitation with the given code, or null if no invitation exists with that code.
     */
    fetchUmaInvitation(invitationCode: string): Promise<UmaInvitation | null>;
    private hashPhoneNumber;
    /**
     * Executes a raw `Query` against the Lightspark API.
     *
     * This generally should not be used directly,
     * but is exposed for advanced use cases and for internal use to retrieve
     * complex fields from objects.
     *
     * @param query The `Query` to execute.
     * @returns The result of the query.
     */
    executeRawQuery<T>(query: Query<T>): Promise<T | null>;
}

interface CancelInvoiceInput {
    invoiceId: string;
}

interface CancelInvoiceOutput {
    invoiceId: string;
}

interface ClaimUmaInvitationInput {
    invitationCode: string;
    inviteeUma: string;
}

interface ClaimUmaInvitationOutput {
    invitationId: string;
}

interface ClaimUmaInvitationWithIncentivesInput {
    invitationCode: string;
    inviteeUma: string;
    inviteePhoneHash: string;
    inviteeRegion: RegionCode;
}

interface ClaimUmaInvitationWithIncentivesOutput {
    invitationId: string;
}

interface Connection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The typename of the object **/
    typename: string;
}

interface CreateApiTokenInput {
    /** An arbitrary name that the user can choose to identify the API token in a list. **/
    name: string;
    /** List of permissions to grant to the API token **/
    permissions: Permission[];
}

interface CreateInvitationWithIncentivesInput {
    inviterUma: string;
    inviterPhoneHash: string;
    inviterRegion: RegionCode;
}

interface CreateInvitationWithIncentivesOutput {
    invitationId: string;
}

interface CreateInvoiceInput {
    /** The node from which to create the invoice. **/
    nodeId: string;
    /** The amount for which the invoice should be created, in millisatoshis. **/
    amountMsats: number;
    memo?: string | undefined;
    invoiceType?: InvoiceType | undefined;
    /** The expiry of the invoice in seconds. Default value is 86400 (1 day). **/
    expirySecs?: number | undefined;
}

interface CreateInvoiceOutput {
    invoiceId: string;
}

interface CreateLnurlInvoiceInput {
    /** The node from which to create the invoice. **/
    nodeId: string;
    /** The amount for which the invoice should be created, in millisatoshis. **/
    amountMsats: number;
    /**
     * The SHA256 hash of the LNURL metadata payload. This will be present in the h-tag (SHA256
     * purpose of payment) of the resulting Bolt 11 invoice.
     **/
    metadataHash: string;
    /** The expiry of the invoice in seconds. Default value is 86400 (1 day). **/
    expirySecs?: number | undefined;
}

interface CreateNodeWalletAddressInput {
    nodeId: string;
}

interface CreateNodeWalletAddressOutput {
    nodeId: string;
    walletAddress: string;
}

interface CreateTestModeInvoiceInput {
    localNodeId: string;
    amountMsats: number;
    memo?: string | undefined;
    invoiceType?: InvoiceType | undefined;
}

interface CreateTestModeInvoiceOutput {
    encodedPaymentRequest: string;
}

interface CreateTestModePaymentInput {
    /** The node to where you want to send the payment. **/
    localNodeId: string;
    /** The invoice you want to be paid (as defined by the BOLT11 standard). **/
    encodedInvoice: string;
    /**
     * The amount you will be paid for this invoice, expressed in msats. It should ONLY be set when
     * the invoice amount is zero.
     **/
    amountMsats?: number | undefined;
}

/**
 * This is an object identifying the output of a test mode payment. This object can be used to
 * retrieve the associated payment made from a Test Mode Payment call. *
 */
interface CreateTestModePaymentoutput {
    /**
     * The payment that has been sent.
     *
     * @deprecated Use incoming_payment instead.
     **/
    paymentId: string;
    /** The payment that has been received. **/
    incomingPaymentId: string;
}

interface CreateUmaInvitationInput {
    inviterUma: string;
}

interface CreateUmaInvitationOutput {
    invitationId: string;
}

interface CreateUmaInvoiceInput {
    nodeId: string;
    amountMsats: number;
    metadataHash: string;
    expirySecs?: number | undefined;
}

interface DeclineToSignMessagesInput {
    /** List of payload ids to decline to sign because validation failed. **/
    payloadIds: string[];
}

declare enum SignablePayloadStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    CREATED = "CREATED",
    SIGNED = "SIGNED",
    VALIDATION_FAILED = "VALIDATION_FAILED",
    INVALID_SIGNATURE = "INVALID_SIGNATURE"
}

interface SignablePayload {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The payload that needs to be signed. **/
    payload: string;
    /**
     * The consistent method for generating the same set of accounts and wallets for a given
     * private key *
     */
    derivationPath: string;
    /** The status of the payload. **/
    status: SignablePayloadStatus;
    /** The signable this payload belongs to. **/
    signableId: string;
    /** The typename of the object **/
    typename: string;
    /** The tweak value to add. **/
    addTweak?: string | undefined;
    /** The tweak value to multiply. **/
    mulTweak?: string | undefined;
}
declare const getSignablePayloadQuery: (id: string) => Query<SignablePayload>;

interface DeclineToSignMessagesOutput {
    declinedPayloads: SignablePayload[];
}

interface DeleteApiTokenInput {
    apiTokenId: string;
}

interface DeleteApiTokenOutput {
    accountId: string;
}

/**
 * This object represents a Deposit made to a Lightspark node wallet. This operation occurs for any
 * L1 funding transaction to the wallet. You can retrieve this object to receive detailed
 * information about the deposit. *
 */
interface Deposit {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The recipient Lightspark node this deposit was sent to. **/
    destinationId: string;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /**
     * The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin
     * blockchain.
     **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
}
declare const getDepositQuery: (id: string) => Query<Deposit>;

interface FundNodeInput {
    nodeId: string;
    amountSats?: number | undefined;
}

interface FundNodeOutput {
    amount: CurrencyAmount;
}

/**
 * This object represents a node that exists on the Lightning Network, including nodes not managed
 * by Lightspark. You can retrieve this object to get publicly available information about any node
 * on the Lightning Network. *
 */
declare class GraphNode implements Node, Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The Bitcoin Network this node is deployed in. **/
    readonly bitcoinNetwork: BitcoinNetwork;
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    readonly displayName: string;
    /** The typename of the object **/
    readonly typename: string;
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    readonly alias?: string | undefined;
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    readonly color?: string | undefined;
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    readonly conductivity?: number | undefined;
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    readonly publicKey?: string | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The Bitcoin Network this node is deployed in. **/
    bitcoinNetwork: BitcoinNetwork, 
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    displayName: string, 
    /** The typename of the object **/
    typename: string, 
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    alias?: string | undefined, 
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    color?: string | undefined, 
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    conductivity?: number | undefined, 
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    publicKey?: string | undefined);
    getAddresses(client: LightsparkClient, first?: number | undefined, types?: NodeAddressType[] | undefined): Promise<NodeToAddressesConnection>;
    static getGraphNodeQuery(id: string): Query<GraphNode>;
    toJson(): {
        __typename: string;
        graph_node_id: string;
        graph_node_created_at: string;
        graph_node_updated_at: string;
        graph_node_alias: string | undefined;
        graph_node_bitcoin_network: BitcoinNetwork;
        graph_node_color: string | undefined;
        graph_node_conductivity: number | undefined;
        graph_node_display_name: string;
        graph_node_public_key: string | undefined;
    };
}

interface IdAndSignature {
    /** The id of the message. **/
    id: string;
    /** The signature of the message. **/
    signature: string;
}

interface LightningFeeEstimateForInvoiceInput {
    /** The node from where you want to send the payment. **/
    nodeId: string;
    /** The invoice you want to pay (as defined by the BOLT11 standard). **/
    encodedPaymentRequest: string;
    /**
     * If the invoice does not specify a payment amount, then the amount that you wish to pay,
     * expressed in msats.
     **/
    amountMsats?: number | undefined;
}

interface LightningFeeEstimateForNodeInput {
    /** The node from where you want to send the payment. **/
    nodeId: string;
    /** The public key of the node that you want to pay. **/
    destinationNodePublicKey: string;
    /** The payment amount expressed in msats. **/
    amountMsats: number;
}

interface LightningFeeEstimateOutput {
    /** The estimated fees for the payment. **/
    feeEstimate: CurrencyAmount;
}

interface Secret {
    encryptedValue: string;
    cipher: string;
}

/** This is a Lightspark node with OSK. **/
declare class LightsparkNodeWithOSK implements LightsparkNode, Node, Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The Bitcoin Network this node is deployed in. **/
    readonly bitcoinNetwork: BitcoinNetwork;
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    readonly displayName: string;
    /** The owner of this LightsparkNode. **/
    readonly ownerId: string;
    /**
     * The utxos of the channels that are connected to this node. This is used in uma flow for
     * pre-screening.
     **/
    readonly umaPrescreeningUtxos: string[];
    /** The typename of the object **/
    readonly typename: string;
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    readonly alias?: string | undefined;
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    readonly color?: string | undefined;
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    readonly conductivity?: number | undefined;
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    readonly publicKey?: string | undefined;
    /** The current status of this node. **/
    readonly status?: LightsparkNodeStatus | undefined;
    /**
     * The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this
     * node.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly totalBalance?: CurrencyAmount | undefined;
    /**
     * The total sum of the channel balances (online and offline) on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly totalLocalBalance?: CurrencyAmount | undefined;
    /**
     * The sum of the channel balances (online only) that are available to send on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly localBalance?: CurrencyAmount | undefined;
    /**
     * The sum of the channel balances that are available to receive on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly remoteBalance?: CurrencyAmount | undefined;
    /**
     * The details of the balance of this node on the Bitcoin Network.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly blockchainBalance?: BlockchainBalance | undefined;
    /** The balances that describe the funds in this node. **/
    readonly balances?: Balances | undefined;
    /**
     * The private key client is using to sign a GraphQL request which will be verified at server
     * side. *
     */
    readonly encryptedSigningPrivateKey?: Secret | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The Bitcoin Network this node is deployed in. **/
    bitcoinNetwork: BitcoinNetwork, 
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    displayName: string, 
    /** The owner of this LightsparkNode. **/
    ownerId: string, 
    /**
     * The utxos of the channels that are connected to this node. This is used in uma flow for
     * pre-screening.
     **/
    umaPrescreeningUtxos: string[], 
    /** The typename of the object **/
    typename: string, 
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    alias?: string | undefined, 
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    color?: string | undefined, 
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    conductivity?: number | undefined, 
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    publicKey?: string | undefined, 
    /** The current status of this node. **/
    status?: LightsparkNodeStatus | undefined, 
    /**
     * The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this
     * node.
     *
     * @deprecated Use `balances` instead.
     **/
    totalBalance?: CurrencyAmount | undefined, 
    /**
     * The total sum of the channel balances (online and offline) on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    totalLocalBalance?: CurrencyAmount | undefined, 
    /**
     * The sum of the channel balances (online only) that are available to send on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    localBalance?: CurrencyAmount | undefined, 
    /**
     * The sum of the channel balances that are available to receive on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    remoteBalance?: CurrencyAmount | undefined, 
    /**
     * The details of the balance of this node on the Bitcoin Network.
     *
     * @deprecated Use `balances` instead.
     **/
    blockchainBalance?: BlockchainBalance | undefined, 
    /** The balances that describe the funds in this node. **/
    balances?: Balances | undefined, 
    /**
     * The private key client is using to sign a GraphQL request which will be verified at server
     * side. *
     */
    encryptedSigningPrivateKey?: Secret | undefined);
    getAddresses(client: LightsparkClient, first?: number | undefined, types?: NodeAddressType[] | undefined): Promise<NodeToAddressesConnection>;
    getChannels(client: LightsparkClient, first?: number | undefined, statuses?: ChannelStatus[] | undefined, after?: string | undefined): Promise<LightsparkNodeToChannelsConnection>;
    static getLightsparkNodeWithOSKQuery(id: string): Query<LightsparkNodeWithOSK>;
    toJson(): {
        __typename: string;
        lightspark_node_with_o_s_k_id: string;
        lightspark_node_with_o_s_k_created_at: string;
        lightspark_node_with_o_s_k_updated_at: string;
        lightspark_node_with_o_s_k_alias: string | undefined;
        lightspark_node_with_o_s_k_bitcoin_network: BitcoinNetwork;
        lightspark_node_with_o_s_k_color: string | undefined;
        lightspark_node_with_o_s_k_conductivity: number | undefined;
        lightspark_node_with_o_s_k_display_name: string;
        lightspark_node_with_o_s_k_public_key: string | undefined;
        lightspark_node_with_o_s_k_owner: {
            id: string;
        };
        lightspark_node_with_o_s_k_status: LightsparkNodeStatus | undefined;
        lightspark_node_with_o_s_k_total_balance: any;
        lightspark_node_with_o_s_k_total_local_balance: any;
        lightspark_node_with_o_s_k_local_balance: any;
        lightspark_node_with_o_s_k_remote_balance: any;
        lightspark_node_with_o_s_k_blockchain_balance: any;
        lightspark_node_with_o_s_k_uma_prescreening_utxos: string[];
        lightspark_node_with_o_s_k_balances: any;
        lightspark_node_with_o_s_k_encrypted_signing_private_key: any;
    };
}

/** This is a Lightspark node with remote signing. **/
declare class LightsparkNodeWithRemoteSigning implements LightsparkNode, Node, Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The Bitcoin Network this node is deployed in. **/
    readonly bitcoinNetwork: BitcoinNetwork;
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    readonly displayName: string;
    /** The owner of this LightsparkNode. **/
    readonly ownerId: string;
    /**
     * The utxos of the channels that are connected to this node. This is used in uma flow for
     * pre-screening.
     **/
    readonly umaPrescreeningUtxos: string[];
    /** The typename of the object **/
    readonly typename: string;
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    readonly alias?: string | undefined;
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    readonly color?: string | undefined;
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    readonly conductivity?: number | undefined;
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    readonly publicKey?: string | undefined;
    /** The current status of this node. **/
    readonly status?: LightsparkNodeStatus | undefined;
    /**
     * The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this
     * node.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly totalBalance?: CurrencyAmount | undefined;
    /**
     * The total sum of the channel balances (online and offline) on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly totalLocalBalance?: CurrencyAmount | undefined;
    /**
     * The sum of the channel balances (online only) that are available to send on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly localBalance?: CurrencyAmount | undefined;
    /**
     * The sum of the channel balances that are available to receive on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly remoteBalance?: CurrencyAmount | undefined;
    /**
     * The details of the balance of this node on the Bitcoin Network.
     *
     * @deprecated Use `balances` instead.
     **/
    readonly blockchainBalance?: BlockchainBalance | undefined;
    /** The balances that describe the funds in this node. **/
    readonly balances?: Balances | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The Bitcoin Network this node is deployed in. **/
    bitcoinNetwork: BitcoinNetwork, 
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    displayName: string, 
    /** The owner of this LightsparkNode. **/
    ownerId: string, 
    /**
     * The utxos of the channels that are connected to this node. This is used in uma flow for
     * pre-screening.
     **/
    umaPrescreeningUtxos: string[], 
    /** The typename of the object **/
    typename: string, 
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    alias?: string | undefined, 
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    color?: string | undefined, 
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    conductivity?: number | undefined, 
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    publicKey?: string | undefined, 
    /** The current status of this node. **/
    status?: LightsparkNodeStatus | undefined, 
    /**
     * The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this
     * node.
     *
     * @deprecated Use `balances` instead.
     **/
    totalBalance?: CurrencyAmount | undefined, 
    /**
     * The total sum of the channel balances (online and offline) on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    totalLocalBalance?: CurrencyAmount | undefined, 
    /**
     * The sum of the channel balances (online only) that are available to send on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    localBalance?: CurrencyAmount | undefined, 
    /**
     * The sum of the channel balances that are available to receive on this node.
     *
     * @deprecated Use `balances` instead.
     **/
    remoteBalance?: CurrencyAmount | undefined, 
    /**
     * The details of the balance of this node on the Bitcoin Network.
     *
     * @deprecated Use `balances` instead.
     **/
    blockchainBalance?: BlockchainBalance | undefined, 
    /** The balances that describe the funds in this node. **/
    balances?: Balances | undefined);
    getAddresses(client: LightsparkClient, first?: number | undefined, types?: NodeAddressType[] | undefined): Promise<NodeToAddressesConnection>;
    getChannels(client: LightsparkClient, first?: number | undefined, statuses?: ChannelStatus[] | undefined, after?: string | undefined): Promise<LightsparkNodeToChannelsConnection>;
    static getLightsparkNodeWithRemoteSigningQuery(id: string): Query<LightsparkNodeWithRemoteSigning>;
    toJson(): {
        __typename: string;
        lightspark_node_with_remote_signing_id: string;
        lightspark_node_with_remote_signing_created_at: string;
        lightspark_node_with_remote_signing_updated_at: string;
        lightspark_node_with_remote_signing_alias: string | undefined;
        lightspark_node_with_remote_signing_bitcoin_network: BitcoinNetwork;
        lightspark_node_with_remote_signing_color: string | undefined;
        lightspark_node_with_remote_signing_conductivity: number | undefined;
        lightspark_node_with_remote_signing_display_name: string;
        lightspark_node_with_remote_signing_public_key: string | undefined;
        lightspark_node_with_remote_signing_owner: {
            id: string;
        };
        lightspark_node_with_remote_signing_status: LightsparkNodeStatus | undefined;
        lightspark_node_with_remote_signing_total_balance: any;
        lightspark_node_with_remote_signing_total_local_balance: any;
        lightspark_node_with_remote_signing_local_balance: any;
        lightspark_node_with_remote_signing_remote_balance: any;
        lightspark_node_with_remote_signing_blockchain_balance: any;
        lightspark_node_with_remote_signing_uma_prescreening_utxos: string[];
        lightspark_node_with_remote_signing_balances: any;
    };
}

/**
 * This object represents an L1 transaction that occurred on the Bitcoin Network. You can retrieve
 * this object to receive information about a specific on-chain transaction made on the Lightning
 * Network associated with your Lightspark Node. *
 */
interface OnChainTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /**
     * The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin
     * blockchain.
     **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
}
declare const getOnChainTransactionQuery: (id: string) => Query<OnChainTransaction>;

interface OutgoingPaymentsForInvoiceQueryInput {
    /** The encoded invoice that the outgoing payments paid to. **/
    encodedInvoice: string;
    /** An optional filter to only query outgoing payments of given statuses. **/
    statuses?: TransactionStatus[] | undefined;
}

interface OutgoingPaymentsForInvoiceQueryOutput {
    payments: OutgoingPayment[];
}

interface PayInvoiceInput {
    /** The node from where you want to send the payment. **/
    nodeId: string;
    /** The invoice you want to pay (as defined by the BOLT11 standard). **/
    encodedInvoice: string;
    /** The timeout in seconds that we will try to make the payment. **/
    timeoutSecs: number;
    /**
     * The maximum amount of fees that you want to pay for this payment to be sent, expressed in
     * msats. *
     */
    maximumFeesMsats: number;
    /**
     * The amount you will pay for this invoice, expressed in msats. It should ONLY be set when the
     * invoice amount is zero.
     **/
    amountMsats?: number | undefined;
}

interface PayInvoiceOutput {
    /** The payment that has been sent. **/
    paymentId: string;
}

interface PayUmaInvoiceInput {
    nodeId: string;
    encodedInvoice: string;
    timeoutSecs: number;
    maximumFeesMsats: number;
    amountMsats?: number | undefined;
}

interface RegisterPaymentInput {
    /**
     * The compliance provider that is going to screen the node. You need to be a customer of the
     * selected provider and store the API key on the Lightspark account setting page.
     **/
    provider: ComplianceProvider;
    /**
     * The Lightspark ID of the lightning payment you want to register. It can be the id of either
     * an OutgoingPayment or an IncomingPayment.
     **/
    paymentId: string;
    /**
     * The public key of the counterparty lightning node, which would be the public key of the
     * recipient node if it is to register an outgoing payment, or the public key of the sender
     * node if it is to register an incoming payment.
     **/
    nodePubkey: string;
    /** Indicates whether this payment is an OutgoingPayment or an IncomingPayment. **/
    direction: PaymentDirection;
}

interface RegisterPaymentOutput {
    paymentId: string;
}

interface ReleaseChannelPerCommitmentSecretInput {
    /** The unique identifier of the channel. **/
    channelId: string;
    /** The per-commitment secret to be released. **/
    perCommitmentSecret: string;
    /** The index associated with the per-commitment secret. **/
    perCommitmentIndex: number;
}

interface ReleaseChannelPerCommitmentSecretOutput {
    /** The channel object after the per-commitment secret release operation. **/
    channelId: string;
}

interface ReleasePaymentPreimageInput {
    /** The invoice the preimage belongs to. **/
    invoiceId: string;
    /** The preimage to release. **/
    paymentPreimage: string;
}

interface ReleasePaymentPreimageOutput {
    /** The invoice of the transaction. **/
    invoiceId: string;
}

/** This is an enum of the potential sub-event types for Remote Signing webook events. **/
declare enum RemoteSigningSubEventType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    ECDH = "ECDH",
    GET_PER_COMMITMENT_POINT = "GET_PER_COMMITMENT_POINT",
    RELEASE_PER_COMMITMENT_SECRET = "RELEASE_PER_COMMITMENT_SECRET",
    SIGN_INVOICE = "SIGN_INVOICE",
    DERIVE_KEY_AND_SIGN = "DERIVE_KEY_AND_SIGN",
    RELEASE_PAYMENT_PREIMAGE = "RELEASE_PAYMENT_PREIMAGE",
    REQUEST_INVOICE_PAYMENT_HASH = "REQUEST_INVOICE_PAYMENT_HASH",
    REVEAL_COUNTERPARTY_PER_COMMITMENT_SECRET = "REVEAL_COUNTERPARTY_PER_COMMITMENT_SECRET"
}

interface RequestWithdrawalInput {
    /** The node from which you'd like to make the withdrawal. **/
    nodeId: string;
    /** The bitcoin address where the withdrawal should be sent. **/
    bitcoinAddress: string;
    /**
     * The amount you want to withdraw from this node in Satoshis. Use the special value -1 to
     * withdrawal all funds from this node.
     **/
    amountSats: number;
    /** The strategy that should be used to withdraw the funds from this node. **/
    withdrawalMode: WithdrawalMode;
}

interface RequestWithdrawalOutput {
    /** The request that is created for this withdrawal. **/
    requestId: string;
}

/**
 * This is an enum of the potential risk ratings related to a transaction made over the Lightning
 * Network. These risk ratings are returned from the CryptoSanctionScreeningProvider. *
 */
declare enum RiskRating {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    HIGH_RISK = "HIGH_RISK",
    LOW_RISK = "LOW_RISK",
    UNKNOWN = "UNKNOWN"
}

/**
 * This object represents a transaction that was forwarded through a Lightspark node on the
 * Lightning Network, i.e., a routed transaction. You can retrieve this object to receive
 * information about any transaction routed through your Lightspark Node. *
 */
interface RoutingTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /** If known, the channel this transaction was received from. **/
    incomingChannelId?: string | undefined;
    /** If known, the channel this transaction was forwarded to. **/
    outgoingChannelId?: string | undefined;
    /**
     * The fees collected by the node when routing this transaction. We subtract the outgoing
     * amount to the incoming amount to determine how much fees were collected.
     **/
    fees?: CurrencyAmount | undefined;
    /** If applicable, user-facing error message describing why the routing failed. **/
    failureMessage?: RichText | undefined;
    /** If applicable, the reason why the routing failed. **/
    failureReason?: RoutingTransactionFailureReason | undefined;
}
declare const getRoutingTransactionQuery: (id: string) => Query<RoutingTransaction>;

interface ScreenNodeInput {
    /**
     * The compliance provider that is going to screen the node. You need to be a customer of the
     * selected provider and store the API key on the Lightspark account setting page.
     **/
    provider: ComplianceProvider;
    /** The public key of the lightning node that needs to be screened. **/
    nodePubkey: string;
}

interface ScreenNodeOutput {
    rating: RiskRating;
}

interface SendPaymentInput {
    /** The node from where you want to send the payment. **/
    nodeId: string;
    /** The public key of the destination node. **/
    destinationPublicKey: string;
    /** The timeout in seconds that we will try to make the payment. **/
    timeoutSecs: number;
    /** The amount you will send to the destination node, expressed in msats. **/
    amountMsats: number;
    /**
     * The maximum amount of fees that you want to pay for this payment to be sent, expressed in
     * msats. *
     */
    maximumFeesMsats: number;
}

interface SendPaymentOutput {
    /** The payment that has been sent. **/
    paymentId: string;
}

interface SetInvoicePaymentHashInput {
    /** The invoice that needs to be updated. **/
    invoiceId: string;
    /** The 32-byte hash of the payment preimage. **/
    paymentHash: string;
    /**
     * The 32-byte nonce used to generate the invoice preimage if applicable. It will later be
     * included in RELEASE_PAYMENT_PREIMAGE webhook to help recover the raw preimage.
     **/
    preimageNonce?: string | undefined;
}

interface SetInvoicePaymentHashOutput {
    invoiceId: string;
}

interface SignInvoiceInput {
    /** The unique identifier of the invoice to be signed. **/
    invoiceId: string;
    /** The cryptographic signature for the invoice. **/
    signature: string;
    /** The recovery identifier for the signature. **/
    recoveryId: number;
}

interface SignInvoiceOutput {
    /** The signed invoice object. **/
    invoiceId: string;
}

interface SignMessagesInput {
    /** The list of the message ids and signatures. **/
    signatures: IdAndSignature[];
}

interface SignMessagesOutput {
    /** The list of signed payloads. **/
    signedPayloads: SignablePayload[];
}

interface Signable {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The typename of the object **/
    typename: string;
}
declare const getSignableQuery: (id: string) => Query<Signable>;

interface UpdateChannelPerCommitmentPointInput {
    channelId: string;
    perCommitmentPoint: string;
    perCommitmentPointIndex: number;
}

interface UpdateChannelPerCommitmentPointOutput {
    channelId: string;
}

interface UpdateNodeSharedSecretInput {
    nodeId: string;
    sharedSecret: string;
}

interface UpdateNodeSharedSecretOutput {
    nodeId: string;
}

/**
 * This is an enum of the potential event types that can be associated with your Lightspark
 * wallets. *
 */
declare enum WebhookEventType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    PAYMENT_FINISHED = "PAYMENT_FINISHED",
    FORCE_CLOSURE = "FORCE_CLOSURE",
    WITHDRAWAL_FINISHED = "WITHDRAWAL_FINISHED",
    FUNDS_RECEIVED = "FUNDS_RECEIVED",
    NODE_STATUS = "NODE_STATUS",
    UMA_INVITATION_CLAIMED = "UMA_INVITATION_CLAIMED",
    WALLET_STATUS = "WALLET_STATUS",
    WALLET_OUTGOING_PAYMENT_FINISHED = "WALLET_OUTGOING_PAYMENT_FINISHED",
    WALLET_INCOMING_PAYMENT_FINISHED = "WALLET_INCOMING_PAYMENT_FINISHED",
    WALLET_WITHDRAWAL_FINISHED = "WALLET_WITHDRAWAL_FINISHED",
    WALLET_FUNDS_RECEIVED = "WALLET_FUNDS_RECEIVED",
    REMOTE_SIGNING = "REMOTE_SIGNING",
    LOW_BALANCE = "LOW_BALANCE"
}

/**
 * This object represents an L1 withdrawal from your Lightspark Node to any Bitcoin wallet. You can
 * retrieve this object to receive detailed information about any L1 withdrawal associated with
 * your Lightspark Node or account. *
 */
interface Withdrawal {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The Lightspark node this withdrawal originated from. **/
    originId: string;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /**
     * The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin
     * blockchain.
     **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
}
declare const getWithdrawalQuery: (id: string) => Query<Withdrawal>;

interface WithdrawalFeeEstimateInput {
    /** The node from which you'd like to make the withdrawal. **/
    nodeId: string;
    /**
     * The amount you want to withdraw from this node in Satoshis. Use the special value -1 to
     * withdrawal all funds from this node.
     **/
    amountSats: number;
    /** The strategy that should be used to withdraw the funds from this node. **/
    withdrawalMode: WithdrawalMode;
}

interface WithdrawalFeeEstimateOutput {
    /** The estimated fee for the withdrawal. **/
    feeEstimate: CurrencyAmount;
}

export { Deposit as $, Account as A, Balances as B, CancelInvoiceInput as C, CreateApiTokenInput as D, CreateApiTokenOutput as E, CreateInvitationWithIncentivesInput as F, CreateInvitationWithIncentivesOutput as G, CreateInvoiceInput as H, CreateInvoiceOutput as I, CreateLnurlInvoiceInput as J, CreateNodeWalletAddressInput as K, LightsparkClient as L, CreateNodeWalletAddressOutput as M, CreateTestModeInvoiceInput as N, CreateTestModeInvoiceOutput as O, CreateTestModePaymentInput as P, CreateTestModePaymentoutput as Q, CreateUmaInvitationInput as R, CreateUmaInvitationOutput as S, CreateUmaInvoiceInput as T, CurrencyAmount as U, CurrencyUnit as V, WebhookEventType as W, DeclineToSignMessagesInput as X, DeclineToSignMessagesOutput as Y, DeleteApiTokenInput as Z, DeleteApiTokenOutput as _, AccountToApiTokensConnection as a, ReleaseChannelPerCommitmentSecretInput as a$, getDepositQuery as a0, Entity as a1, FeeEstimate as a2, FundNodeInput as a3, FundNodeOutput as a4, GraphNode as a5, Hop as a6, getHopQuery as a7, HtlcAttemptFailureCode as a8, IdAndSignature as a9, NodeAddress as aA, NodeAddressType as aB, NodeToAddressesConnection as aC, OnChainTransaction as aD, getOnChainTransactionQuery as aE, OutgoingPayment as aF, OutgoingPaymentAttempt as aG, OutgoingPaymentAttemptStatus as aH, OutgoingPaymentAttemptToHopsConnection as aI, OutgoingPaymentToAttemptsConnection as aJ, OutgoingPaymentsForInvoiceQueryInput as aK, OutgoingPaymentsForInvoiceQueryOutput as aL, PageInfo as aM, PayInvoiceInput as aN, PayInvoiceOutput as aO, PayUmaInvoiceInput as aP, PaymentDirection as aQ, PaymentFailureReason as aR, PaymentRequest as aS, getPaymentRequestQuery as aT, PaymentRequestData as aU, PaymentRequestStatus as aV, Permission as aW, PostTransactionData as aX, RegionCode as aY, RegisterPaymentInput as aZ, RegisterPaymentOutput as a_, IncentivesIneligibilityReason as aa, IncentivesStatus as ab, IncomingPayment as ac, IncomingPaymentAttempt as ad, getIncomingPaymentAttemptQuery as ae, IncomingPaymentAttemptStatus as af, IncomingPaymentToAttemptsConnection as ag, Invoice as ah, getInvoiceQuery as ai, InvoiceData as aj, InvoiceType as ak, LightningFeeEstimateForInvoiceInput as al, LightningFeeEstimateForNodeInput as am, LightningFeeEstimateOutput as an, LightningTransaction as ao, getLightningTransactionQuery as ap, LightsparkNode as aq, getLightsparkNodeQuery as ar, LightsparkNodeOwner as as, getLightsparkNodeOwnerQuery as at, LightsparkNodeStatus as au, LightsparkNodeToChannelsConnection as av, LightsparkNodeWithOSK as aw, LightsparkNodeWithRemoteSigning as ax, Node as ay, getNodeQuery as az, AccountToChannelsConnection as b, ReleaseChannelPerCommitmentSecretOutput as b0, ReleasePaymentPreimageInput as b1, ReleasePaymentPreimageOutput as b2, RemoteSigningSubEventType as b3, RequestWithdrawalInput as b4, RequestWithdrawalOutput as b5, RichText as b6, RiskRating as b7, RoutingTransaction as b8, getRoutingTransactionQuery as b9, UpdateChannelPerCommitmentPointInput as bA, UpdateChannelPerCommitmentPointOutput as bB, UpdateNodeSharedSecretInput as bC, UpdateNodeSharedSecretOutput as bD, Wallet as bE, WalletStatus as bF, WalletToPaymentRequestsConnection as bG, WalletToTransactionsConnection as bH, WalletToWithdrawalRequestsConnection as bI, Withdrawal as bJ, getWithdrawalQuery as bK, WithdrawalFeeEstimateInput as bL, WithdrawalFeeEstimateOutput as bM, WithdrawalMode as bN, WithdrawalRequest as bO, WithdrawalRequestStatus as bP, WithdrawalRequestToChannelClosingTransactionsConnection as bQ, WithdrawalRequestToChannelOpeningTransactionsConnection as bR, RoutingTransactionFailureReason as ba, ScreenNodeInput as bb, ScreenNodeOutput as bc, Secret as bd, SendPaymentInput as be, SendPaymentOutput as bf, SetInvoicePaymentHashInput as bg, SetInvoicePaymentHashOutput as bh, SignInvoiceInput as bi, SignInvoiceOutput as bj, SignMessagesInput as bk, SignMessagesOutput as bl, Signable as bm, getSignableQuery as bn, SignablePayload as bo, getSignablePayloadQuery as bp, SignablePayloadStatus as bq, SingleNodeDashboard as br, Transaction as bs, getTransactionQuery as bt, TransactionFailures as bu, TransactionStatus as bv, TransactionType as bw, TransactionUpdate as bx, UmaInvitation as by, getUmaInvitationQuery as bz, AccountToNodesConnection as c, AccountToPaymentRequestsConnection as d, AccountToTransactionsConnection as e, AccountToWalletsConnection as f, AccountToWithdrawalRequestsConnection as g, ApiToken as h, getApiTokenQuery as i, BlockchainBalance as j, CancelInvoiceOutput as k, Channel as l, ChannelClosingTransaction as m, getChannelClosingTransactionQuery as n, ChannelFees as o, ChannelOpeningTransaction as p, getChannelOpeningTransactionQuery as q, ChannelSnapshot as r, ChannelStatus as s, ChannelToTransactionsConnection as t, ClaimUmaInvitationInput as u, ClaimUmaInvitationOutput as v, ClaimUmaInvitationWithIncentivesInput as w, ClaimUmaInvitationWithIncentivesOutput as x, ComplianceProvider as y, Connection as z };
