"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ConfigKeys: () => ConfigKeys,
  CurrencyUnit: () => CurrencyUnit,
  DefaultCrypto: () => DefaultCrypto,
  KeyOrAlias: () => KeyOrAlias,
  LightsparkAuthException: () => LightsparkAuthException_default,
  LightsparkException: () => LightsparkException_default,
  LightsparkSigningException: () => LightsparkSigningException_default,
  Logger: () => Logger,
  NodeKeyCache: () => NodeKeyCache_default,
  RSASigningKey: () => RSASigningKey,
  Requester: () => Requester_default,
  Secp256k1SigningKey: () => Secp256k1SigningKey,
  ServerEnvironment: () => ServerEnvironment_default,
  SigningKey: () => SigningKey,
  SigningKeyType: () => SigningKeyType,
  StubAuthProvider: () => StubAuthProvider,
  abbrCurrencyUnit: () => abbrCurrencyUnit,
  apiDomainForEnvironment: () => apiDomainForEnvironment,
  b64decode: () => b64decode,
  b64encode: () => b64encode,
  bytesToHex: () => bytesToHex,
  clamp: () => clamp,
  convertCurrencyAmount: () => convertCurrencyAmount,
  convertCurrencyAmountValue: () => convertCurrencyAmountValue,
  countryCodesToCurrencyCodes: () => countryCodesToCurrencyCodes,
  createSha256Hash: () => createSha256Hash,
  defaultCurrencyCode: () => defaultCurrencyCode,
  errorToJSON: () => errorToJSON,
  formatCurrencyStr: () => formatCurrencyStr,
  getCurrentLocale: () => getCurrentLocale,
  getErrorMsg: () => getErrorMsg,
  getLocalStorageBoolean: () => getLocalStorageBoolean,
  getLocalStorageConfigItem: () => getLocalStorageConfigItem,
  hexToBytes: () => hexToBytes,
  isBrowser: () => isBrowser,
  isCurrencyAmount: () => isCurrencyAmount,
  isCurrencyAmountObj: () => isCurrencyAmountObj,
  isCurrencyMap: () => isCurrencyMap,
  isError: () => isError,
  isErrorMsg: () => isErrorMsg,
  isErrorWithMessage: () => isErrorWithMessage,
  isNode: () => isNode,
  isNumber: () => isNumber,
  isTest: () => isTest,
  isType: () => isType,
  linearInterpolate: () => linearInterpolate,
  localeToCurrencyCode: () => localeToCurrencyCode,
  localeToCurrencySymbol: () => localeToCurrencySymbol,
  mapCurrencyAmount: () => mapCurrencyAmount,
  pollUntil: () => pollUntil,
  round: () => round,
  separateCurrencyStrParts: () => separateCurrencyStrParts,
  sleep: () => sleep,
  urlsafe_b64decode: () => urlsafe_b64decode
});
module.exports = __toCommonJS(src_exports);

// src/LightsparkException.ts
var LightsparkException = class extends Error {
  code;
  message;
  extraInfo;
  constructor(code, message, extraInfo) {
    super(message);
    this.code = code;
    this.message = message;
    this.extraInfo = extraInfo;
  }
};
var LightsparkException_default = LightsparkException;

// src/utils/environment.ts
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var isTest = isNode && process.env.NODE_ENV === "test";

// src/Logger.ts
var Logger = class {
  context;
  loggingEnabled = false;
  constructor(loggerContext, getLoggingEnabled) {
    this.context = loggerContext;
    void this.updateLoggingEnabled(getLoggingEnabled);
  }
  async updateLoggingEnabled(getLoggingEnabled) {
    if (getLoggingEnabled) {
      this.loggingEnabled = await getLoggingEnabled();
    } else if (isTest) {
      this.loggingEnabled = true;
    } else if (isBrowser) {
      try {
        this.loggingEnabled = getLocalStorageConfigItem(
          ConfigKeys.LoggingEnabled
        );
      } catch (e) {
      }
    }
    if (this.loggingEnabled) {
      console.log(`[${this.context}] Logging enabled`);
    }
  }
  info(message, ...rest) {
    if (this.loggingEnabled) {
      console.log(`[${this.context}] ${message}`, ...rest);
    }
  }
};
var logger = new Logger("@lightsparkdev/core");

// src/ServerEnvironment.ts
var ServerEnvironment = /* @__PURE__ */ ((ServerEnvironment2) => {
  ServerEnvironment2["PRODUCTION"] = "production";
  ServerEnvironment2["DEV"] = "dev";
  return ServerEnvironment2;
})(ServerEnvironment || {});
var apiDomainForEnvironment = (environment) => {
  switch (environment) {
    case "dev" /* DEV */:
      return "api.dev.dev.sparkinfra.net";
    case "production" /* PRODUCTION */:
      return "api.lightspark.com";
  }
};
var ServerEnvironment_default = ServerEnvironment;

// src/auth/LightsparkAuthException.ts
var LightsparkAuthException = class extends LightsparkException_default {
  constructor(message, extraInfo) {
    super("AuthException", message, extraInfo);
  }
};
var LightsparkAuthException_default = LightsparkAuthException;

// src/auth/StubAuthProvider.ts
var StubAuthProvider = class {
  addAuthHeaders(headers) {
    return Promise.resolve(headers);
  }
  isAuthorized() {
    return Promise.resolve(false);
  }
  addWsConnectionParams(params) {
    return Promise.resolve(params);
  }
};

// src/constants/localStorage.ts
var ConfigKeys = {
  LoggingEnabled: "lightspark-logging-enabled",
  ConsoleToolsEnabled: "lightspark-console-tools-enabled"
};
var getLocalStorageConfigItem = (key) => {
  return getLocalStorageBoolean(key);
};
var getLocalStorageBoolean = (key) => {
  try {
    return localStorage.getItem(key) === "1";
  } catch (e) {
    return false;
  }
};

// src/crypto/KeyOrAlias.ts
var KeyOrAlias = {
  key: (key) => ({ key }),
  alias: (alias) => ({ alias })
};

// src/crypto/LightsparkSigningException.ts
var LightsparkSigningException = class extends LightsparkException_default {
  constructor(message, extraInfo) {
    super("SigningException", message, extraInfo);
  }
};
var LightsparkSigningException_default = LightsparkSigningException;

// src/crypto/NodeKeyCache.ts
var import_auto_bind = __toESM(require("auto-bind"), 1);

// src/utils/base64.ts
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var Base64 = {
  btoa: (input = "") => {
    const str = input;
    let output = "";
    for (let block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = "=", i % 1); output += map.charAt(63 & block >> 8 - i % 1 * 8)) {
      charCode = str.charCodeAt(i += 3 / 4);
      if (charCode > 255) {
        throw new Error(
          "'btoa' failed: The string to be encoded contains characters outside of the Latin1 range."
        );
      }
      block = block << 8 | charCode;
    }
    return output;
  },
  atob: (input = "") => {
    const str = input.replace(/=+$/, "");
    let output = "";
    if (str.length % 4 == 1) {
      throw new Error(
        "'atob' failed: The string to be decoded is not correctly encoded."
      );
    }
    for (let bc = 0, bs = 0, buffer, i = 0; buffer = str.charAt(i++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
      buffer = chars.indexOf(buffer);
    }
    return output;
  }
};
var b64decode = (encoded) => {
  return Uint8Array.from(Base64.atob(encoded), (c) => c.charCodeAt(0));
};
var urlsafe_b64decode = (encoded) => {
  return b64decode(encoded.replace(/_/g, "/").replace(/-/g, "+"));
};
var b64encode = (data) => {
  return Base64.btoa(
    String.fromCharCode.apply(null, Array.from(new Uint8Array(data)))
  );
};

// src/crypto/crypto.ts
var getCrypto = () => {
  let cryptoImplPromise;
  if (typeof crypto !== "undefined") {
    cryptoImplPromise = Promise.resolve(crypto);
  } else {
    cryptoImplPromise = import("crypto").then((nodeCrypto) => {
      let cryptoModule = nodeCrypto;
      if (!nodeCrypto.subtle) {
        cryptoModule = Object.assign({}, cryptoModule, {
          subtle: nodeCrypto.webcrypto.subtle
        });
      }
      if (!nodeCrypto.getRandomValues) {
        cryptoModule = Object.assign({}, cryptoModule, {
          getRandomValues: (array) => {
            if (!array) {
              return array;
            }
            const buffer = Buffer.from(array.buffer);
            nodeCrypto.randomFillSync(buffer);
            return array;
          }
        });
      }
      return cryptoModule;
    });
  }
  return cryptoImplPromise;
};
var getRandomValues32 = async (arr) => {
  if (typeof crypto !== "undefined") {
    return crypto.getRandomValues(arr);
  } else {
    const cryptoImpl = await getCrypto();
    return cryptoImpl.getRandomValues(arr);
  }
};
var deriveKey = async (password, salt, iterations, algorithm, bit_len) => {
  const enc = new TextEncoder();
  const cryptoImpl = await getCrypto();
  const password_key = await cryptoImpl.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveBits", "deriveKey"]
  );
  const derived = await cryptoImpl.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt,
      iterations,
      hash: "SHA-256"
    },
    password_key,
    bit_len
  );
  const key = await cryptoImpl.subtle.importKey(
    "raw",
    derived.slice(0, 32),
    { name: algorithm, length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
  const iv = derived.slice(32);
  return [key, iv];
};
var decrypt = async (header_json, ciphertext, password) => {
  let decoded = b64decode(ciphertext);
  let header;
  if (header_json === "AES_256_CBC_PBKDF2_5000_SHA256") {
    header = {
      v: 0,
      i: 5e3
    };
    decoded = decoded.slice(8);
  } else {
    header = JSON.parse(header_json);
  }
  if (header.v < 0 || header.v > 4) {
    throw new LightsparkException_default(
      "DecryptionError",
      `Unknown version ${header.v}`
    );
  }
  const cryptoImpl = await getCrypto();
  const algorithm = header.v < 2 ? "AES-CBC" : "AES-GCM";
  const bit_len = header.v < 4 ? 384 : 352;
  const salt_len = header.v < 4 ? 8 : 16;
  if (header.lsv === 2 || header.v === 3) {
    const salt = decoded.slice(decoded.length - 8, decoded.length);
    const nonce = decoded.slice(0, 12);
    const cipherText = decoded.slice(12, decoded.length - 8);
    const [
      key
      /* , _iv */
    ] = await deriveKey(
      password,
      salt,
      header.i,
      algorithm,
      256
    );
    return await cryptoImpl.subtle.decrypt(
      { name: algorithm, iv: nonce.buffer },
      key,
      cipherText
    );
  } else {
    const salt = decoded.slice(0, salt_len);
    const encrypted = decoded.slice(salt_len);
    const [key, iv] = await deriveKey(
      password,
      salt,
      header.i,
      algorithm,
      bit_len
    );
    return await cryptoImpl.subtle.decrypt(
      { name: algorithm, iv },
      key,
      encrypted
    );
  }
};
async function decryptSecretWithNodePassword(cipher, encryptedSecret, nodePassword) {
  let decryptedValue = null;
  try {
    decryptedValue = await decrypt(cipher, encryptedSecret, nodePassword);
  } catch (ex) {
    console.error(ex);
  }
  return decryptedValue;
}
var generateSigningKeyPair = async () => {
  const cryptoImpl = await getCrypto();
  return await cryptoImpl.subtle.generateKey(
    /*algorithm:*/
    {
      name: "RSA-PSS",
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: "SHA-256"
    },
    /*extractable*/
    true,
    /*keyUsages*/
    ["sign", "verify"]
  );
};
var serializeSigningKey = async (key, format) => {
  const cryptoImpl = await getCrypto();
  return await cryptoImpl.subtle.exportKey(
    /*format*/
    format,
    /*key*/
    key
  );
};
var getNonce = async () => {
  const nonceSt = await getRandomValues32(new Uint32Array(1));
  return Number(nonceSt);
};
var sign = async (keyOrAlias, data) => {
  if (typeof keyOrAlias === "string") {
    throw new LightsparkSigningException_default(
      "Key alias not supported for default crypto."
    );
  }
  const cryptoImpl = await getCrypto();
  return await cryptoImpl.subtle.sign(
    {
      name: "RSA-PSS",
      saltLength: 32
    },
    keyOrAlias,
    data
  );
};
var importPrivateSigningKey = async (keyData) => {
  const cryptoImpl = await getCrypto();
  return await cryptoImpl.subtle.importKey(
    /*format*/
    "pkcs8",
    /*keyData*/
    keyData,
    /*algorithm*/
    {
      name: "RSA-PSS",
      hash: "SHA-256"
    },
    /*extractable*/
    true,
    /*keyUsages*/
    ["sign"]
  );
};
var DefaultCrypto = {
  decryptSecretWithNodePassword,
  generateSigningKeyPair,
  serializeSigningKey,
  getNonce,
  sign,
  importPrivateSigningKey
};

// src/crypto/SigningKey.ts
var import_secp256k1 = __toESM(require("secp256k1"), 1);

// src/utils/hex.ts
var bytesToHex = (bytes) => {
  return bytes.reduce((acc, byte) => {
    return acc += ("0" + byte.toString(16)).slice(-2);
  }, "");
};
var hexToBytes = (hex) => {
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.substr(c, 2), 16));
  }
  return Uint8Array.from(bytes);
};

// src/utils/createHash.ts
async function createSha256Hash(data, asHex) {
  if (isBrowser) {
    const source = typeof data === "string" ? new TextEncoder().encode(data) : data;
    const buffer = await window.crypto.subtle.digest("SHA-256", source);
    const arr = new Uint8Array(buffer);
    if (asHex) {
      return bytesToHex(arr);
    }
    return arr;
  } else {
    const { createHash } = await import("crypto");
    if (asHex) {
      const hexStr = createHash("sha256").update(data).digest("hex");
      return hexStr;
    }
    const buffer = createHash("sha256").update(data).digest();
    return new Uint8Array(buffer);
  }
}

// src/utils/locale.ts
function getCurrentLocale() {
  return Intl.NumberFormat().resolvedOptions().locale;
}

// src/utils/localeToCurrencyCodes.ts
var countryCodesToCurrencyCodes = {
  AD: "EUR",
  // AE: "AED",
  // AF: "AFN",
  // AG: "XCD",
  // AI: "XCD",
  // AL: "ALL",
  // AM: "AMD",
  // AO: "AOA",
  AR: "ARS",
  AS: "USD",
  AT: "EUR",
  AU: "AUD",
  // AW: "AWG",
  AX: "EUR",
  // AZ: "AZN",
  // BA: "BAM",
  // BB: "BBD",
  // BD: "BDT",
  BE: "EUR",
  // BF: "XOF",
  // BG: "BGN",
  // BH: "BHD",
  // BI: "BIF",
  // BJ: "XOF",
  BL: "EUR",
  // BM: "BMD",
  // BN: "BND",
  // BO: "BOB",
  BQ: "USD",
  BR: "BRL",
  // BS: "BSD",
  // BT: "BTN",
  // BV: "NOK",
  // BW: "BWP",
  // BY: "BYN",
  // BZ: "BZD",
  CA: "CAD",
  // CC: "AUD",
  // CD: "CDF",
  // CF: "XAF",
  // CG: "XAF",
  // CH: "CHF",
  // CI: "XOF",
  // CK: "NZD",
  // CL: "CLP",
  // CM: "XAF",
  // CN: "CNY",
  CO: "COP",
  // CR: "CRC",
  // CU: "CUP",
  // CV: "CVE",
  // CW: "ANG",
  // CX: "AUD",
  CY: "EUR",
  // CZ: "CZK",
  DE: "EUR",
  // DJ: "DJF",
  // DK: "DKK",
  // DM: "XCD",
  // DO: "DOP",
  // DZ: "DZD",
  EC: "USD",
  EE: "EUR",
  // EG: "EGP",
  // EH: "MAD",
  // ER: "ERN",
  ES: "EUR",
  // ET: "ETB",
  FI: "EUR",
  // FJ: "FJD",
  // FK: "FKP",
  FM: "USD",
  // FO: "DKK",
  FR: "EUR",
  // GA: "XAF",
  GB: "GBP",
  // GD: "XCD",
  // GE: "GEL",
  GF: "EUR",
  GG: "GBP",
  // GH: "GHS",
  // GI: "GIP",
  // GL: "DKK",
  // GM: "GMD",
  // GN: "GNF",
  GP: "EUR",
  // GQ: "XAF",
  GR: "EUR",
  GS: "GBP",
  // GT: "GTQ",
  GU: "USD",
  // GW: "XOF",
  // GY: "GYD",
  // HK: "HKD",
  // HM: "AUD",
  // HN: "HNL",
  // HR: "HRK",
  // HT: "HTG",
  // HU: "HUF",
  // ID: "IDR",
  IE: "EUR",
  // IL: "ILS",
  IM: "GBP",
  IN: "INR",
  IO: "USD",
  // IQ: "IQD",
  // IR: "IRR",
  // IS: "ISK",
  IT: "EUR",
  JE: "GBP",
  // JM: "JMD",
  // JO: "JOD",
  // JP: "JPY",
  // KE: "KES",
  // KG: "KGS",
  // KH: "KHR",
  // KI: "AUD",
  // KM: "KMF",
  // KN: "XCD",
  // KP: "KPW",
  // KR: "KRW",
  // KW: "KWD",
  // KY: "KYD",
  // KZ: "KZT",
  // LA: "LAK",
  // LB: "LBP",
  // LC: "XCD",
  // LI: "CHF",
  // LK: "LKR",
  // LR: "LRD",
  // LS: "LSL",
  LT: "EUR",
  LU: "EUR",
  LV: "EUR",
  // LY: "LYD",
  // MA: "MAD",
  MC: "EUR",
  // MD: "MDL",
  ME: "EUR",
  MF: "EUR",
  // MG: "MGA",
  MH: "USD",
  // MK: "MKD",
  // ML: "XOF",
  // MM: "MMK",
  // MN: "MNT",
  // MO: "MOP",
  MP: "USD",
  MQ: "EUR",
  // MR: "MRO",
  // MS: "XCD",
  MT: "EUR",
  // MU: "MUR",
  // MV: "MVR",
  // MW: "MWK",
  MX: "MXN",
  // MY: "MYR",
  // MZ: "MZN",
  // NA: "NAD",
  // NC: "XPF",
  // NE: "XOF",
  NF: "AUD",
  // NG: "NGN",
  // NI: "NIO",
  NL: "EUR",
  // NO: "NOK",
  // NP: "NPR",
  NR: "AUD",
  // NU: "NZD",
  // NZ: "NZD",
  // OM: "OMR",
  // PA: "PAB",
  // PE: "PEN",
  // PF: "XPF",
  // PG: "PGK",
  // PH: "PHP",
  // PK: "PKR",
  // PL: "PLN",
  PM: "EUR",
  // PN: "NZD",
  PR: "USD",
  // PS: "ILS",
  PT: "EUR",
  PW: "USD",
  // PY: "PYG",
  // QA: "QAR",
  RE: "EUR",
  // RO: "RON",
  // RS: "RSD",
  // RU: "RUB",
  // RW: "RWF",
  // SA: "SAR",
  // SB: "SBD",
  // SC: "SCR",
  // SD: "SDG",
  // SE: "SEK",
  // SG: "SGD",
  // SH: "SHP",
  SI: "EUR",
  // SJ: "NOK",
  SK: "EUR",
  // SL: "SLL",
  SM: "EUR",
  // SN: "XOF",
  // SO: "SOS",
  // SR: "SRD",
  // ST: "STD",
  // SV: "SVC",
  // SX: "ANG",
  // SY: "SYP",
  // SZ: "SZL",
  TC: "USD",
  // TD: "XAF",
  TF: "EUR",
  // TG: "XOF",
  // TH: "THB",
  // TJ: "TJS",
  // TK: "NZD",
  TL: "USD",
  // TM: "TMT",
  // TN: "TND",
  // TO: "TOP",
  // TR: "TRY",
  // TT: "TTD",
  TV: "AUD",
  // TW: "TWD",
  // TZ: "TZS",
  // UA: "UAH",
  // UG: "UGX",
  UM: "USD",
  US: "USD",
  // UY: "UYU",
  // UZ: "UZS",
  VA: "EUR",
  // VC: "XCD",
  // VE: "VEF",
  VG: "USD",
  VI: "USD",
  // VN: "VND",
  // VU: "VUV",
  // WF: "XPF",
  // WS: "WST",
  // YE: "YER",
  YT: "EUR"
  // ZA: "ZAR",
  // ZM: "ZMW",
  // ZW: "ZWL",
};
function getCountryCode(localeString) {
  let components = localeString.split("_");
  if (components.length === 2) {
    return components.pop();
  }
  components = localeString.split("-");
  if (components.length === 2) {
    return components.pop();
  }
  return localeString;
}
function localeToCurrencyCode(locale) {
  const countryCode = getCountryCode(locale);
  return countryCodesToCurrencyCodes[countryCode];
}

// src/utils/numbers.ts
function clamp(val, min, max) {
  return val > max ? max : val < min ? min : val;
}
function linearInterpolate(value, fromRangeStart, fromRangeEnd, toRangeStart, toRangeEnd) {
  const fromRangeMax = fromRangeEnd - fromRangeStart;
  const fromRangeVal = value - fromRangeStart;
  const toRangeMax = toRangeEnd - toRangeStart;
  const val = fromRangeVal / fromRangeMax * toRangeMax + toRangeStart;
  return clamp(
    val,
    Math.min(toRangeStart, toRangeEnd),
    Math.max(toRangeStart, toRangeEnd)
  );
}
function round(num, decimalPlaces = 0) {
  const p = Math.pow(10, decimalPlaces);
  const n = num * p * (1 + Number.EPSILON);
  return Math.round(n) / p;
}
function isNumber(value) {
  return typeof value === "number";
}

// src/utils/currency.ts
var defaultCurrencyCode = "USD";
var CurrencyUnit = /* @__PURE__ */ ((CurrencyUnit2) => {
  CurrencyUnit2["FUTURE_VALUE"] = "FUTURE_VALUE";
  CurrencyUnit2["BITCOIN"] = "BITCOIN";
  CurrencyUnit2["SATOSHI"] = "SATOSHI";
  CurrencyUnit2["MILLISATOSHI"] = "MILLISATOSHI";
  CurrencyUnit2["USD"] = "USD";
  CurrencyUnit2["NANOBITCOIN"] = "NANOBITCOIN";
  CurrencyUnit2["MICROBITCOIN"] = "MICROBITCOIN";
  CurrencyUnit2["MILLIBITCOIN"] = "MILLIBITCOIN";
  return CurrencyUnit2;
})(CurrencyUnit || {});
var CONVERSION_MAP = {
  ["BITCOIN" /* BITCOIN */]: {
    ["BITCOIN" /* BITCOIN */]: (v) => v,
    ["MICROBITCOIN" /* MICROBITCOIN */]: (v) => v * 1e6,
    ["MILLIBITCOIN" /* MILLIBITCOIN */]: (v) => v * 1e3,
    ["MILLISATOSHI" /* MILLISATOSHI */]: (v) => v * 1e11,
    ["NANOBITCOIN" /* NANOBITCOIN */]: (v) => v * 1e9,
    ["SATOSHI" /* SATOSHI */]: (v) => v * 1e8,
    ["USD" /* USD */]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v * centsPerBtc, 2)
    )
  },
  ["MICROBITCOIN" /* MICROBITCOIN */]: {
    ["BITCOIN" /* BITCOIN */]: (v) => v / 1e6,
    ["MICROBITCOIN" /* MICROBITCOIN */]: (v) => v,
    ["MILLIBITCOIN" /* MILLIBITCOIN */]: (v) => v / 1e3,
    ["MILLISATOSHI" /* MILLISATOSHI */]: (v) => v * 1e5,
    ["NANOBITCOIN" /* NANOBITCOIN */]: (v) => v * 1e3,
    ["SATOSHI" /* SATOSHI */]: (v) => v * 100,
    ["USD" /* USD */]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e6 * centsPerBtc)
    )
  },
  ["MILLIBITCOIN" /* MILLIBITCOIN */]: {
    ["BITCOIN" /* BITCOIN */]: (v) => v / 1e3,
    ["MICROBITCOIN" /* MICROBITCOIN */]: (v) => v * 1e3,
    ["MILLIBITCOIN" /* MILLIBITCOIN */]: (v) => v,
    ["MILLISATOSHI" /* MILLISATOSHI */]: (v) => v * 1e8,
    ["NANOBITCOIN" /* NANOBITCOIN */]: (v) => v * 1e6,
    ["SATOSHI" /* SATOSHI */]: (v) => v * 1e5,
    ["USD" /* USD */]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e3 * centsPerBtc)
    )
  },
  ["MILLISATOSHI" /* MILLISATOSHI */]: {
    ["BITCOIN" /* BITCOIN */]: (v) => v / 1e11,
    ["MICROBITCOIN" /* MICROBITCOIN */]: (v) => v / 1e5,
    ["MILLIBITCOIN" /* MILLIBITCOIN */]: (v) => v / 1e8,
    ["MILLISATOSHI" /* MILLISATOSHI */]: (v) => v,
    ["NANOBITCOIN" /* NANOBITCOIN */]: (v) => v / 100,
    ["SATOSHI" /* SATOSHI */]: (v) => v / 1e3,
    ["USD" /* USD */]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e11 * centsPerBtc)
    )
  },
  ["NANOBITCOIN" /* NANOBITCOIN */]: {
    ["BITCOIN" /* BITCOIN */]: (v) => v / 1e9,
    ["MICROBITCOIN" /* MICROBITCOIN */]: (v) => v / 1e3,
    ["MILLIBITCOIN" /* MILLIBITCOIN */]: (v) => v / 1e6,
    ["MILLISATOSHI" /* MILLISATOSHI */]: (v) => v * 100,
    ["NANOBITCOIN" /* NANOBITCOIN */]: (v) => v,
    ["SATOSHI" /* SATOSHI */]: (v) => v / 10,
    ["USD" /* USD */]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e9 * centsPerBtc)
    )
  },
  ["SATOSHI" /* SATOSHI */]: {
    ["BITCOIN" /* BITCOIN */]: (v) => v / 1e8,
    ["MICROBITCOIN" /* MICROBITCOIN */]: (v) => v / 100,
    ["MILLIBITCOIN" /* MILLIBITCOIN */]: (v) => v / 1e5,
    ["MILLISATOSHI" /* MILLISATOSHI */]: (v) => v * 1e3,
    ["NANOBITCOIN" /* NANOBITCOIN */]: (v) => v * 10,
    ["SATOSHI" /* SATOSHI */]: (v) => v,
    ["USD" /* USD */]: (v, centsPerBtc = 1) => (
      /* Round without decimals since we're returning cents: */
      round(v / 1e8 * centsPerBtc)
    )
  },
  ["USD" /* USD */]: {
    ["BITCOIN" /* BITCOIN */]: (v, centsPerBtc = 1) => v / centsPerBtc,
    ["MICROBITCOIN" /* MICROBITCOIN */]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e6,
    ["MILLIBITCOIN" /* MILLIBITCOIN */]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e3,
    ["MILLISATOSHI" /* MILLISATOSHI */]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e11,
    ["NANOBITCOIN" /* NANOBITCOIN */]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e9,
    ["SATOSHI" /* SATOSHI */]: (v, centsPerBtc = 1) => v / centsPerBtc * 1e8,
    ["USD" /* USD */]: (v) => v
  }
};
function convertCurrencyAmountValue(fromUnit, toUnit, amount, centsPerBtc = 1) {
  if (fromUnit === "FUTURE_VALUE" /* FUTURE_VALUE */ || toUnit === "FUTURE_VALUE" /* FUTURE_VALUE */) {
    throw new LightsparkException_default("CurrencyError", `Unsupported CurrencyUnit.`);
  }
  if (fromUnit === toUnit) {
    return amount;
  }
  const conversionFn = CONVERSION_MAP[fromUnit][toUnit];
  if (!conversionFn) {
    throw new LightsparkException_default(
      "CurrencyError",
      `Cannot convert from ${fromUnit} to ${toUnit}`
    );
  }
  return conversionFn(amount, centsPerBtc);
}
var convertCurrencyAmount = (from, toUnit) => {
  const value = convertCurrencyAmountValue(
    from.originalUnit,
    toUnit,
    from.originalValue
  );
  return {
    ...from,
    preferredCurrencyUnit: toUnit,
    preferredCurrencyValueApprox: value,
    preferredCurrencyValueRounded: value
  };
};
function isCurrencyAmountObj(arg) {
  return typeof arg === "object" && arg !== null && "value" in arg && "unit" in arg;
}
function isCurrencyAmount(arg) {
  return typeof arg === "object" && arg !== null && "originalValue" in arg && "originalUnit" in arg && "preferredCurrencyUnit" in arg && "preferredCurrencyValueRounded" in arg && "preferredCurrencyValueApprox" in arg;
}
function asNumber(value) {
  if (typeof value === "string") {
    return Number(value);
  }
  return value || 0;
}
function getCurrencyAmount(currencyAmountArg) {
  let value = 0;
  let unit = void 0;
  if (isCurrencyAmountObj(currencyAmountArg)) {
    value = asNumber(currencyAmountArg.value);
    unit = currencyAmountArg.unit;
  } else if (isCurrencyAmount(currencyAmountArg)) {
    value = currencyAmountArg.originalValue;
    unit = currencyAmountArg.originalUnit;
  }
  return {
    value: asNumber(value),
    unit: unit || "SATOSHI" /* SATOSHI */
  };
}
function mapCurrencyAmount(currencyAmountArg, centsPerBtc = 1) {
  const { value, unit } = getCurrencyAmount(currencyAmountArg);
  const convert = convertCurrencyAmountValue;
  const sats = convert(unit, "SATOSHI" /* SATOSHI */, value, centsPerBtc);
  const btc = convert(unit, "BITCOIN" /* BITCOIN */, value, centsPerBtc);
  const msats = convert(unit, "MILLISATOSHI" /* MILLISATOSHI */, value, centsPerBtc);
  const usd = convert(unit, "USD" /* USD */, value, centsPerBtc);
  const mibtc = convert(unit, "MICROBITCOIN" /* MICROBITCOIN */, value, centsPerBtc);
  const mlbtc = convert(unit, "MILLIBITCOIN" /* MILLIBITCOIN */, value, centsPerBtc);
  const nbtc = convert(unit, "NANOBITCOIN" /* NANOBITCOIN */, value, centsPerBtc);
  const mapWithCurrencyUnits = {
    ["BITCOIN" /* BITCOIN */]: btc,
    ["SATOSHI" /* SATOSHI */]: sats,
    ["MILLISATOSHI" /* MILLISATOSHI */]: msats,
    ["USD" /* USD */]: usd,
    ["MICROBITCOIN" /* MICROBITCOIN */]: mibtc,
    ["MILLIBITCOIN" /* MILLIBITCOIN */]: mlbtc,
    ["NANOBITCOIN" /* NANOBITCOIN */]: nbtc,
    ["FUTURE_VALUE" /* FUTURE_VALUE */]: NaN,
    formatted: {
      ["BITCOIN" /* BITCOIN */]: formatCurrencyStr({
        value: btc,
        unit: "BITCOIN" /* BITCOIN */
      }),
      ["SATOSHI" /* SATOSHI */]: formatCurrencyStr({
        value: sats,
        unit: "SATOSHI" /* SATOSHI */
      }),
      ["MILLISATOSHI" /* MILLISATOSHI */]: formatCurrencyStr({
        value: msats,
        unit: "MILLISATOSHI" /* MILLISATOSHI */
      }),
      ["MICROBITCOIN" /* MICROBITCOIN */]: formatCurrencyStr({
        value: mibtc,
        unit: "MICROBITCOIN" /* MICROBITCOIN */
      }),
      ["MILLIBITCOIN" /* MILLIBITCOIN */]: formatCurrencyStr({
        value: mlbtc,
        unit: "MILLIBITCOIN" /* MILLIBITCOIN */
      }),
      ["NANOBITCOIN" /* NANOBITCOIN */]: formatCurrencyStr({
        value: nbtc,
        unit: "NANOBITCOIN" /* NANOBITCOIN */
      }),
      ["USD" /* USD */]: formatCurrencyStr({
        value: usd,
        unit: "USD" /* USD */
      }),
      ["FUTURE_VALUE" /* FUTURE_VALUE */]: "-"
    }
  };
  return {
    ...mapWithCurrencyUnits,
    btc,
    sats,
    msats,
    isZero: msats === 0,
    isLessThan: (other) => {
      if (isNumber(other)) {
        return msats < other;
      }
      if (isCurrencyAmountObj(other)) {
        other = mapCurrencyAmount(other);
      }
      return msats < other.msats;
    },
    isGreaterThan: (other) => {
      if (isNumber(other)) {
        return msats > other;
      }
      if (isCurrencyAmountObj(other)) {
        other = mapCurrencyAmount(other);
      }
      return msats > other.msats;
    },
    isEqualTo: (other) => {
      if (isNumber(other)) {
        return msats === other;
      }
      if (isCurrencyAmountObj(other)) {
        other = mapCurrencyAmount(other);
      }
      return msats === other.msats;
    },
    formatted: {
      ...mapWithCurrencyUnits.formatted,
      btc: mapWithCurrencyUnits.formatted["BITCOIN" /* BITCOIN */],
      sats: mapWithCurrencyUnits.formatted["SATOSHI" /* SATOSHI */],
      msats: mapWithCurrencyUnits.formatted["MILLISATOSHI" /* MILLISATOSHI */]
    },
    type: "CurrencyMap"
  };
}
var isCurrencyMap = (currencyMap) => typeof currencyMap === "object" && currencyMap !== null && "type" in currencyMap && typeof currencyMap.type === "string" && currencyMap.type === "CurrencyMap";
var abbrCurrencyUnit = (unit) => {
  switch (unit) {
    case "BITCOIN" /* BITCOIN */:
      return "BTC";
    case "SATOSHI" /* SATOSHI */:
      return "SAT";
    case "MILLISATOSHI" /* MILLISATOSHI */:
      return "MSAT";
    case "USD" /* USD */:
      return "USD";
  }
  return "Unsupported CurrencyUnit";
};
function formatCurrencyStr(amount, maxFractionDigits, compact, showBtcSymbol = false, options = {}) {
  const currencyAmount = getCurrencyAmount(amount);
  let { value: num } = currencyAmount;
  const { unit } = currencyAmount;
  if (unit === "USD" /* USD */) {
    num = num / 100;
  }
  function getDefaultMaxFractionDigits(defaultDigits) {
    return typeof maxFractionDigits === "undefined" ? compact ? 1 : defaultDigits : maxFractionDigits;
  }
  const symbol = !showBtcSymbol ? "" : unit === "BITCOIN" /* BITCOIN */ ? "\uE903" : unit === "SATOSHI" /* SATOSHI */ ? "\uE902" : "";
  const currentLocale = getCurrentLocale();
  switch (unit) {
    case "BITCOIN" /* BITCOIN */:
      return `${symbol}${num.toLocaleString(currentLocale, {
        notation: compact ? "compact" : void 0,
        maximumFractionDigits: getDefaultMaxFractionDigits(4),
        ...options
      })}`;
    case "MILLISATOSHI" /* MILLISATOSHI */:
    case "SATOSHI" /* SATOSHI */:
    case "MICROBITCOIN" /* MICROBITCOIN */:
    case "MILLIBITCOIN" /* MILLIBITCOIN */:
    case "NANOBITCOIN" /* NANOBITCOIN */:
    default:
      return `${symbol}${num.toLocaleString(currentLocale, {
        notation: compact ? "compact" : void 0,
        maximumFractionDigits: getDefaultMaxFractionDigits(0),
        ...options
      })}`;
    case "USD" /* USD */:
      return num.toLocaleString(currentLocale, {
        style: "currency",
        currency: defaultCurrencyCode,
        notation: compact ? "compact" : void 0,
        maximumFractionDigits: getDefaultMaxFractionDigits(2),
        ...options
      });
  }
}
function separateCurrencyStrParts(currencyStr) {
  const symbol = currencyStr.replace(/[0-9\s\u00a0.,]/g, "");
  const amount = currencyStr.replace(/[^\d.,-]/g, "");
  return { symbol, amount };
}
function localeToCurrencySymbol(locale) {
  const currencyCode = localeToCurrencyCode(locale);
  const formatted = new Intl.NumberFormat(locale, {
    style: "currency",
    currency: currencyCode,
    useGrouping: false,
    // to avoid thousands separators
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(0);
  const { symbol } = separateCurrencyStrParts(formatted);
  return symbol;
}

// src/utils/errors.ts
var isError = (e) => {
  return Boolean(
    typeof e === "object" && e !== null && "name" in e && typeof e.name === "string" && "message" in e && typeof e.message === "string" && "stack" in e && (!e.stack || typeof e.stack === "string")
  );
};
var isErrorWithMessage = (e) => {
  return Boolean(
    typeof e === "object" && e !== null && "message" in e && typeof e.message === "string"
  );
};
var getErrorMsg = (e) => {
  return isErrorWithMessage(e) ? e.message : "Unknown error";
};
var isErrorMsg = (e, msg) => {
  if (isError(e)) {
    return e.message === msg;
  }
  return false;
};
function errorToJSON(err) {
  if (typeof err === "object" && err !== null && "toJSON" in err && typeof err.toJSON === "function") {
    return err.toJSON();
  }
  return JSON.parse(
    JSON.stringify(err, Object.getOwnPropertyNames(err))
  );
}

// ../../node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../../node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../../node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../../node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../../node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../../node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../../node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// ../../node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// src/utils/sleep.ts
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// src/utils/pollUntil.ts
function getDefaultMaxPollsError() {
  return new Error("pollUntil: Max polls reached");
}
async function pollUntil(asyncFn, getValue, maxPolls = 60, pollIntervalMs = 500, ignoreErrors = false, getMaxPollsError = getDefaultMaxPollsError) {
  let polls = 0;
  let stopPolling = false;
  let result = {
    stopPolling: false,
    value: null
  };
  while (!stopPolling) {
    polls += 1;
    if (polls > maxPolls) {
      stopPolling = true;
      const maxPollsError = getMaxPollsError(maxPolls);
      throw maxPollsError;
    }
    try {
      const asyncResult = await asyncFn();
      result = getValue(asyncResult, {
        stopPolling: false,
        value: null
      });
      if (result.stopPolling) {
        stopPolling = true;
      }
    } catch (e) {
      if (!ignoreErrors || isFunction_default(ignoreErrors) && !ignoreErrors(e)) {
        stopPolling = true;
        throw e;
      }
    }
    await sleep(pollIntervalMs);
  }
  return result.value;
}

// src/utils/types.ts
var isType = (typename) => (node) => {
  return node?.__typename === typename;
};

// src/crypto/SigningKey.ts
function isAlias(key) {
  return "alias" in key;
}
var SigningKey = class {
  type;
  constructor(type) {
    this.type = type;
  }
};
var RSASigningKey = class extends SigningKey {
  constructor(privateKey, cryptoImpl) {
    super("RSASigningKey" /* RSASigningKey */);
    this.privateKey = privateKey;
    this.cryptoImpl = cryptoImpl;
  }
  async sign(data) {
    const key = isAlias(this.privateKey) ? this.privateKey.alias : this.privateKey;
    return this.cryptoImpl.sign(key, data);
  }
};
var Secp256k1SigningKey = class extends SigningKey {
  constructor(privateKey) {
    super("Secp256k1SigningKey" /* Secp256k1SigningKey */);
    this.privateKey = privateKey;
  }
  async sign(data) {
    const keyBytes = new Uint8Array(hexToBytes(this.privateKey));
    const hash = await createSha256Hash(data);
    const signResult = import_secp256k1.default.ecdsaSign(hash, keyBytes);
    return signResult.signature;
  }
};

// src/crypto/types.ts
var SigningKeyType = /* @__PURE__ */ ((SigningKeyType2) => {
  SigningKeyType2["RSASigningKey"] = "RSASigningKey";
  SigningKeyType2["Secp256k1SigningKey"] = "Secp256k1SigningKey";
  return SigningKeyType2;
})(SigningKeyType || {});

// src/crypto/NodeKeyCache.ts
var NodeKeyCache = class {
  constructor(cryptoImpl = DefaultCrypto) {
    this.cryptoImpl = cryptoImpl;
    this.idToKey = /* @__PURE__ */ new Map();
    (0, import_auto_bind.default)(this);
  }
  idToKey;
  async loadKey(id, keyOrAlias, signingKeyType) {
    let signingKey;
    if (keyOrAlias.alias !== void 0) {
      switch (signingKeyType) {
        case "RSASigningKey" /* RSASigningKey */:
          signingKey = new RSASigningKey(
            { alias: keyOrAlias.alias },
            this.cryptoImpl
          );
          break;
        default:
          throw new LightsparkSigningException_default(
            `Aliases are not supported for signing key type ${signingKeyType}`
          );
      }
      this.idToKey.set(id, signingKey);
      return signingKey;
    }
    try {
      if (signingKeyType === "Secp256k1SigningKey" /* Secp256k1SigningKey */) {
        signingKey = new Secp256k1SigningKey(keyOrAlias.key);
      } else {
        const decoded = b64decode(this.stripPemTags(keyOrAlias.key));
        const cryptoKeyOrAlias = await this.cryptoImpl.importPrivateSigningKey(decoded);
        const key = typeof cryptoKeyOrAlias === "string" ? { alias: cryptoKeyOrAlias } : cryptoKeyOrAlias;
        signingKey = new RSASigningKey(key, this.cryptoImpl);
      }
      this.idToKey.set(id, signingKey);
      return signingKey;
    } catch (e) {
      console.log("Error importing key: ", e);
    }
    return null;
  }
  getKey(id) {
    return this.idToKey.get(id);
  }
  hasKey(id) {
    return this.idToKey.has(id);
  }
  stripPemTags(pem) {
    return pem.replace(/-----BEGIN (.*)-----/, "").replace(/-----END (.*)----/, "");
  }
};
var NodeKeyCache_default = NodeKeyCache;

// src/requester/Requester.ts
var import_auto_bind2 = __toESM(require("auto-bind"), 1);
var import_dayjs = __toESM(require("dayjs"), 1);
var import_utc = __toESM(require("dayjs/plugin/utc.js"), 1);
var import_graphql_ws = require("graphql-ws");
var import_ws = __toESM(require("ws"), 1);
var import_zen_observable_ts = require("zen-observable-ts");
var DEFAULT_BASE_URL = "api.lightspark.com";
var LIGHTSPARK_BETA_HEADER_KEY = "X-Lightspark-Beta";
var LIGHTSPARK_BETA_HEADER_VALUE = "z2h0BBYxTA83cjW7fi8QwWtBPCzkQKiemcuhKY08LOo";
import_dayjs.default.extend(import_utc.default);
var Requester = class {
  constructor(nodeKeyCache, schemaEndpoint, sdkUserAgent, authProvider = new StubAuthProvider(), baseUrl = DEFAULT_BASE_URL, cryptoImpl = DefaultCrypto) {
    this.nodeKeyCache = nodeKeyCache;
    this.schemaEndpoint = schemaEndpoint;
    this.sdkUserAgent = sdkUserAgent;
    this.authProvider = authProvider;
    this.baseUrl = baseUrl;
    this.cryptoImpl = cryptoImpl;
    let websocketImpl;
    if (typeof WebSocket === "undefined" && typeof window === "undefined") {
      websocketImpl = import_ws.default;
    }
    let websocketProtocol = "wss";
    if (baseUrl.startsWith("http://")) {
      websocketProtocol = "ws";
    }
    this.wsClient = (0, import_graphql_ws.createClient)({
      url: `${websocketProtocol}://${this.stripProtocol(this.baseUrl)}/${this.schemaEndpoint}`,
      connectionParams: () => authProvider.addWsConnectionParams({}),
      webSocketImpl: websocketImpl
    });
    (0, import_auto_bind2.default)(this);
  }
  wsClient;
  async executeQuery(query) {
    const data = await this.makeRawRequest(
      query.queryPayload,
      query.variables || {},
      query.signingNodeId,
      !!query.skipAuth
    );
    return query.constructObject(data);
  }
  subscribe(queryPayload, variables = {}) {
    logger.info(`Requester.subscribe variables`, variables);
    const operationNameRegex = /^\s*(query|mutation|subscription)\s+(\w+)/i;
    const operationMatch = queryPayload.match(operationNameRegex);
    if (!operationMatch || operationMatch.length < 3) {
      throw new LightsparkException_default("InvalidQuery", "Invalid query payload");
    }
    const operationType = operationMatch[1];
    logger.info(`Requester.subscribe operationType`, operationType);
    if (operationType == "mutation") {
      throw new LightsparkException_default(
        "InvalidQuery",
        "Mutation queries should call makeRawRequest instead"
      );
    }
    for (const key in variables) {
      if (variables[key] === void 0) {
        variables[key] = null;
      }
    }
    const operation = operationMatch[2];
    const bodyData = {
      query: queryPayload,
      variables,
      operationName: operation
    };
    return new import_zen_observable_ts.Observable((observer) => {
      logger.info(`Requester.subscribe observer`, observer);
      return this.wsClient.subscribe(bodyData, {
        next: (data) => observer.next(data),
        error: (err) => observer.error(err),
        complete: () => observer.complete()
      });
    });
  }
  async makeRawRequest(queryPayload, variables = {}, signingNodeId = void 0, skipAuth = false) {
    const operationNameRegex = /^\s*(query|mutation|subscription)\s+(\w+)/i;
    const operationMatch = queryPayload.match(operationNameRegex);
    if (!operationMatch || operationMatch.length < 3) {
      throw new LightsparkException_default("InvalidQuery", "Invalid query payload");
    }
    const operationType = operationMatch[1];
    if (operationType == "subscription") {
      throw new LightsparkException_default(
        "InvalidQuery",
        "Subscription queries should call subscribe instead"
      );
    }
    for (const key in variables) {
      if (variables[key] === void 0) {
        variables[key] = null;
      }
    }
    const operation = operationMatch[2];
    let bodyData = {
      query: queryPayload,
      variables,
      operationName: operation
    };
    const browserUserAgent = typeof navigator !== "undefined" ? navigator.userAgent : "";
    const sdkUserAgent = this.getSdkUserAgent();
    const baseHeaders = {
      "Content-Type": "application/json",
      [LIGHTSPARK_BETA_HEADER_KEY]: LIGHTSPARK_BETA_HEADER_VALUE,
      "X-Lightspark-SDK": sdkUserAgent,
      "User-Agent": browserUserAgent || sdkUserAgent
    };
    const headers = skipAuth ? baseHeaders : await this.authProvider.addAuthHeaders(baseHeaders);
    bodyData = await this.addSigningDataIfNeeded(
      bodyData,
      headers,
      signingNodeId
    );
    let urlWithProtocol = this.baseUrl;
    if (!urlWithProtocol.startsWith("https://") && !urlWithProtocol.startsWith("http://")) {
      urlWithProtocol = `https://${urlWithProtocol}`;
    }
    const url = `${urlWithProtocol}/${this.schemaEndpoint}`;
    logger.info(`Requester.makeRawRequest`, {
      url,
      operationName: operation,
      variables
    });
    const response = await fetch(url, {
      method: "POST",
      headers,
      body: JSON.stringify(bodyData)
    });
    if (!response.ok) {
      throw new LightsparkException_default(
        "RequestFailed",
        `Request ${operation} failed. ${response.statusText}`
      );
    }
    const responseJson = await response.json();
    const data = responseJson.data;
    if (!data) {
      throw new LightsparkException_default(
        "RequestFailed",
        `Request ${operation} failed. ${JSON.stringify(responseJson.errors)}`
      );
    }
    return data;
  }
  getSdkUserAgent() {
    const platform = isNode ? "NodeJS" : "Browser";
    const platformVersion = isNode ? process.version : "";
    return `${this.sdkUserAgent} ${platform}/${platformVersion}`;
  }
  stripProtocol(url) {
    return url.replace(/.*?:\/\//g, "");
  }
  async addSigningDataIfNeeded(queryPayload, headers, signingNodeId) {
    if (!signingNodeId) {
      return queryPayload;
    }
    const query = queryPayload.query;
    const variables = queryPayload.variables;
    const operationName = queryPayload.operationName;
    const nonce = await this.cryptoImpl.getNonce();
    const expiration = import_dayjs.default.utc().add(1, "hour").format();
    const payload = {
      query,
      variables,
      operationName,
      nonce,
      expires_at: expiration
    };
    const key = this.nodeKeyCache.getKey(signingNodeId);
    if (!key) {
      throw new LightsparkSigningException_default(
        "Missing node of encrypted_signing_private_key"
      );
    }
    let TextEncoderImpl = TextEncoder;
    if (typeof TextEncoder === "undefined") {
      TextEncoderImpl = (await import("text-encoding")).TextEncoder;
    }
    const encodedPayload = new TextEncoderImpl().encode(
      JSON.stringify(payload)
    );
    const signedPayload = await key.sign(encodedPayload);
    const encodedSignedPayload = b64encode(signedPayload);
    headers["X-Lightspark-Signing"] = JSON.stringify({
      v: "1",
      signature: encodedSignedPayload
    });
    return payload;
  }
};
var Requester_default = Requester;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ConfigKeys,
  CurrencyUnit,
  DefaultCrypto,
  KeyOrAlias,
  LightsparkAuthException,
  LightsparkException,
  LightsparkSigningException,
  Logger,
  NodeKeyCache,
  RSASigningKey,
  Requester,
  Secp256k1SigningKey,
  ServerEnvironment,
  SigningKey,
  SigningKeyType,
  StubAuthProvider,
  abbrCurrencyUnit,
  apiDomainForEnvironment,
  b64decode,
  b64encode,
  bytesToHex,
  clamp,
  convertCurrencyAmount,
  convertCurrencyAmountValue,
  countryCodesToCurrencyCodes,
  createSha256Hash,
  defaultCurrencyCode,
  errorToJSON,
  formatCurrencyStr,
  getCurrentLocale,
  getErrorMsg,
  getLocalStorageBoolean,
  getLocalStorageConfigItem,
  hexToBytes,
  isBrowser,
  isCurrencyAmount,
  isCurrencyAmountObj,
  isCurrencyMap,
  isError,
  isErrorMsg,
  isErrorWithMessage,
  isNode,
  isNumber,
  isTest,
  isType,
  linearInterpolate,
  localeToCurrencyCode,
  localeToCurrencySymbol,
  mapCurrencyAmount,
  pollUntil,
  round,
  separateCurrencyStrParts,
  sleep,
  urlsafe_b64decode
});
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
