import { Observable } from 'zen-observable-ts';
export { ById, CurrencyAmountArg, CurrencyAmountObj, CurrencyAmountType, CurrencyCodes, CurrencyLocales, CurrencyMap, CurrencyUnit, DeepPartial, ExpandRecursively, JSONLiteral, JSONObject, JSONType, Maybe, OmitTypename, abbrCurrencyUnit, b64decode, b64encode, bytesToHex, clamp, convertCurrencyAmount, convertCurrencyAmountValue, countryCodesToCurrencyCodes, createSha256Hash, defaultCurrencyCode, errorToJSON, formatCurrencyStr, getCurrentLocale, getErrorMsg, hexToBytes, isBrowser, isCurrencyAmount, isCurrencyAmountObj, isCurrencyMap, isError, isErrorMsg, isErrorWithMessage, isNode, isNumber, isTest, isType, linearInterpolate, localeToCurrencyCode, localeToCurrencySymbol, mapCurrencyAmount, pollUntil, round, separateCurrencyStrParts, sleep, urlsafe_b64decode } from './utils/index.cjs';

declare class LightsparkException extends Error {
    code: string;
    message: string;
    extraInfo: Record<string, unknown> | undefined;
    constructor(code: string, message: string, extraInfo?: Record<string, unknown>);
}

type GetLoggingEnabled = (() => Promise<boolean> | boolean) | undefined;
declare class Logger {
    context: string;
    loggingEnabled: boolean;
    constructor(loggerContext: string, getLoggingEnabled?: GetLoggingEnabled);
    updateLoggingEnabled(getLoggingEnabled: GetLoggingEnabled): Promise<void>;
    info(message: string, ...rest: unknown[]): void;
}

declare enum ServerEnvironment {
    PRODUCTION = "production",
    DEV = "dev"
}
declare const apiDomainForEnvironment: (environment: ServerEnvironment) => string;

type Headers = Record<string, string>;
type WsConnectionParams = Record<string, unknown>;
interface AuthProvider {
    addAuthHeaders(headers: Headers): Promise<Headers>;
    isAuthorized(): Promise<boolean>;
    addWsConnectionParams(params: WsConnectionParams): Promise<WsConnectionParams>;
}

declare class LightsparkAuthException extends LightsparkException {
    constructor(message: string, extraInfo?: Record<string, unknown>);
}

declare class StubAuthProvider implements AuthProvider {
    addAuthHeaders(headers: Headers): Promise<Headers>;
    isAuthorized(): Promise<boolean>;
    addWsConnectionParams(params: WsConnectionParams): Promise<WsConnectionParams>;
}

declare const ConfigKeys: {
    readonly LoggingEnabled: "lightspark-logging-enabled";
    readonly ConsoleToolsEnabled: "lightspark-console-tools-enabled";
};
type ConfigKeys = (typeof ConfigKeys)[keyof typeof ConfigKeys];
declare const getLocalStorageConfigItem: (key: ConfigKeys) => boolean;
declare const getLocalStorageBoolean: (key: string) => boolean;

type OnlyKey = {
    key: string;
    alias?: never;
};
type OnlyAlias = {
    key?: never;
    alias: string;
};
type KeyOrAliasType = OnlyKey | OnlyAlias;
declare const KeyOrAlias: {
    key: (key: string) => OnlyKey;
    alias: (alias: string) => OnlyAlias;
};

declare class LightsparkSigningException extends LightsparkException {
    constructor(message: string, extraInfo?: Record<string, unknown>);
}

type GeneratedKeyPair = {
    publicKey: CryptoKey | string;
    privateKey: CryptoKey | string;
    keyAlias?: string;
};
type CryptoInterface = {
    decryptSecretWithNodePassword: (cipher: string, encryptedSecret: string, nodePassword: string) => Promise<ArrayBuffer | null>;
    generateSigningKeyPair: () => Promise<GeneratedKeyPair>;
    serializeSigningKey: (key: CryptoKey | string, format: "pkcs8" | "spki") => Promise<ArrayBuffer>;
    getNonce: () => Promise<number>;
    sign: (keyOrAlias: CryptoKey | string, data: Uint8Array) => Promise<ArrayBuffer>;
    importPrivateSigningKey: (keyData: Uint8Array) => Promise<CryptoKey | string>;
};
declare function decryptSecretWithNodePassword(cipher: string, encryptedSecret: string, nodePassword: string): Promise<ArrayBuffer | null>;
declare const DefaultCrypto: {
    decryptSecretWithNodePassword: typeof decryptSecretWithNodePassword;
    generateSigningKeyPair: () => Promise<GeneratedKeyPair>;
    serializeSigningKey: (key: CryptoKey | string, format: "pkcs8" | "spki") => Promise<ArrayBuffer>;
    getNonce: () => Promise<number>;
    sign: (keyOrAlias: CryptoKey | string, data: Uint8Array) => Promise<ArrayBuffer>;
    importPrivateSigningKey: (keyData: Uint8Array) => Promise<CryptoKey | string>;
};

interface Alias {
    alias: string;
}
declare abstract class SigningKey {
    readonly type: SigningKeyType;
    constructor(type: SigningKeyType);
    abstract sign(data: Uint8Array): Promise<ArrayBuffer>;
}
declare class RSASigningKey extends SigningKey {
    private readonly privateKey;
    private readonly cryptoImpl;
    constructor(privateKey: CryptoKey | Alias, cryptoImpl: CryptoInterface);
    sign(data: Uint8Array): Promise<ArrayBuffer>;
}
declare class Secp256k1SigningKey extends SigningKey {
    private readonly privateKey;
    constructor(privateKey: string);
    sign(data: Uint8Array): Promise<Uint8Array>;
}

declare enum SigningKeyType {
    RSASigningKey = "RSASigningKey",
    Secp256k1SigningKey = "Secp256k1SigningKey"
}

declare class NodeKeyCache {
    private readonly cryptoImpl;
    private idToKey;
    constructor(cryptoImpl?: CryptoInterface);
    loadKey(id: string, keyOrAlias: KeyOrAliasType, signingKeyType: SigningKeyType): Promise<SigningKey | null>;
    getKey(id: string): SigningKey | undefined;
    hasKey(id: string): boolean;
    private stripPemTags;
}

type Query<T> = {
    /** The string representation of the query payload for graphQL. **/
    queryPayload: string;
    /** The variables that will be passed to the query. **/
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The function that will be called to construct the object from the
     * response. *
     */
    constructObject: (rawData: any) => T;
    /** The id of the node that will be used to sign the query. **/
    signingNodeId?: string;
    /** True if auth headers should be omitted for this query. **/
    skipAuth?: boolean;
};

declare class Requester {
    private readonly nodeKeyCache;
    private readonly schemaEndpoint;
    private readonly sdkUserAgent;
    private readonly authProvider;
    private readonly baseUrl;
    private readonly cryptoImpl;
    private readonly wsClient;
    constructor(nodeKeyCache: NodeKeyCache, schemaEndpoint: string, sdkUserAgent: string, authProvider?: AuthProvider, baseUrl?: string, cryptoImpl?: CryptoInterface);
    executeQuery<T>(query: Query<T>): Promise<T | null>;
    subscribe<T>(queryPayload: string, variables?: {
        [key: string]: unknown;
    }): Observable<{
        data: T;
    }>;
    makeRawRequest(queryPayload: string, variables?: {
        [key: string]: unknown;
    }, signingNodeId?: string | undefined, skipAuth?: boolean): Promise<any>;
    private getSdkUserAgent;
    private stripProtocol;
    private addSigningDataIfNeeded;
}

export { AuthProvider, ConfigKeys, CryptoInterface, DefaultCrypto, GeneratedKeyPair, KeyOrAlias, KeyOrAliasType, LightsparkAuthException, LightsparkException, LightsparkSigningException, Logger, NodeKeyCache, Query, RSASigningKey, Requester, Secp256k1SigningKey, ServerEnvironment, SigningKey, SigningKeyType, StubAuthProvider, apiDomainForEnvironment, getLocalStorageBoolean, getLocalStorageConfigItem };
