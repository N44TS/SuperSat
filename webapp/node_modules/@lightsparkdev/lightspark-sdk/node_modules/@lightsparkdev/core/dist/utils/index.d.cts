declare const b64decode: (encoded: string) => Uint8Array;
declare const urlsafe_b64decode: (encoded: string) => Uint8Array;
declare const b64encode: (data: ArrayBuffer) => string;

type SourceData = Uint8Array | string;
declare function createSha256Hash(data: SourceData): Promise<Uint8Array>;
declare function createSha256Hash(data: SourceData, asHex: true): Promise<string>;

declare const defaultCurrencyCode = "USD";
/**
 * This enum identifies the unit of currency associated with a CurrencyAmount.
 * *
 */
declare enum CurrencyUnit {
    /**
     * This is an enum value that represents values that could be added in the
     * future. Clients should support unknown values as more of them could be
     * added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /**
     * Bitcoin is the cryptocurrency native to the Bitcoin network.
     * It is used as the native medium for value transfer for the Lightning
     * Network. *
     */
    BITCOIN = "BITCOIN",
    /**
     * 0.00000001 (10e-8) Bitcoin or one hundred millionth of a Bitcoin.
     * This is the unit most commonly used in Lightning transactions.
     * *
     */
    SATOSHI = "SATOSHI",
    /**
     * 0.001 Satoshi, or 10e-11 Bitcoin. We recommend using the Satoshi unit
     * instead when possible. *
     */
    MILLISATOSHI = "MILLISATOSHI",
    /** United States Dollar. **/
    USD = "USD",
    /**
     * 0.000000001 (10e-9) Bitcoin or a billionth of a Bitcoin.
     * We recommend using the Satoshi unit instead when possible.
     * *
     */
    NANOBITCOIN = "NANOBITCOIN",
    /**
     * 0.000001 (10e-6) Bitcoin or a millionth of a Bitcoin.
     * We recommend using the Satoshi unit instead when possible.
     * *
     */
    MICROBITCOIN = "MICROBITCOIN",
    /**
     * 0.001 (10e-3) Bitcoin or a thousandth of a Bitcoin.
     * We recommend using the Satoshi unit instead when possible.
     * *
     */
    MILLIBITCOIN = "MILLIBITCOIN"
}
/** This object represents the value and unit for an amount of currency. **/
type CurrencyAmountType = {
    /** The original numeric value for this CurrencyAmount. **/
    originalValue: number;
    /** The original unit of currency for this CurrencyAmount. **/
    originalUnit: CurrencyUnit;
    /** The unit of user's preferred currency. **/
    preferredCurrencyUnit: CurrencyUnit;
    /**
     * The rounded numeric value for this CurrencyAmount in the very base level
     * of user's preferred currency. For example, for USD, the value will be in
     * cents.
     **/
    preferredCurrencyValueRounded: number;
    /**
     * The approximate float value for this CurrencyAmount in the very base level
     * of user's preferred currency. For example, for USD, the value will be in
     * cents.
     **/
    preferredCurrencyValueApprox: number;
};
declare function convertCurrencyAmountValue(fromUnit: CurrencyUnit, toUnit: CurrencyUnit, amount: number, centsPerBtc?: number): number;
declare const convertCurrencyAmount: (from: CurrencyAmountType, toUnit: CurrencyUnit) => CurrencyAmountType;
type CurrencyMap = {
    sats: number;
    msats: number;
    btc: number;
    [CurrencyUnit.BITCOIN]: number;
    [CurrencyUnit.SATOSHI]: number;
    [CurrencyUnit.MILLISATOSHI]: number;
    [CurrencyUnit.MICROBITCOIN]: number;
    [CurrencyUnit.MILLIBITCOIN]: number;
    [CurrencyUnit.NANOBITCOIN]: number;
    [CurrencyUnit.USD]: number;
    [CurrencyUnit.FUTURE_VALUE]: number;
    formatted: {
        sats: string;
        msats: string;
        btc: string;
        [CurrencyUnit.BITCOIN]: string;
        [CurrencyUnit.SATOSHI]: string;
        [CurrencyUnit.MILLISATOSHI]: string;
        [CurrencyUnit.MILLIBITCOIN]: string;
        [CurrencyUnit.MICROBITCOIN]: string;
        [CurrencyUnit.NANOBITCOIN]: string;
        [CurrencyUnit.USD]: string;
        [CurrencyUnit.FUTURE_VALUE]: string;
    };
    isZero: boolean;
    isLessThan: (other: CurrencyMap | CurrencyAmountObj | number) => boolean;
    isGreaterThan: (other: CurrencyMap | CurrencyAmountObj | number) => boolean;
    isEqualTo: (other: CurrencyMap | CurrencyAmountObj | number) => boolean;
    type: "CurrencyMap";
};
type CurrencyAmountObj = {
    value?: number | string | null;
    unit?: CurrencyUnit;
    __typename?: "CurrencyAmount";
};
type CurrencyAmountArg = CurrencyAmountObj | CurrencyAmountType | undefined | null;
declare function isCurrencyAmountObj(arg: unknown): arg is CurrencyAmountObj;
declare function isCurrencyAmount(arg: unknown): arg is CurrencyAmountType;
declare function mapCurrencyAmount(currencyAmountArg: CurrencyAmountArg, centsPerBtc?: number): CurrencyMap;
declare const isCurrencyMap: (currencyMap: unknown) => currencyMap is CurrencyMap;
declare const abbrCurrencyUnit: (unit: CurrencyUnit) => "USD" | "BTC" | "SAT" | "MSAT" | "Unsupported CurrencyUnit";
declare function formatCurrencyStr(amount: CurrencyAmountArg, maxFractionDigits?: number, compact?: boolean, showBtcSymbol?: boolean, options?: Intl.NumberFormatOptions): string;
declare function separateCurrencyStrParts(currencyStr: string): {
    symbol: string;
    amount: string;
};
declare function localeToCurrencySymbol(locale: string): string;

declare const isBrowser: boolean;
declare const isNode: boolean;
declare const isTest: boolean;

type Maybe<T> = T | null | undefined;
type ExpandRecursively<T> = T extends object ? T extends infer O ? {
    [K in keyof O]: ExpandRecursively<O[K]>;
} : never : T;
type ById<T> = {
    [id: string]: T;
};
type OmitTypename<T> = Omit<T, "__typename">;
declare const isType: <T extends string>(typename: T) => <N extends {
    __typename: string;
}>(node: N | null | undefined) => node is Extract<N, {
    __typename: T;
}>;
type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
type JSONLiteral = string | number | boolean | null;
type JSONType = JSONLiteral | JSONType[] | {
    [key: string]: JSONType;
};
type JSONObject = {
    [key: string]: JSONType;
};

declare const isError: (e: unknown) => e is Error;
type ErrorWithMessage = {
    message: string;
};
declare const isErrorWithMessage: (e: unknown) => e is ErrorWithMessage;
declare const getErrorMsg: (e: unknown) => string;
declare const isErrorMsg: (e: unknown, msg: string) => boolean;
declare function errorToJSON(err: unknown): JSONType;

declare const bytesToHex: (bytes: Uint8Array) => string;
declare const hexToBytes: (hex: string) => Uint8Array;

declare function getCurrentLocale(): string;

declare const countryCodesToCurrencyCodes: {
    readonly AD: "EUR";
    readonly AR: "ARS";
    readonly AS: "USD";
    readonly AT: "EUR";
    readonly AU: "AUD";
    readonly AX: "EUR";
    readonly BE: "EUR";
    readonly BL: "EUR";
    readonly BQ: "USD";
    readonly BR: "BRL";
    readonly CA: "CAD";
    readonly CO: "COP";
    readonly CY: "EUR";
    readonly DE: "EUR";
    readonly EC: "USD";
    readonly EE: "EUR";
    readonly ES: "EUR";
    readonly FI: "EUR";
    readonly FM: "USD";
    readonly FR: "EUR";
    readonly GB: "GBP";
    readonly GF: "EUR";
    readonly GG: "GBP";
    readonly GP: "EUR";
    readonly GR: "EUR";
    readonly GS: "GBP";
    readonly GU: "USD";
    readonly IE: "EUR";
    readonly IM: "GBP";
    readonly IN: "INR";
    readonly IO: "USD";
    readonly IT: "EUR";
    readonly JE: "GBP";
    readonly LT: "EUR";
    readonly LU: "EUR";
    readonly LV: "EUR";
    readonly MC: "EUR";
    readonly ME: "EUR";
    readonly MF: "EUR";
    readonly MH: "USD";
    readonly MP: "USD";
    readonly MQ: "EUR";
    readonly MT: "EUR";
    readonly MX: "MXN";
    readonly NF: "AUD";
    readonly NL: "EUR";
    readonly NR: "AUD";
    readonly PM: "EUR";
    readonly PR: "USD";
    readonly PT: "EUR";
    readonly PW: "USD";
    readonly RE: "EUR";
    readonly SI: "EUR";
    readonly SK: "EUR";
    readonly SM: "EUR";
    readonly TC: "USD";
    readonly TF: "EUR";
    readonly TL: "USD";
    readonly TV: "AUD";
    readonly UM: "USD";
    readonly US: "USD";
    readonly VA: "EUR";
    readonly VG: "USD";
    readonly VI: "USD";
    readonly YT: "EUR";
};
type CurrencyLocales = keyof typeof countryCodesToCurrencyCodes;
type CurrencyCodes = (typeof countryCodesToCurrencyCodes)[CurrencyLocales];
declare function localeToCurrencyCode(locale: string): CurrencyCodes;

declare function clamp(val: number, min: number, max: number): number;
declare function linearInterpolate(value: number, fromRangeStart: number, fromRangeEnd: number, toRangeStart: number, toRangeEnd: number): number;
declare function round(num: number, decimalPlaces?: number): number;
declare function isNumber(value: unknown): value is number;

type GetValueResult<T> = {
    stopPolling: boolean;
    value: null | T;
};
declare function pollUntil<D extends () => Promise<unknown>, T>(asyncFn: D, getValue: (data: Awaited<ReturnType<D>>, response: {
    stopPolling: boolean;
    value: null | T;
}) => GetValueResult<T>, maxPolls?: number, pollIntervalMs?: number, ignoreErrors?: boolean | ((e: unknown) => boolean), getMaxPollsError?: (maxPolls: number) => Error): Promise<T>;

declare function sleep(ms: number): Promise<unknown>;

export { ById, CurrencyAmountArg, CurrencyAmountObj, CurrencyAmountType, CurrencyCodes, CurrencyLocales, CurrencyMap, CurrencyUnit, DeepPartial, ExpandRecursively, JSONLiteral, JSONObject, JSONType, Maybe, OmitTypename, abbrCurrencyUnit, b64decode, b64encode, bytesToHex, clamp, convertCurrencyAmount, convertCurrencyAmountValue, countryCodesToCurrencyCodes, createSha256Hash, defaultCurrencyCode, errorToJSON, formatCurrencyStr, getCurrentLocale, getErrorMsg, hexToBytes, isBrowser, isCurrencyAmount, isCurrencyAmountObj, isCurrencyMap, isError, isErrorMsg, isErrorWithMessage, isNode, isNumber, isTest, isType, linearInterpolate, localeToCurrencyCode, localeToCurrencySymbol, mapCurrencyAmount, pollUntil, round, separateCurrencyStrParts, sleep, urlsafe_b64decode };
