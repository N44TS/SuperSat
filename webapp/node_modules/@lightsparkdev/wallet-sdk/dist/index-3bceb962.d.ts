import * as _lightsparkdev_core from '@lightsparkdev/core';
import { Query, Maybe, AuthProvider, CryptoInterface, SigningKeyType, KeyOrAliasType } from '@lightsparkdev/core';
import { Observable } from 'zen-observable-ts';

type AccessTokenInfo = {
    accessToken: string;
    validUntil: Date;
};

/**
 * Interface for storing and retrieving JWT token info.
 */
interface AccessTokenStorage {
    getCurrent(): Promise<AccessTokenInfo | null>;
    replace(tokenInfo: AccessTokenInfo): Promise<void>;
    clear(): Promise<void>;
}

/** This is an enum identifying a particular Bitcoin Network. **/
declare enum BitcoinNetwork {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** The production version of the Bitcoin Blockchain. **/
    MAINNET = "MAINNET",
    /** A test version of the Bitcoin Blockchain, maintained by Lightspark. **/
    REGTEST = "REGTEST",
    /**
     * A test version of the Bitcoin Blockchain, maintained by a centralized organization. Not in use
     * at Lightspark. *
     */
    SIGNET = "SIGNET",
    /** A test version of the Bitcoin Blockchain, publicly available. **/
    TESTNET = "TESTNET"
}

/** This enum identifies the unit of currency associated with a CurrencyAmount. **/
declare enum CurrencyUnit {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /**
     * Bitcoin is the cryptocurrency native to the Bitcoin network. It is used as the native medium
     * for value transfer for the Lightning Network. *
     */
    BITCOIN = "BITCOIN",
    /**
     * 0.00000001 (10e-8) Bitcoin or one hundred millionth of a Bitcoin. This is the unit most
     * commonly used in Lightning transactions. *
     */
    SATOSHI = "SATOSHI",
    /**
     * 0.001 Satoshi, or 10e-11 Bitcoin. We recommend using the Satoshi unit instead when possible. *
     */
    MILLISATOSHI = "MILLISATOSHI",
    /** United States Dollar. **/
    USD = "USD",
    /**
     * 0.000000001 (10e-9) Bitcoin or a billionth of a Bitcoin. We recommend using the Satoshi unit
     * instead when possible. *
     */
    NANOBITCOIN = "NANOBITCOIN",
    /**
     * 0.000001 (10e-6) Bitcoin or a millionth of a Bitcoin. We recommend using the Satoshi unit
     * instead when possible. *
     */
    MICROBITCOIN = "MICROBITCOIN",
    /**
     * 0.001 (10e-3) Bitcoin or a thousandth of a Bitcoin. We recommend using the Satoshi unit instead
     * when possible. *
     */
    MILLIBITCOIN = "MILLIBITCOIN"
}

/** This object represents the value and unit for an amount of currency. **/
interface CurrencyAmount {
    /** The original numeric value for this CurrencyAmount. **/
    originalValue: number;
    /** The original unit of currency for this CurrencyAmount. **/
    originalUnit: CurrencyUnit;
    /** The unit of user's preferred currency. **/
    preferredCurrencyUnit: CurrencyUnit;
    /**
     * The rounded numeric value for this CurrencyAmount in the very base level of user's preferred
     * currency. For example, for USD, the value will be in cents.
     **/
    preferredCurrencyValueRounded: number;
    /**
     * The approximate float value for this CurrencyAmount in the very base level of user's
     * preferred currency. For example, for USD, the value will be in cents.
     **/
    preferredCurrencyValueApprox: number;
}

/**
 * This interface is used by all the entities in the Lightspark system. It defines a few core
 * fields that are available everywhere. Any object that implements this interface can be queried
 * using the `entity` query and its ID. *
 */
interface Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The typename of the object **/
    typename: string;
}

/**
 * This is an enum of the potential types of addresses that a node on the Lightning Network can
 * have. *
 */
declare enum NodeAddressType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    IPV4 = "IPV4",
    IPV6 = "IPV6",
    TOR = "TOR"
}

/** This object represents the address of a node on the Lightning Network. **/
interface NodeAddress {
    /** The string representation of the address. **/
    address: string;
    /** The type, or protocol, of this address. **/
    type: NodeAddressType;
}

/**
 * A connection between a node and the addresses it has announced for itself on Lightning Network.
 * *
 */
interface NodeToAddressesConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** The addresses for the current page of this connection. **/
    entities: NodeAddress[];
}

/**
 * This object is an interface representing a Lightning Node on the Lightning Network, and could
 * either be a Lightspark node or a node managed by a third party. *
 */
interface Node {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The Bitcoin Network this node is deployed in. **/
    bitcoinNetwork: BitcoinNetwork;
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    displayName: string;
    /** The typename of the object **/
    typename: string;
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    alias?: string | undefined;
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    color?: string | undefined;
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    conductivity?: number | undefined;
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    publicKey?: string | undefined;
    getAddresses(client: LightsparkClient, first?: number | undefined, types?: NodeAddressType[] | undefined): Promise<NodeToAddressesConnection>;
}
declare const getNodeQuery: (id: string) => Query<Node>;

/**
 * This object represents a node that exists on the Lightning Network, including nodes not managed
 * by Lightspark. You can retrieve this object to get publicly available information about any node
 * on the Lightning Network. *
 */
declare class GraphNode implements Node, Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The Bitcoin Network this node is deployed in. **/
    readonly bitcoinNetwork: BitcoinNetwork;
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    readonly displayName: string;
    /** The typename of the object **/
    readonly typename: string;
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    readonly alias?: string | undefined;
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    readonly color?: string | undefined;
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    readonly conductivity?: number | undefined;
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    readonly publicKey?: string | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The Bitcoin Network this node is deployed in. **/
    bitcoinNetwork: BitcoinNetwork, 
    /**
     * The name of this node in the network. It will be the most human-readable option possible,
     * depending on the data available for this node.
     **/
    displayName: string, 
    /** The typename of the object **/
    typename: string, 
    /**
     * A name that identifies the node. It has no importance in terms of operating the node, it is
     * just a way to identify and search for commercial services or popular nodes. This alias can
     * be changed at any time by the node operator.
     **/
    alias?: string | undefined, 
    /**
     * A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is
     * white. It has no importance in terms of operating the node, it is just a way to visually
     * differentiate nodes. That color can be changed at any time by the node operator.
     **/
    color?: string | undefined, 
    /**
     * A summary metric used to capture how well positioned a node is to send, receive, or route
     * transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be
     * capital efficient. The value is an integer ranging between 0 and 10 (bounds included).
     **/
    conductivity?: number | undefined, 
    /**
     * The public key of this node. It acts as a unique identifier of this node in the Lightning
     * Network. *
     */
    publicKey?: string | undefined);
    getAddresses(client: LightsparkClient, first?: number | undefined, types?: NodeAddressType[] | undefined): Promise<NodeToAddressesConnection>;
    static getGraphNodeQuery(id: string): Query<GraphNode>;
    toJson(): {
        __typename: string;
        graph_node_id: string;
        graph_node_created_at: string;
        graph_node_updated_at: string;
        graph_node_alias: string | undefined;
        graph_node_bitcoin_network: BitcoinNetwork;
        graph_node_color: string | undefined;
        graph_node_conductivity: number | undefined;
        graph_node_display_name: string;
        graph_node_public_key: string | undefined;
    };
}

/**
 * This object represents the data associated with a BOLT #11 invoice. You can retrieve this object
 * to receive the relevant data associated with a specific invoice. *
 */
interface InvoiceData {
    encodedPaymentRequest: string;
    bitcoinNetwork: BitcoinNetwork;
    /** The payment hash of this invoice. **/
    paymentHash: string;
    /**
     * The requested amount in this invoice. If it is equal to 0, the sender should choose the
     * amount to send.
     **/
    amount: CurrencyAmount;
    /** The date and time when this invoice was created. **/
    createdAt: string;
    /** The date and time when this invoice will expire. **/
    expiresAt: string;
    /** The lightning node that will be paid when fulfilling this invoice. **/
    destination: GraphNode;
    /** The typename of the object **/
    typename: string;
    /** A short, UTF-8 encoded, description of the purpose of this invoice. **/
    memo?: string | undefined;
}

/**
 * This is an enum of the potential states that a payment request on the Lightning Network can
 * take. *
 */
declare enum PaymentRequestStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    OPEN = "OPEN",
    CLOSED = "CLOSED"
}

/** This object represents a BOLT #11 invoice (https://github.com/lightning/bolts/blob/master/11-payment-encoding.md) created by a Lightspark Node. You can retrieve this object to receive relevant payment information for a specific invoice generated by a Lightspark node. **/
interface Invoice {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The details of the invoice. **/
    data: InvoiceData;
    /** The status of the payment request. **/
    status: PaymentRequestStatus;
    /** The typename of the object **/
    typename: string;
    /** The total amount that has been paid to this invoice. **/
    amountPaid?: CurrencyAmount | undefined;
}
declare const getInvoiceQuery: (id: string) => Query<Invoice>;

/**
 * This is an object representing the balance associated with your Lightspark account. You can
 * retrieve this object to see your balance, which can be broken down into several different
 * categorizations. *
 */
interface Balances {
    /**
     * This represents the balance that should be displayed when asked "how much do I own right
     * now?". It represents the amount currently owned, including things that may not be owned soon
     * (e.g. in-flight outgoing payments, in-flight withdrawals, commit fees, etc.). It really is a
     * snapshot of what is officially owned at this instant.
     **/
    ownedBalance: CurrencyAmount;
    /**
     * This represents the balance that should be displayed when asked "how much can I send on
     * Lightning right now?". It represents the amount currently available to be sent on the
     * Lightning network. We remove from the balance all the funds that are temporarily locked
     * (e.g. channel reserves).
     **/
    availableToSendBalance: CurrencyAmount;
    /**
     * This represents the balance that should be displayed when asked "how much money can I
     * withdraw on the Bitcoin network right now?". It represents the amount currently available to
     * withdraw and is usually equal to the `owned_balance` but it does not include in-flight
     * operations (which would likely succeed and therefore likely make your withdrawal fail).
     **/
    availableToWithdrawBalance: CurrencyAmount;
}

/**
 * This is an enum of the potential statuses a transaction associated with your Lightspark Node can
 * take. *
 */
declare enum TransactionStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** Transaction succeeded. **/
    SUCCESS = "SUCCESS",
    /** Transaction failed. **/
    FAILED = "FAILED",
    /** Transaction has been initiated and is currently in-flight. **/
    PENDING = "PENDING",
    /**
     * For transaction type PAYMENT_REQUEST only. No payments have been made to a payment request. *
     */
    NOT_STARTED = "NOT_STARTED",
    /** For transaction type PAYMENT_REQUEST only. A payment request has expired. **/
    EXPIRED = "EXPIRED",
    /** For transaction type PAYMENT_REQUEST only. **/
    CANCELLED = "CANCELLED"
}

/**
 * This is an enum of the potential types of transactions that can be associated with your
 * Lightspark Node. *
 */
declare enum TransactionType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** Transactions initiated from a Lightspark node on Lightning Network. **/
    OUTGOING_PAYMENT = "OUTGOING_PAYMENT",
    /** Transactions received by a Lightspark node on Lightning Network. **/
    INCOMING_PAYMENT = "INCOMING_PAYMENT",
    /** Transactions that forwarded payments through Lightspark nodes on Lightning Network. **/
    ROUTED = "ROUTED",
    /**
     * Transactions on the Bitcoin blockchain to withdraw funds from a Lightspark node to a Bitcoin
     * wallet. *
     */
    L1_WITHDRAW = "L1_WITHDRAW",
    /** Transactions on Bitcoin blockchain to fund a Lightspark node's wallet. **/
    L1_DEPOSIT = "L1_DEPOSIT",
    /**
     * Transactions on Bitcoin blockchain to open a channel on Lightning Network funded by the local
     * Lightspark node. *
     */
    CHANNEL_OPEN = "CHANNEL_OPEN",
    /**
     * Transactions on Bitcoin blockchain to close a channel on Lightning Network where the balances
     * are allocated back to local and remote nodes. *
     */
    CHANNEL_CLOSE = "CHANNEL_CLOSE",
    /** Transactions initiated from a Lightspark node on Lightning Network. **/
    PAYMENT = "PAYMENT",
    /** Payment requests from a Lightspark node on Lightning Network **/
    PAYMENT_REQUEST = "PAYMENT_REQUEST",
    /** Transactions that forwarded payments through Lightspark nodes on Lightning Network. **/
    ROUTE = "ROUTE"
}

/** This is an enum of the potential statuses that your Lightspark wallet can take.  **/
declare enum WalletStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /**
     * The wallet has not been set up yet and is ready to be deployed. This is the default status
     * after the first login. *
     */
    NOT_SETUP = "NOT_SETUP",
    /** The wallet is currently being deployed in the Lightspark infrastructure. **/
    DEPLOYING = "DEPLOYING",
    /**
     * The wallet has been deployed in the Lightspark infrastructure and is ready to be initialized. *
     */
    DEPLOYED = "DEPLOYED",
    /** The wallet is currently being initialized. **/
    INITIALIZING = "INITIALIZING",
    /** The wallet is available and ready to be used. **/
    READY = "READY",
    /** The wallet is temporarily available, due to a transient issue or a scheduled maintenance. **/
    UNAVAILABLE = "UNAVAILABLE",
    /**
     * The wallet had an unrecoverable failure. This status is not expected to happend and will be
     * investigated by the Lightspark team. *
     */
    FAILED = "FAILED",
    /** The wallet is being terminated. **/
    TERMINATING = "TERMINATING",
    /**
     * The wallet has been terminated and is not available in the Lightspark infrastructure anymore.
     * It is not connected to the Lightning network and its funds can only be accessed using the
     * Funds Recovery flow. *
     */
    TERMINATED = "TERMINATED"
}

/**
 * This is an object representing information about a page returned by the Lightspark API. For more
 * information, please see the “Pagination” section of our API docs for more information about its
 * usage. *
 */
interface PageInfo {
    hasNextPage?: boolean | undefined;
    hasPreviousPage?: boolean | undefined;
    startCursor?: string | undefined;
    endCursor?: string | undefined;
}

/**
 * This object is an interface of a payment request on the Lightning Network (i.e., a Lightning
 * Invoice). It contains data related to parsing the payment details of a Lightning Invoice. *
 */
interface PaymentRequestData {
    encodedPaymentRequest: string;
    bitcoinNetwork: BitcoinNetwork;
    /** The typename of the object **/
    typename: string;
}

/**
 * This object contains information related to a payment request generated or received by a
 * LightsparkNode. You can retrieve this object to receive payment information about a specific
 * invoice. *
 */
interface PaymentRequest {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when the entity was first created. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The details of the payment request. **/
    data: PaymentRequestData;
    /** The status of the payment request. **/
    status: PaymentRequestStatus;
    /** The typename of the object **/
    typename: string;
}
declare const getPaymentRequestQuery: (id: string) => Query<PaymentRequest>;

interface WalletToPaymentRequestsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The payment requests for the current page of this connection. **/
    entities: PaymentRequest[];
    /** The typename of the object **/
    typename: string;
}

/**
 * This object represents a payment transaction. The transaction can occur either on a Bitcoin
 * Network, or over the Lightning Network. You can retrieve this object to receive specific
 * information about a particular transaction tied to your Lightspark Node. *
 */
interface Transaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
}
declare const getTransactionQuery: (id: string) => Query<Transaction>;

interface WalletToTransactionsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The transactions for the current page of this connection. **/
    entities: Transaction[];
    /** The typename of the object **/
    typename: string;
}

/** This is an enum of the potential statuses that a Withdrawal can take. **/
declare enum WithdrawalRequestStatus {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    CREATING = "CREATING",
    CREATED = "CREATED",
    FAILED = "FAILED",
    IN_PROGRESS = "IN_PROGRESS",
    SUCCESSFUL = "SUCCESSFUL",
    PARTIALLY_SUCCESSFUL = "PARTIALLY_SUCCESSFUL"
}

/**
 * This object represents an L1 withdrawal from your Lightspark Node to any Bitcoin wallet. You can
 * retrieve this object to receive detailed information about any L1 withdrawal associated with
 * your Lightspark Node or account. *
 */
interface Withdrawal {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /** The fees that were paid by the node for this transaction. **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
}
declare const getWithdrawalQuery: (id: string) => Query<Withdrawal>;

interface WithdrawalRequestToWithdrawalsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** The withdrawals for the current page of this connection. **/
    entities: Withdrawal[];
}

/**
 * This object represents a request made for an L1 withdrawal from your Lightspark Node to any
 * Bitcoin wallet. You can retrieve this object to receive detailed information about any
 * withdrawal request made from your Lightspark account. *
 */
declare class WithdrawalRequest implements Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /**
     * The requested amount of money to be withdrawn. If the requested amount is -1, it means to
     * withdraw all.
     **/
    readonly requestedAmount: CurrencyAmount;
    /**
     * The amount of money that should be withdrawn in this request.
     *
     * @deprecated Use `requested_amount` instead
     **/
    readonly amount: CurrencyAmount;
    /** The bitcoin address where the funds should be sent. **/
    readonly bitcoinAddress: string;
    /** The current status of this withdrawal request. **/
    readonly status: WithdrawalRequestStatus;
    /** The typename of the object **/
    readonly typename: string;
    /**
     * If the requested amount is `-1` (i.e. everything), this field may contain an estimate of the
     * amount for the withdrawal.
     **/
    readonly estimatedAmount?: CurrencyAmount | undefined;
    /**
     * The actual amount that is withdrawn to the bitcoin address. It will be set once the request
     * is completed.
     **/
    readonly amountWithdrawn?: CurrencyAmount | undefined;
    /**
     * The total fees the node paid for the withdrawal. It will be set once the request is
     * completed. *
     */
    readonly totalFees?: CurrencyAmount | undefined;
    /** The time at which this request was completed. **/
    readonly completedAt?: string | undefined;
    /**
     * The withdrawal transaction that has been generated by this request.
     *
     * @deprecated Use `withdrawals` instead.
     **/
    readonly withdrawalId?: string | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /**
     * The requested amount of money to be withdrawn. If the requested amount is -1, it means to
     * withdraw all.
     **/
    requestedAmount: CurrencyAmount, 
    /**
     * The amount of money that should be withdrawn in this request.
     *
     * @deprecated Use `requested_amount` instead
     **/
    amount: CurrencyAmount, 
    /** The bitcoin address where the funds should be sent. **/
    bitcoinAddress: string, 
    /** The current status of this withdrawal request. **/
    status: WithdrawalRequestStatus, 
    /** The typename of the object **/
    typename: string, 
    /**
     * If the requested amount is `-1` (i.e. everything), this field may contain an estimate of the
     * amount for the withdrawal.
     **/
    estimatedAmount?: CurrencyAmount | undefined, 
    /**
     * The actual amount that is withdrawn to the bitcoin address. It will be set once the request
     * is completed.
     **/
    amountWithdrawn?: CurrencyAmount | undefined, 
    /**
     * The total fees the node paid for the withdrawal. It will be set once the request is
     * completed. *
     */
    totalFees?: CurrencyAmount | undefined, 
    /** The time at which this request was completed. **/
    completedAt?: string | undefined, 
    /**
     * The withdrawal transaction that has been generated by this request.
     *
     * @deprecated Use `withdrawals` instead.
     **/
    withdrawalId?: string | undefined);
    getWithdrawals(client: LightsparkClient, first?: number | undefined): Promise<WithdrawalRequestToWithdrawalsConnection>;
    static getWithdrawalRequestQuery(id: string): Query<WithdrawalRequest>;
    toJson(): {
        __typename: string;
        withdrawal_request_id: string;
        withdrawal_request_created_at: string;
        withdrawal_request_updated_at: string;
        withdrawal_request_requested_amount: any;
        withdrawal_request_amount: any;
        withdrawal_request_estimated_amount: any;
        withdrawal_request_amount_withdrawn: any;
        withdrawal_request_total_fees: any;
        withdrawal_request_bitcoin_address: string;
        withdrawal_request_status: WithdrawalRequestStatus;
        withdrawal_request_completed_at: string | undefined;
        withdrawal_request_withdrawal: {
            id: string | undefined;
        };
    };
}

interface WalletToWithdrawalRequestsConnection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The withdrawal requests for the current page of this connection. **/
    entities: WithdrawalRequest[];
    /** The typename of the object **/
    typename: string;
}

declare class Wallet implements Entity {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    readonly id: string;
    /** The date and time when the entity was first created. **/
    readonly createdAt: string;
    /** The date and time when the entity was last updated. **/
    readonly updatedAt: string;
    /** The status of this wallet. **/
    readonly status: WalletStatus;
    /** The typename of the object **/
    readonly typename: string;
    /** The balances that describe the funds in this wallet. **/
    readonly balances?: Balances | undefined;
    constructor(
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string, 
    /** The date and time when the entity was first created. **/
    createdAt: string, 
    /** The date and time when the entity was last updated. **/
    updatedAt: string, 
    /** The status of this wallet. **/
    status: WalletStatus, 
    /** The typename of the object **/
    typename: string, 
    /** The balances that describe the funds in this wallet. **/
    balances?: Balances | undefined);
    getTransactions(client: LightsparkClient, first?: number | undefined, after?: string | undefined, createdAfterDate?: string | undefined, createdBeforeDate?: string | undefined, statuses?: TransactionStatus[] | undefined, types?: TransactionType[] | undefined): Promise<WalletToTransactionsConnection>;
    getPaymentRequests(client: LightsparkClient, first?: number | undefined, after?: string | undefined, createdAfterDate?: string | undefined, createdBeforeDate?: string | undefined): Promise<WalletToPaymentRequestsConnection>;
    getWithdrawalRequests(client: LightsparkClient, first?: number | undefined, after?: string | undefined, statuses?: WithdrawalRequestStatus[] | undefined, createdAfterDate?: string | undefined, createdBeforeDate?: string | undefined): Promise<WalletToWithdrawalRequestsConnection>;
    static getWalletQuery(): Query<Wallet>;
    toJson(): {
        __typename: string;
        wallet_id: string;
        wallet_created_at: string;
        wallet_updated_at: string;
        wallet_balances: any;
        wallet_status: WalletStatus;
    };
}

interface LoginWithJWTOutput {
    accessToken: string;
    wallet: Wallet;
    validUntil: string;
}

/**
 * This object represents the estimated L1 transaction fees for the Bitcoin network. Fee estimates
 * are separated by potential confirmation speeds for settlement. *
 */
interface FeeEstimate {
    feeFast: CurrencyAmount;
    feeMin: CurrencyAmount;
}

/**
 * This object represents any payment sent to a Lightspark node on the Lightning Network. You can
 * retrieve this object to receive payment related information about a specific payment received by
 * a Lightspark node. *
 */
interface IncomingPayment {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /**
     * The optional payment request for this incoming payment, which will be null if the payment is
     * sent through keysend.
     **/
    paymentRequestId?: string | undefined;
}
declare const getIncomingPaymentQuery: (id: string) => Query<IncomingPayment>;

/** This is an enum for potential invoice types. **/
declare enum InvoiceType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    /** A standard Bolt 11 invoice. **/
    STANDARD = "STANDARD",
    /** An AMP (Atomic Multi-path Payment) invoice. **/
    AMP = "AMP"
}

declare enum KeyType {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    RSA_OAEP = "RSA_OAEP",
    ELLIPTIC_CURVE = "ELLIPTIC_CURVE",
    ED25519 = "ED25519"
}

/**
 * This is an enum of the potential reasons why an OutgoingPayment sent from a Lightspark Node may
 * have failed. *
 */
declare enum PaymentFailureReason {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    NONE = "NONE",
    TIMEOUT = "TIMEOUT",
    NO_ROUTE = "NO_ROUTE",
    ERROR = "ERROR",
    INCORRECT_PAYMENT_DETAILS = "INCORRECT_PAYMENT_DETAILS",
    INSUFFICIENT_BALANCE = "INSUFFICIENT_BALANCE",
    INVOICE_ALREADY_PAID = "INVOICE_ALREADY_PAID",
    SELF_PAYMENT = "SELF_PAYMENT",
    INVOICE_EXPIRED = "INVOICE_EXPIRED",
    INVOICE_CANCELLED = "INVOICE_CANCELLED",
    RISK_SCREENING_FAILED = "RISK_SCREENING_FAILED",
    INSUFFICIENT_BALANCE_ON_SINGLE_PATH_INVOICE = "INSUFFICIENT_BALANCE_ON_SINGLE_PATH_INVOICE"
}

interface RichText {
    text: string;
}

/**
 * This object represents a Lightning Network payment sent from a Lightspark Node. You can retrieve
 * this object to receive payment related information about any payment sent from your Lightspark
 * Node on the Lightning Network. *
 */
interface OutgoingPayment {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /** The fees paid by the sender node to send the payment. **/
    fees?: CurrencyAmount | undefined;
    /** The data of the payment request that was paid by this transaction, if known. **/
    paymentRequestData?: PaymentRequestData | undefined;
    /** If applicable, the reason why the payment failed. **/
    failureReason?: PaymentFailureReason | undefined;
    /** If applicable, user-facing error message describing why the payment failed. **/
    failureMessage?: RichText | undefined;
    /** The preimage of the payment. **/
    paymentPreimage?: string | undefined;
}
declare const getOutgoingPaymentQuery: (id: string) => Query<OutgoingPayment>;

type WalletDashboard = {
    id: string;
    status: WalletStatus;
    balances: Maybe<Balances>;
    recentTransactions: WalletToTransactionsConnection;
    paymentRequests: WalletToPaymentRequestsConnection;
};

/** This is an enum of the potential modes that your Bitcoin withdrawal can take. **/
declare enum WithdrawalMode {
    /**
     * This is an enum value that represents values that could be added in the future.
     * Clients should support unknown values as more of them could be added without notice.
     */
    FUTURE_VALUE = "FUTURE_VALUE",
    WALLET_ONLY = "WALLET_ONLY",
    WALLET_THEN_CHANNELS = "WALLET_THEN_CHANNELS"
}

/**
 * The LightsparkClient is the main entrypoint for interacting with the
 * Lightspark Wallet SDK.
 *
 * ```ts
 * const lightsparkClient = new LightsparkClient(
 *    new CustomJwtAuthProvider(new InMemoryTokenStorage()),
 * );
 * const encodedInvoice = await lightsparkClient.createInvoice(
 *   { value: 100, unit: CurrencyUnit.SATOSHI },
 *   "Whasssupppp",
 *   InvoiceType.AMP,
 * );
 *
 * const invoiceDetails = await lightsparkClient.decodeInvoice(encodedInvoice);
 * console.log(invoiceDetails);
 *
 * const payment = await lightsparkClient.payInvoice(encodedInvoice, 1_000_000);
 * console.log(payment);
 * ```
 *
 * @class LightsparkClient
 */
declare class LightsparkClient {
    private authProvider;
    private readonly serverUrl;
    private readonly cryptoImpl;
    private readonly signingKeyType;
    private requester;
    private readonly nodeKeyCache;
    /**
     * Constructs a new LightsparkClient.
     *
     * @param authProvider The auth provider to use for authentication. Defaults to a stub auth provider. For server-side
     *     use, you should use the `AccountTokenAuthProvider`.
     * @param serverUrl The base URL of the server to connect to. Defaults to lightspark production.
     * @param cryptoImpl The crypto implementation to use. Defaults to web and node compatible crypto.
     *     For React Native, you should use the `ReactNativeCrypto`
     *     implementation from `@lightsparkdev/react-native`.
     * @param signingKeyType The type of signing key used in the LightsparkClient. Different signing operations are used depending on the key type.
     */
    constructor(authProvider?: AuthProvider, serverUrl?: string, cryptoImpl?: CryptoInterface, signingKeyType?: SigningKeyType);
    /**
     * Sets the auth provider for the client.
     * This is useful for switching between auth providers if you are using
     * multiple accounts or waiting for the user to log in.
     *
     * @param authProvider
     */
    setAuthProvider(authProvider: AuthProvider): void;
    /**
     * @returns Whether or not the client is authorized. This is useful for determining if the user is logged in or not.
     */
    isAuthorized(): Promise<boolean>;
    /**
     * Login using the Custom JWT authentication scheme described in our
     * documentation.
     *
     * Note: When using this method, you are responsible for refreshing the JWT
     * token before or when it expires. If the token expires,
     * the client will throw a [LightsparkAuthenticationException] on the next
     * API call which requires valid authentication.
     * Then you'll need to call this method again to get a new token.
     *
     * @param accountId The account ID to login with. This is specific to your company's account.
     * @param jwt The JWT to use for authentication of this user.
     * @param storage The storage to use for storing the JWT token.
     * @return The output of the login operation, including the access token, expiration time, and wallet info.
     */
    loginWithJWT(accountId: string, jwt: string, storage: AccessTokenStorage): Promise<LoginWithJWTOutput>;
    /**
     * Deploys a wallet in the Lightspark infrastructure.
     * This is an asynchronous operation,
     * the caller should then poll the wallet frequently (or subscribe to its
     * modifications). When this process is over,
     * the Wallet status will change to `DEPLOYED` (or `FAILED`).
     *
     * @return The wallet that was deployed.
     */
    deployWallet(): Promise<Wallet | null>;
    /**
     * Deploys a wallet in the Lightspark infrastructure and waits for it to be
     * deployed. This is an asynchronous operation,
     * which will continue processing wallet status updates until the Wallet
     * status changes to `DEPLOYED` (or `FAILED`).
     *
     * @return A Promise with the final wallet status after deployment or failure.
     * @throws LightsparkException if the wallet status is not `DEPLOYED` or `FAILED` after 60 seconds,
     * or if the subscription fails.
     */
    deployWalletAndAwaitDeployed(): Promise<WalletStatus>;
    /**
     * Initializes a wallet in the Lightspark infrastructure and syncs it to the
     * Bitcoin network. This is an asynchronous operation,
     * the caller should then poll the wallet frequently (or subscribe to its
     * modifications). When this process is over,
     * the Wallet status will change to `READY` (or `FAILED`).
     *
     * @param keyType The type of key to use for the wallet.
     * @param signingPublicKey The base64-encoded public key to use for signing transactions.
     * @param signingPrivateKeyOrAlias An object containing either the base64-encoded private key or, in the case of
     *     React Native, a key alias for a key in the mobile keystore.
     *     The key will be used for signing transactions.
     *     This key will not leave the device.
     *     It is only used for signing transactions locally.
     * @return The wallet that was initialized.
     */
    initializeWallet(keyType: KeyType, signingPublicKey: string, signingPrivateKeyOrAlias: KeyOrAliasType): Promise<Wallet | null>;
    /**
     * Initializes a wallet in the Lightspark infrastructure and syncs it to the
     * Bitcoin network. This is an asynchronous operation,
     * which will continue processing wallet status updates until the Wallet
     * status changes to `READY` (or `FAILED`).
     *
     * @param keyType The type of key to use for the wallet.
     * @param signingPublicKey The base64-encoded public key to use for signing transactions.
     * @param signingPrivateKeyOrAlias An object containing either the base64-encoded private key or, in the case of
     *     React Native, a key alias for a key in the mobile keystore.
     *     The key will be used for signing transactions.
     *     This key will not leave the device.
     *     It is only used for signing transactions locally.
     * @return A Promise with the final wallet status after initialization or failure.
     * @throws LightsparkException if the wallet status is not `READY` or `FAILED` after 5 minutes,
     * or if the subscription fails.
     */
    initializeWalletAndAwaitReady(keyType: KeyType, signingPublicKey: string, signingPrivateKeyOrAlias: KeyOrAliasType): Promise<WalletStatus>;
    /**
     * Removes the wallet from Lightspark infrastructure.
     * It won't be connected to the Lightning network anymore and its funds won't
     * be accessible outside of the Funds Recovery Kit process.
     *
     * @return The wallet that was terminated.
     */
    terminateWallet(): Promise<Wallet | null>;
    /**
     * Get the dashboard overview for a Lightning wallet.
     * Includes balance info and the most recent transactions and payment
     * requests.
     *
     * @param numTransactions The max number of recent transactions to fetch. Defaults to 20.
     * @param numPaymentRequests The max number of recent payment requests to fetch. Defaults to 20.
     * @return The dashboard overview for the wallet, including balance and recent transactions and payment requests.
     */
    getWalletDashboard(numTransactions?: number, numPaymentRequests?: number): Promise<WalletDashboard | null>;
    /**
     * Creates a lightning invoice from the current wallet.
     *
     * Test mode note: You can simulate a payment of this invoice in test move
     * using [createTestModePayment].
     *
     * @param amountMsats The amount of the invoice in milli-satoshis.
     * @param memo Optional memo to include in the invoice.
     * @param type The type of invoice to create. Defaults to [InvoiceType.STANDARD].
     * @param expirySecs The number of seconds until the invoice expires. Defaults to 1 day.
     * @return The created invoice.
     */
    createInvoice(amountMsats: number, memo?: string | undefined, type?: InvoiceType, expirySecs?: number | undefined): Promise<Invoice | null>;
    /**
     * Cancels an existing unpaid invoice and returns that invoice. Cancelled invoices cannot be paid.
     *
     * @param invoiceId The ID of the invoice to cancel.
     * @returns The cancelled invoice, or undefined if the invoice could not be cancelled.
     */
    cancelInvoice(invoiceId: string): Promise<Invoice | null>;
    /**
     * Pay a lightning invoice from the current wallet.
     * This function will return immediately with the payment details,
     * which may still be in a PENDING state.
     * You can use the [payInvoiceAndAwaitResult] function to wait for the
     * payment to complete or fail.
     *
     * Note: This call will fail if the wallet is not unlocked yet via
     * [loadWalletSigningKey]. You must successfully unlock the wallet before
     * calling this function.
     *
     * Test mode note: For test mode, you can use the [createTestModeInvoice]
     * function to create an invoice you can pay in test mode.
     *
     * @param encodedInvoice An encoded string representation of the invoice to pay.
     * @param maxFeesMsats The maximum fees to pay in milli-satoshis. You must pass a value.
     *     As guidance, a maximum fee of 15 basis points should make almost all
     *     transactions succeed. For example,
     *     for a transaction between 10k sats and 100k sats,
     *     this would mean a fee limit of 15 to 150 sats.
     * @param amountMsats The amount to pay in milli-satoshis. Defaults to the full amount of the invoice.
     * @param timeoutSecs The number of seconds to wait for the payment to complete. Defaults to 60.
     * @return The payment details, which may still be in a PENDING state. You can use the [payInvoiceAndAwaitResult]
     *     function to wait for the payment to complete or fail.
     */
    payInvoice(encodedInvoice: string, maxFeesMsats: number, amountMsats?: number | undefined, timoutSecs?: number): Promise<OutgoingPayment>;
    /**
     * Pay a lightning invoice from the current wallet and wait for the payment
     * to complete or fail.
     *
     * Note: This call will fail if the wallet is not unlocked yet via
     * [loadWalletSigningKey]. You must successfully unlock the wallet before
     * calling this function.
     *
     * @param encodedInvoice An encoded string representation of the invoice to pay.
     * @param maxFeesMsats The maximum fees to pay in milli-satoshis. You must pass a value.
     *     As guidance, a maximum fee of 15 basis points should make almost all
     *     transactions succeed. For example,
     *     for a transaction between 10k sats and 100k sats,
     *     this would mean a fee limit of 15 to 150 sats.
     * @param amountMsats The amount to pay in milli-satoshis. Defaults to the full amount of the invoice.
     * @param timeoutSecs The number of seconds to wait for the payment to complete. Defaults to 60.
     * @return The payment details.
     */
    payInvoiceAndAwaitResult(encodedInvoice: string, maxFeesMsats: number, amountMsats?: number | undefined, timeoutSecs?: number): Promise<OutgoingPayment>;
    awaitPaymentResult<T extends OutgoingPayment | IncomingPayment>(payment: T, timeoutSecs?: number): Promise<T>;
    /**
     * Sends a payment directly to a node on the Lightning Network through the
     * public key of the node without an invoice.
     * This function will return immediately with the payment details,
     * which may still be in a PENDING state.
     * You can use the [sendPaymentAndAwaitResult] function to wait for the
     * payment to complete or fail.
     *
     * @param destinationPublicKey The public key of the destination node.
     * @param amountMsats The amount to pay in milli-satoshis.
     * @param maxFeesMsats The maximum amount of fees that you want to pay for this payment to be sent.
     *     As guidance, a maximum fee of 15 basis points should make almost all
     *     transactions succeed. For example,
     *     for a transaction between 10k sats and 100k sats,
     *     this would mean a fee limit of 15 to 150 sats.
     * @param timeoutSecs The timeout in seconds that we will try to make the payment.
     * @return An `OutgoingPayment` object, which may still be in a PENDING state. You can use the
     *     [sendPaymentAndAwaitResult] function to wait for the payment to
     *     complete or fail.
     */
    sendPayment(destinationNodePublicKey: string, amountMsats: number, maxFeesMsats: number, timeoutSecs?: number): Promise<OutgoingPayment>;
    /**
     * Sends a payment directly to a node on the Lightning Network through the
     * public key of the node without an invoice.
     * Waits for the payment to complete or fail.
     *
     * @param destinationPublicKey The public key of the destination node.
     * @param amountMsats The amount to pay in milli-satoshis.
     * @param maxFeesMsats The maximum amount of fees that you want to pay for this payment to be sent.
     *     As guidance, a maximum fee of 15 basis points should make almost all
     *     transactions succeed. For example,
     *     for a transaction between 10k sats and 100k sats,
     *     this would mean a fee limit of 15 to 150 sats.
     * @param timeoutSecs The timeout in seconds that we will try to make the payment.
     * @return An `OutgoingPayment` object. Check the `status` field to see if the payment succeeded or failed.
     */
    sendPaymentAndAwaitResult(destinationNodePublicKey: string, amountMsats: number, maxFeesMsats: number, timeoutSecs?: number): Promise<OutgoingPayment>;
    /**
     * Decode a lightning invoice to get its details included payment amount,
     * destination, etc.
     *
     * @param encodedInvoice An encoded string representation of the invoice to decode.
     * @return The decoded invoice details.
     */
    decodeInvoice(encodedInvoice: string): Promise<InvoiceData | null>;
    /**
     * Gets an estimate of the fee for sending a payment over the given bitcoin
     * network.
     *
     * @param bitcoinNetwork The bitcoin network for which to get a fee estimate. Defaults to MAINNET.
     * @returns A fee estimate for the given bitcoin network including a minimum fee rate, and a max-speed fee rate.
     */
    getBitcoinFeeEstimate(): Promise<FeeEstimate>;
    /**
     * Gets an estimate of the fees that will be paid for a Lightning invoice.
     *
     * @param encodedPaymentRequest The invoice you want to pay (as defined by the BOLT11 standard).
     * @param amountMsats If the invoice does not specify a payment amount, then the amount that you wish to pay,
     *     expressed in msats.
     * @returns An estimate of the fees that will be paid for a Lightning invoice.
     */
    getLightningFeeEstimateForInvoice(encodedPaymentRequest: string, amountMsats?: number | undefined): Promise<CurrencyAmount>;
    /**
     * Returns an estimate of the fees that will be paid to send a payment to
     * another Lightning node.
     *
     * @param destinationNodePublicKey The public key of the node that you want to pay.
     * @param amountMsats The payment amount expressed in msats.
     * @returns An estimate of the fees that will be paid to send a payment to another Lightning node.
     */
    getLightningFeeEstimateForNode(destinationNodePublicKey: string, amountMsats: number): Promise<CurrencyAmount>;
    /**
     * Returns an estimated amount for the L1 withdrawal fees for the specified node, amount, and
     * strategy.
     *
     * @param amountSats The amount you want to withdraw from this node in Satoshis. Use the special value -1 to
     *     withdrawal all funds from this wallet.
     * @param withdrawalMode The strategy that should be used to withdraw the funds from this node.
     * @returns An estimated amount for the L1 withdrawal fees for the specified node, amount, and strategy.
     */
    getWithrawalFeeEstimate(amountSats: number, withdrawalMode: WithdrawalMode): Promise<CurrencyAmount>;
    /**
     * Unlocks the wallet for use with the SDK for the current application
     * session. This function must be called before any other functions that
     * require wallet signing keys, including [payInvoice].
     *
     * This function is intended for use in cases where the wallet's private
     * signing key is already saved by the application outside of the SDK.
     * It is the responsibility of the application to ensure that the key is
     * valid and that it is the correct key for the wallet.
     * Otherwise signed requests will fail.
     *
     * @param signingKeyBytesOrAlias An object holding either the PEM encoded bytes of the wallet's private signing key or,
     *     in the case of ReactNative, the alias of the key in the mobile
     *     keychain.
     */
    loadWalletSigningKey(signingKeyBytesOrAlias: KeyOrAliasType): Promise<_lightsparkdev_core.SigningKey | null>;
    /**
     * Creates an L1 Bitcoin wallet address which can be used to deposit or
     * withdraw funds from the Lightning wallet.
     *
     * @return The newly created L1 wallet address.
     */
    createBitcoinFundingAddress(): Promise<string | null>;
    /**
     * @return The current wallet if one exists, null otherwise.
     */
    getCurrentWallet(): Promise<Wallet | null>;
    /**
     * Withdraws funds from the account and sends it to the requested bitcoin
     * address.
     *
     * The process is asynchronous and may take up to a few minutes.
     * You can check the progress by polling the `WithdrawalRequest` that is
     * created, or by subscribing to a webhook.
     *
     * @param amountSats The amount of funds to withdraw in SATOSHI.
     * @param bitcoinAddress The Bitcoin address to withdraw funds to.
     */
    requestWithdrawal(amountSats: number, bitcoinAddress: string): Promise<WithdrawalRequest | null>;
    /**
     * In test mode, generates a Lightning Invoice which can be paid by a local
     * node. This call is only valid in test mode.
     * You can then pay the invoice using [payInvoice].
     *
     * @param amountMsats The amount to pay in milli-satoshis.
     * @param memo An optional memo to attach to the invoice.
     * @param invoiceType The type of invoice to create.
     */
    createTestModeInvoice(amountMsats: number, memo?: string | undefined, invoiceType?: InvoiceType): Promise<string | null>;
    /**
     * In test mode, simulates a payment of a Lightning Invoice from another
     * node. This can only be used in test mode and should be used with invoices
     * generated by [createInvoice].
     *
     * @param encodedInvoice The encoded invoice to pay.
     * @param amountMsats The amount to pay in milli-satoshis for 0-amount invoices. This should be null for non-zero
     *     amount invoices.
     */
    createTestModePayment(encodedInvoice: string, amountMsats?: number | undefined): Promise<IncomingPayment | null>;
    /**
     * @return True if the wallet is unlocked or false if it is locked.
     */
    isWalletUnlocked(): boolean;
    private requireValidAuth;
    private requireWalletUnlocked;
    private waitForWalletStatus;
    private listenToWalletStatus;
    /**
     * Executes a raw `Query` as a subscription and returns an `Observable` that
     * emits the result of the query when it changes.
     *
     * This can only be used with `subscription` operations.
     *
     * @param query The `Query` to execute.
     * @returns A zen-observable that emits the result of the query when it changes.
     */
    subscribeToRawQuery<T>(query: Query<T>): Observable<T>;
    /**
     * Executes a raw `Query` against the Lightspark API.
     *
     * This generally should not be used directly,
     * but is exposed for advanced use cases and for internal use to retrieve
     * complex fields from objects.
     *
     * @param query The `Query` to execute.
     * @returns The result of the query.
     */
    executeRawQuery<T>(query: Query<T>): Promise<T | null>;
}

interface AmazonS3FundsRecoveryKit {
    /** The bitcoin address where the funds should be sent if the recovery kit is used. **/
    bitcoinWalletAddress: string;
    /** The URL of the Amazon S3 bucket URL where we should upload the funds recovery kit. **/
    s3BucketUrl: string;
    /** The typename of the object **/
    typename: string;
}

/**
 * The unique identifier of the Invoice that should be cancelled. The invoice is supposed to be
 * open, not settled and not expired. *
 */
interface CancelInvoiceInput {
    invoiceId: string;
}

/**
 * The Invoice that was cancelled. If the invoice was already cancelled, the same invoice is
 * returned. *
 */
interface CancelInvoiceOutput {
    invoiceId: string;
}

/**
 * This is an object representing a transaction which closes a channel on the Lightning Network.
 * This operation allocates balances back to the local and remote nodes. *
 */
interface ChannelClosingTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /** The fees that were paid by the node for this transaction. **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
}
declare const getChannelClosingTransactionQuery: (id: string) => Query<ChannelClosingTransaction>;

/**
 * This is an object representing a transaction which opens a channel on the Lightning Network.
 * This object occurs only for channels funded by the local Lightspark node. *
 */
interface ChannelOpeningTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /** The fees that were paid by the node for this transaction. **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
}
declare const getChannelOpeningTransactionQuery: (id: string) => Query<ChannelOpeningTransaction>;

interface Connection {
    /**
     * The total count of objects in this connection, using the current filters. It is different
     * from the number of objects returned in the current page (in the `entities` field).
     **/
    count: number;
    /** An object that holds pagination information about the objects in this connection. **/
    pageInfo: PageInfo;
    /** The typename of the object **/
    typename: string;
}

interface CreateBitcoinFundingAddressOutput {
    bitcoinAddress: string;
}

interface CreateInvoiceInput {
    amountMsats: number;
    memo?: string | undefined;
    invoiceType?: InvoiceType | undefined;
    expirySecs?: number | undefined;
}

interface CreateInvoiceOutput {
    invoiceId: string;
}

interface CreateTestModeInvoiceInputWallet {
    amountMsats: number;
    memo?: string | undefined;
    invoiceType?: InvoiceType | undefined;
}

interface CreateTestModeInvoiceOutput {
    encodedPaymentRequest: string;
}

interface CreateTestModePaymentInputWallet {
    /** The invoice you want to be paid (as defined by the BOLT11 standard). **/
    encodedInvoice: string;
    /**
     * The amount you will be paid for this invoice, expressed in msats. It should ONLY be set when
     * the invoice amount is zero.
     **/
    amountMsats?: number | undefined;
}

/**
 * This is an object identifying the output of a test mode payment. This object can be used to
 * retrieve the associated payment made from a Test Mode Payment call. *
 */
interface CreateTestModePaymentoutput {
    /**
     * The payment that has been sent.
     *
     * @deprecated Use incoming_payment instead.
     **/
    paymentId: string;
    /** The payment that has been received. **/
    incomingPaymentId: string;
}

interface DeleteFundsRecoveryKitOutput {
    walletId: string;
}

interface DeployWalletOutput {
    wallet: Wallet;
}

/**
 * This object represents a Deposit made to a Lightspark node wallet. This operation occurs for any
 * L1 funding transaction to the wallet. You can retrieve this object to receive detailed
 * information about the deposit. *
 */
interface Deposit {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /** The fees that were paid by the node for this transaction. **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
}
declare const getDepositQuery: (id: string) => Query<Deposit>;

interface FundWalletInput {
    amountSats?: number | undefined;
}

interface FundWalletOutput {
    amount: CurrencyAmount;
}

interface FundsRecoveryKit {
    /** The bitcoin address where the funds should be sent if the recovery kit is used. **/
    bitcoinWalletAddress: string;
    /** The typename of the object **/
    typename: string;
}

interface KeyInput {
    type: KeyType;
    publicKey: string;
}

interface InitializeWalletInput {
    signingPublicKey: KeyInput;
}

interface InitializeWalletOutput {
    wallet: Wallet;
}

interface LightningFeeEstimateForInvoiceInput {
    /** The invoice you want to pay (as defined by the BOLT11 standard). **/
    encodedPaymentRequest: string;
    /**
     * If the invoice does not specify a payment amount, then the amount that you wish to pay,
     * expressed in msats.
     **/
    amountMsats?: number | undefined;
}

interface LightningFeeEstimateForNodeInput {
    /** The public key of the node that you want to pay. **/
    destinationNodePublicKey: string;
    /** The payment amount expressed in msats. **/
    amountMsats: number;
}

interface LightningFeeEstimateOutput {
    /** The estimated fees for the payment. **/
    feeEstimate: CurrencyAmount;
}

/**
 * This is an object representing a transaction made over the Lightning Network. You can retrieve
 * this object to receive information about a specific transaction made over Lightning for a
 * Lightspark node. *
 */
interface LightningTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
}
declare const getLightningTransactionQuery: (id: string) => Query<LightningTransaction>;

interface LoginWithJWTInput {
    accountId: string;
    jwt: string;
}

/**
 * This object represents an L1 transaction that occurred on the Bitcoin Network. You can retrieve
 * this object to receive information about a specific on-chain transaction made on the Lightning
 * Network associated with your Lightspark Node. *
 */
interface OnChainTransaction {
    /**
     * The unique identifier of this entity across all Lightspark systems. Should be treated as an
     * opaque string.
     **/
    id: string;
    /** The date and time when this transaction was initiated. **/
    createdAt: string;
    /** The date and time when the entity was last updated. **/
    updatedAt: string;
    /** The current status of this transaction. **/
    status: TransactionStatus;
    /** The amount of money involved in this transaction. **/
    amount: CurrencyAmount;
    /**
     * The height of the block that included this transaction. This will be zero for unconfirmed
     * transactions.
     **/
    blockHeight: number;
    /** The Bitcoin blockchain addresses this transaction was sent to. **/
    destinationAddresses: string[];
    /** The typename of the object **/
    typename: string;
    /** The date and time when this transaction was completed or failed. **/
    resolvedAt?: string | undefined;
    /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. **/
    transactionHash?: string | undefined;
    /** The fees that were paid by the node for this transaction. **/
    fees?: CurrencyAmount | undefined;
    /**
     * The hash of the block that included this transaction. This will be null for unconfirmed
     * transactions.
     **/
    blockHash?: string | undefined;
    /** The number of blockchain confirmations for this transaction in real time. **/
    numConfirmations?: number | undefined;
}
declare const getOnChainTransactionQuery: (id: string) => Query<OnChainTransaction>;

interface PayInvoiceInput {
    /** The invoice you want to pay (as defined by the BOLT11 standard). **/
    encodedInvoice: string;
    /** The timeout in seconds that we will try to make the payment. **/
    timeoutSecs: number;
    /**
     * The maximum amount of fees that you want to pay for this payment to be sent, expressed in
     * msats. *
     */
    maximumFeesMsats: number;
    /**
     * The amount you will pay for this invoice, expressed in msats. It should ONLY be set when the
     * invoice amount is zero.
     **/
    amountMsats?: number | undefined;
}

interface PayInvoiceOutput {
    /** The payment that has been sent. **/
    paymentId: string;
}

interface RequestWithdrawalInput {
    /** The bitcoin address where the withdrawal should be sent. **/
    bitcoinAddress: string;
    /**
     * The amount you want to withdraw from this node in Satoshis. Use the special value -1 to
     * withdrawal all funds from this node.
     **/
    amountSats: number;
}

interface RequestWithdrawalOutput {
    /** The request that is created for this withdrawal. **/
    requestId: string;
}

interface SendPaymentInput {
    /** The public key of the destination node. **/
    destinationPublicKey: string;
    /** The timeout in seconds that we will try to make the payment. **/
    timeoutSecs: number;
    /** The amount you will send to the destination node, expressed in msats. **/
    amountMsats: number;
    /**
     * The maximum amount of fees that you want to pay for this payment to be sent, expressed in
     * msats. *
     */
    maximumFeesMsats: number;
}

interface SendPaymentOutput {
    /** The payment that has been sent. **/
    paymentId: string;
}

interface TerminateWalletOutput {
    wallet: Wallet;
}

interface UpdateFundsRecoveryKitInput {
    s3BucketUrl: string;
    bitcoinWalletAddress: string;
}

interface UpdateFundsRecoveryKitOutput {
    walletId: string;
    fundsRecoveryKit: FundsRecoveryKit;
}

interface WithdrawalFeeEstimateInput {
    /**
     * The amount you want to withdraw from this node in Satoshis. Use the special value -1 to
     * withdrawal all funds from this node.
     **/
    amountSats: number;
    /** The strategy that should be used to withdraw the funds from this node. **/
    withdrawalMode: WithdrawalMode;
}

interface WithdrawalFeeEstimateOutput {
    /** The estimated fee for the withdrawal. **/
    feeEstimate: CurrencyAmount;
}

export { NodeToAddressesConnection as $, AccessTokenStorage as A, Balances as B, CancelInvoiceInput as C, DeleteFundsRecoveryKitOutput as D, Entity as E, FeeEstimate as F, GraphNode as G, InitializeWalletOutput as H, IncomingPayment as I, Invoice as J, getInvoiceQuery as K, LightsparkClient as L, InvoiceData as M, InvoiceType as N, KeyInput as O, KeyType as P, LightningFeeEstimateForInvoiceInput as Q, LightningFeeEstimateForNodeInput as R, LightningFeeEstimateOutput as S, LightningTransaction as T, getLightningTransactionQuery as U, LoginWithJWTInput as V, LoginWithJWTOutput as W, Node as X, getNodeQuery as Y, NodeAddress as Z, NodeAddressType as _, AccessTokenInfo as a, OnChainTransaction as a0, getOnChainTransactionQuery as a1, OutgoingPayment as a2, getOutgoingPaymentQuery as a3, PageInfo as a4, PayInvoiceInput as a5, PayInvoiceOutput as a6, PaymentFailureReason as a7, PaymentRequest as a8, getPaymentRequestQuery as a9, WithdrawalRequestStatus as aA, WithdrawalRequestToWithdrawalsConnection as aB, PaymentRequestData as aa, PaymentRequestStatus as ab, RequestWithdrawalInput as ac, RequestWithdrawalOutput as ad, RichText as ae, SendPaymentInput as af, SendPaymentOutput as ag, TerminateWalletOutput as ah, Transaction as ai, getTransactionQuery as aj, TransactionStatus as ak, TransactionType as al, UpdateFundsRecoveryKitInput as am, UpdateFundsRecoveryKitOutput as an, Wallet as ao, WalletDashboard as ap, WalletStatus as aq, WalletToPaymentRequestsConnection as ar, WalletToTransactionsConnection as as, WalletToWithdrawalRequestsConnection as at, Withdrawal as au, getWithdrawalQuery as av, WithdrawalFeeEstimateInput as aw, WithdrawalFeeEstimateOutput as ax, WithdrawalMode as ay, WithdrawalRequest as az, AmazonS3FundsRecoveryKit as b, BitcoinNetwork as c, CancelInvoiceOutput as d, ChannelClosingTransaction as e, ChannelOpeningTransaction as f, getChannelClosingTransactionQuery as g, getChannelOpeningTransactionQuery as h, Connection as i, CreateBitcoinFundingAddressOutput as j, CreateInvoiceInput as k, CreateInvoiceOutput as l, CreateTestModeInvoiceInputWallet as m, CreateTestModeInvoiceOutput as n, CreateTestModePaymentInputWallet as o, CreateTestModePaymentoutput as p, CurrencyAmount as q, CurrencyUnit as r, DeployWalletOutput as s, Deposit as t, getDepositQuery as u, FundWalletInput as v, FundWalletOutput as w, FundsRecoveryKit as x, getIncomingPaymentQuery as y, InitializeWalletInput as z };
