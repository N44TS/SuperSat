"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BitcoinNetwork: () => BitcoinNetwork_default,
  ChromeExtensionLocalTokenStorage: () => ChromeExtensionLocalTokenStorage_default,
  CurrencyUnit: () => CurrencyUnit_default,
  CustomJwtAuthProvider: () => CustomJwtAuthProvider_default,
  GraphNode: () => GraphNode_default,
  InMemoryTokenStorage: () => InMemoryTokenStorage_default,
  InvoiceType: () => InvoiceType_default,
  KeyType: () => KeyType_default,
  LightsparkClient: () => client_default,
  NodeAddressType: () => NodeAddressType_default,
  PaymentFailureReason: () => PaymentFailureReason_default,
  PaymentRequestStatus: () => PaymentRequestStatus_default,
  TransactionStatus: () => TransactionStatus_default,
  TransactionType: () => TransactionType_default,
  Wallet: () => Wallet_default,
  WalletStatus: () => WalletStatus_default,
  WithdrawalMode: () => WithdrawalMode_default,
  WithdrawalRequest: () => WithdrawalRequest_default,
  WithdrawalRequestStatus: () => WithdrawalRequestStatus_default,
  getChannelClosingTransactionQuery: () => getChannelClosingTransactionQuery,
  getChannelOpeningTransactionQuery: () => getChannelOpeningTransactionQuery,
  getDepositQuery: () => getDepositQuery,
  getIncomingPaymentQuery: () => getIncomingPaymentQuery,
  getInvoiceQuery: () => getInvoiceQuery,
  getLightningTransactionQuery: () => getLightningTransactionQuery,
  getNodeQuery: () => getNodeQuery,
  getOnChainTransactionQuery: () => getOnChainTransactionQuery,
  getOutgoingPaymentQuery: () => getOutgoingPaymentQuery,
  getPaymentRequestQuery: () => getPaymentRequestQuery,
  getTransactionQuery: () => getTransactionQuery,
  getWithdrawalQuery: () => getWithdrawalQuery
});
module.exports = __toCommonJS(src_exports);

// src/auth/jwt/AccessTokenInfo.ts
function isParsedAccessTokenInfo(value) {
  return typeof value === "object" && value !== null && "accessToken" in value && typeof value.accessToken === "string" && "validUntil" in value && typeof value.validUntil === "string";
}

// src/auth/jwt/ChromeExtensionLocalTokenStorage.ts
var STORAGE_KEY = "lightspark-jwt";
var ChromeExtensionLocalTokenStorage = class {
  async getCurrent() {
    if (!chrome || !chrome.storage || !chrome.storage.local) {
      throw new Error(
        "Chrome extension local storage is not available in this environment."
      );
    }
    const tokenInfo = await chrome.storage.local.get([STORAGE_KEY]);
    if (tokenInfo === null) {
      return null;
    }
    if (isParsedAccessTokenInfo(tokenInfo)) {
      return {
        accessToken: tokenInfo.accessToken,
        validUntil: new Date(tokenInfo.validUntil)
      };
    }
    return null;
  }
  async replace(tokenInfo) {
    await chrome.storage.local.set({
      STORAGE_KEY: {
        accessToken: tokenInfo.accessToken,
        validUntil: tokenInfo.validUntil.toISOString()
      }
    });
  }
  async clear() {
    await chrome.storage.local.remove(STORAGE_KEY);
  }
};
var ChromeExtensionLocalTokenStorage_default = ChromeExtensionLocalTokenStorage;

// src/auth/jwt/CustomJwtAuthProvider.ts
var CustomJwtAuthProvider = class {
  constructor(tokenStorage) {
    this.tokenStorage = tokenStorage;
  }
  async setTokenInfo(tokenInfo) {
    await this.tokenStorage.replace(tokenInfo);
  }
  async logout() {
    await this.tokenStorage.clear();
  }
  async addAuthHeaders(headers) {
    const tokenInfo = await this.tokenStorage.getCurrent();
    if (!tokenInfo) {
      return headers;
    }
    return Object.assign({}, headers, {
      authorization: `Bearer ${tokenInfo.accessToken}`
    });
  }
  async isAuthorized() {
    const tokenInfo = await this.tokenStorage.getCurrent();
    if (!tokenInfo) {
      return false;
    }
    return tokenInfo.validUntil > /* @__PURE__ */ new Date();
  }
  async addWsConnectionParams(params) {
    const tokenInfo = await this.tokenStorage.getCurrent();
    if (!tokenInfo) {
      return params;
    }
    return Object.assign({}, params, {
      access_token: tokenInfo.accessToken
    });
  }
};
var CustomJwtAuthProvider_default = CustomJwtAuthProvider;

// src/auth/jwt/InMemoryTokenStorage.ts
var InMemoryTokenStorage = class {
  tokenInfo = null;
  getCurrent() {
    return Promise.resolve(this.tokenInfo);
  }
  replace(tokenInfo) {
    this.tokenInfo = tokenInfo;
    return Promise.resolve();
  }
  clear() {
    this.tokenInfo = null;
    return Promise.resolve();
  }
};
var InMemoryTokenStorage_default = InMemoryTokenStorage;

// src/client.ts
var import_core5 = require("@lightsparkdev/core");

// ../../node_modules/auto-bind/index.js
var getAllProperties = (object) => {
  const properties = /* @__PURE__ */ new Set();
  do {
    for (const key of Reflect.ownKeys(object)) {
      properties.add([object, key]);
    }
  } while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
  return properties;
};
function autoBind(self, { include, exclude } = {}) {
  const filter = (key) => {
    const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
    if (include) {
      return include.some(match);
    }
    if (exclude) {
      return !exclude.some(match);
    }
    return true;
  };
  for (const [object, key] of getAllProperties(self.constructor.prototype)) {
    if (key === "constructor" || !filter(key)) {
      continue;
    }
    const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
    if (descriptor && typeof descriptor.value === "function") {
      self[key] = self[key].bind(self);
    }
  }
  return self;
}

// package.json
var package_default = {
  name: "@lightsparkdev/wallet-sdk",
  version: "0.12.13",
  description: "Lightspark JS Wallet SDK",
  author: "Lightspark Inc.",
  keywords: [
    "lightspark",
    "bitcoin",
    "lightning",
    "payments",
    "typescript"
  ],
  homepage: "https://github.com/lightsparkdev/js-sdk",
  repository: {
    type: "git",
    url: "https://github.com/lightsparkdev/js-sdk.git"
  },
  bugs: {
    url: "https://github.com/lightsparkdev/js-sdk/issues"
  },
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      import: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      },
      require: {
        types: "./dist/index.d.ts",
        default: "./dist/index.cjs"
      }
    },
    "./env": {
      types: "./dist/env.d.ts",
      import: {
        types: "./dist/env.d.ts",
        default: "./dist/env.js"
      },
      module: "./dist/env.js",
      require: "./dist/env.cjs",
      default: "./dist/env.cjs"
    },
    "./objects": {
      types: "./dist/objects/index.d.ts",
      import: {
        types: "./dist/objects/index.d.ts",
        default: "./dist/objects/index.js"
      },
      require: {
        types: "./dist/objects/index.d.ts",
        default: "./dist/objects/index.cjs"
      }
    }
  },
  type: "module",
  types: "./dist/index.d.ts",
  main: "./dist/index.js",
  module: "./dist/index.js",
  browser: {
    crypto: false
  },
  files: [
    "src/*",
    "dist/*",
    "CHANGELOG.md"
  ],
  scripts: {
    build: "yarn tsc && tsup",
    "build:watch": "yarn build --watch --clean=false",
    clean: "rm -rf .turbo && rm -rf dist",
    dev: "yarn build -- --watch",
    docs: "typedoc --media docs-media src",
    "format:fix": "prettier src --write",
    format: "prettier src --check",
    "lint:fix": "eslint --fix .",
    "lint:fix:continue": "eslint --fix . || exit 0",
    "lint:watch": "esw ./src -w --ext .ts,.tsx,.js --color",
    lint: "eslint .",
    postversion: "yarn build",
    test: 'echo "TODO"',
    "test:integration": "node --experimental-vm-modules $(yarn bin jest) --no-cache --runInBand --bail",
    types: "tsc"
  },
  license: "Apache-2.0",
  dependencies: {
    "@lightsparkdev/core": "1.1.0",
    "@react-native-async-storage/async-storage": "^1.18.1",
    "crypto-browserify": "^3.12.0",
    dayjs: "^1.11.7",
    dotenv: "^16.3.1",
    graphql: "^16.6.0",
    "graphql-ws": "^5.11.3",
    react: "^18.2.0",
    ws: "^8.12.1",
    "zen-observable-ts": "^1.1.0"
  },
  devDependencies: {
    "@lightsparkdev/eslint-config": "*",
    "@types/chrome": "^0.0.254",
    "@types/crypto-js": "^4.1.1",
    "@types/ws": "^8.5.4",
    "auto-bind": "^5.0.1",
    eslint: "^8.3.0",
    "eslint-watch": "^8.0.0",
    jest: "^29.6.2",
    jsonwebtoken: "^9.0.1",
    prettier: "3.0.3",
    "prettier-plugin-organize-imports": "^3.2.4",
    "ts-jest": "^29.1.1",
    tsup: "^7.2.0",
    typedoc: "^0.24.7",
    typescript: "^5.0.0"
  },
  engines: {
    node: ">=18"
  }
};

// src/objects/CurrencyUnit.ts
var CurrencyUnit = /* @__PURE__ */ ((CurrencyUnit2) => {
  CurrencyUnit2["FUTURE_VALUE"] = "FUTURE_VALUE";
  CurrencyUnit2["BITCOIN"] = "BITCOIN";
  CurrencyUnit2["SATOSHI"] = "SATOSHI";
  CurrencyUnit2["MILLISATOSHI"] = "MILLISATOSHI";
  CurrencyUnit2["USD"] = "USD";
  CurrencyUnit2["NANOBITCOIN"] = "NANOBITCOIN";
  CurrencyUnit2["MICROBITCOIN"] = "MICROBITCOIN";
  CurrencyUnit2["MILLIBITCOIN"] = "MILLIBITCOIN";
  return CurrencyUnit2;
})(CurrencyUnit || {});
var CurrencyUnit_default = CurrencyUnit;

// src/objects/CurrencyAmount.ts
var CurrencyAmountFromJson = (obj) => {
  return {
    originalValue: obj["currency_amount_original_value"],
    originalUnit: CurrencyUnit_default[obj["currency_amount_original_unit"]] ?? CurrencyUnit_default.FUTURE_VALUE,
    preferredCurrencyUnit: CurrencyUnit_default[obj["currency_amount_preferred_currency_unit"]] ?? CurrencyUnit_default.FUTURE_VALUE,
    preferredCurrencyValueRounded: obj["currency_amount_preferred_currency_value_rounded"],
    preferredCurrencyValueApprox: obj["currency_amount_preferred_currency_value_approx"]
  };
};
var CurrencyAmountToJson = (obj) => {
  return {
    currency_amount_original_value: obj.originalValue,
    currency_amount_original_unit: obj.originalUnit,
    currency_amount_preferred_currency_unit: obj.preferredCurrencyUnit,
    currency_amount_preferred_currency_value_rounded: obj.preferredCurrencyValueRounded,
    currency_amount_preferred_currency_value_approx: obj.preferredCurrencyValueApprox
  };
};

// src/objects/FeeEstimate.ts
var FeeEstimateFromJson = (obj) => {
  return {
    feeFast: CurrencyAmountFromJson(obj["fee_estimate_fee_fast"]),
    feeMin: CurrencyAmountFromJson(obj["fee_estimate_fee_min"])
  };
};
var FRAGMENT = `
fragment FeeEstimateFragment on FeeEstimate {
    __typename
    fee_estimate_fee_fast: fee_fast {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    fee_estimate_fee_min: fee_min {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
}`;

// src/graqhql/BitcoinFeeEstimate.ts
var BitcoinFeeEstimateQuery = `
  query BitcoinFeeEstimate {
    bitcoin_fee_estimate {
      ...FeeEstimateFragment
    }
  }

  ${FRAGMENT}
`;
var BitcoinFeeEstimate_default = BitcoinFeeEstimateQuery;

// src/objects/BitcoinNetwork.ts
var BitcoinNetwork = /* @__PURE__ */ ((BitcoinNetwork2) => {
  BitcoinNetwork2["FUTURE_VALUE"] = "FUTURE_VALUE";
  BitcoinNetwork2["MAINNET"] = "MAINNET";
  BitcoinNetwork2["REGTEST"] = "REGTEST";
  BitcoinNetwork2["SIGNET"] = "SIGNET";
  BitcoinNetwork2["TESTNET"] = "TESTNET";
  return BitcoinNetwork2;
})(BitcoinNetwork || {});
var BitcoinNetwork_default = BitcoinNetwork;

// src/objects/NodeAddressType.ts
var NodeAddressType = /* @__PURE__ */ ((NodeAddressType2) => {
  NodeAddressType2["FUTURE_VALUE"] = "FUTURE_VALUE";
  NodeAddressType2["IPV4"] = "IPV4";
  NodeAddressType2["IPV6"] = "IPV6";
  NodeAddressType2["TOR"] = "TOR";
  return NodeAddressType2;
})(NodeAddressType || {});
var NodeAddressType_default = NodeAddressType;

// src/objects/NodeAddress.ts
var NodeAddressFromJson = (obj) => {
  return {
    address: obj["node_address_address"],
    type: NodeAddressType_default[obj["node_address_type"]] ?? NodeAddressType_default.FUTURE_VALUE
  };
};

// src/objects/NodeToAddressesConnection.ts
var NodeToAddressesConnectionFromJson = (obj) => {
  return {
    count: obj["node_to_addresses_connection_count"],
    entities: obj["node_to_addresses_connection_entities"].map(
      (e) => NodeAddressFromJson(e)
    )
  };
};

// src/objects/GraphNode.ts
var GraphNode = class {
  constructor(id, createdAt, updatedAt, bitcoinNetwork, displayName, typename, alias, color, conductivity, publicKey) {
    this.id = id;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.bitcoinNetwork = bitcoinNetwork;
    this.displayName = displayName;
    this.typename = typename;
    this.alias = alias;
    this.color = color;
    this.conductivity = conductivity;
    this.publicKey = publicKey;
    autoBind(this);
  }
  async getAddresses(client, first = void 0, types = void 0) {
    return await client.executeRawQuery({
      queryPayload: ` 
query FetchNodeToAddressesConnection($entity_id: ID!, $first: Int, $types: [NodeAddressType!]) {
    entity(id: $entity_id) {
        ... on GraphNode {
            addresses(, first: $first, types: $types) {
                __typename
                node_to_addresses_connection_count: count
                node_to_addresses_connection_entities: entities {
                    __typename
                    node_address_address: address
                    node_address_type: type
                }
            }
        }
    }
}
`,
      variables: { entity_id: this.id, first, types },
      constructObject: (json) => {
        const connection = json["entity"]["addresses"];
        return NodeToAddressesConnectionFromJson(connection);
      }
    });
  }
  static getGraphNodeQuery(id) {
    return {
      queryPayload: `
query GetGraphNode($id: ID!) {
    entity(id: $id) {
        ... on GraphNode {
            ...GraphNodeFragment
        }
    }
}

${FRAGMENT2}    
`,
      variables: { id },
      constructObject: (data) => GraphNodeFromJson(data.entity)
    };
  }
  toJson() {
    return {
      __typename: "GraphNode",
      graph_node_id: this.id,
      graph_node_created_at: this.createdAt,
      graph_node_updated_at: this.updatedAt,
      graph_node_alias: this.alias,
      graph_node_bitcoin_network: this.bitcoinNetwork,
      graph_node_color: this.color,
      graph_node_conductivity: this.conductivity,
      graph_node_display_name: this.displayName,
      graph_node_public_key: this.publicKey
    };
  }
};
var GraphNodeFromJson = (obj) => {
  return new GraphNode(
    obj["graph_node_id"],
    obj["graph_node_created_at"],
    obj["graph_node_updated_at"],
    BitcoinNetwork_default[obj["graph_node_bitcoin_network"]] ?? BitcoinNetwork_default.FUTURE_VALUE,
    obj["graph_node_display_name"],
    "GraphNode",
    obj["graph_node_alias"],
    obj["graph_node_color"],
    obj["graph_node_conductivity"],
    obj["graph_node_public_key"]
  );
};
var FRAGMENT2 = `
fragment GraphNodeFragment on GraphNode {
    __typename
    graph_node_id: id
    graph_node_created_at: created_at
    graph_node_updated_at: updated_at
    graph_node_alias: alias
    graph_node_bitcoin_network: bitcoin_network
    graph_node_color: color
    graph_node_conductivity: conductivity
    graph_node_display_name: display_name
    graph_node_public_key: public_key
}`;
var GraphNode_default = GraphNode;

// src/objects/InvoiceData.ts
var InvoiceDataFromJson = (obj) => {
  return {
    encodedPaymentRequest: obj["invoice_data_encoded_payment_request"],
    bitcoinNetwork: BitcoinNetwork_default[obj["invoice_data_bitcoin_network"]] ?? BitcoinNetwork_default.FUTURE_VALUE,
    paymentHash: obj["invoice_data_payment_hash"],
    amount: CurrencyAmountFromJson(obj["invoice_data_amount"]),
    createdAt: obj["invoice_data_created_at"],
    expiresAt: obj["invoice_data_expires_at"],
    destination: GraphNodeFromJson(obj["invoice_data_destination"]),
    typename: "InvoiceData",
    memo: obj["invoice_data_memo"]
  };
};
var FRAGMENT3 = `
fragment InvoiceDataFragment on InvoiceData {
    __typename
    invoice_data_encoded_payment_request: encoded_payment_request
    invoice_data_bitcoin_network: bitcoin_network
    invoice_data_payment_hash: payment_hash
    invoice_data_amount: amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    invoice_data_created_at: created_at
    invoice_data_expires_at: expires_at
    invoice_data_memo: memo
    invoice_data_destination: destination {
        __typename
        graph_node_id: id
        graph_node_created_at: created_at
        graph_node_updated_at: updated_at
        graph_node_alias: alias
        graph_node_bitcoin_network: bitcoin_network
        graph_node_color: color
        graph_node_conductivity: conductivity
        graph_node_display_name: display_name
        graph_node_public_key: public_key
    }
}`;

// src/objects/PaymentRequestStatus.ts
var PaymentRequestStatus = /* @__PURE__ */ ((PaymentRequestStatus2) => {
  PaymentRequestStatus2["FUTURE_VALUE"] = "FUTURE_VALUE";
  PaymentRequestStatus2["OPEN"] = "OPEN";
  PaymentRequestStatus2["CLOSED"] = "CLOSED";
  return PaymentRequestStatus2;
})(PaymentRequestStatus || {});
var PaymentRequestStatus_default = PaymentRequestStatus;

// src/objects/Invoice.ts
var InvoiceFromJson = (obj) => {
  return {
    id: obj["invoice_id"],
    createdAt: obj["invoice_created_at"],
    updatedAt: obj["invoice_updated_at"],
    data: InvoiceDataFromJson(obj["invoice_data"]),
    status: PaymentRequestStatus_default[obj["invoice_status"]] ?? PaymentRequestStatus_default.FUTURE_VALUE,
    typename: "Invoice",
    amountPaid: !!obj["invoice_amount_paid"] ? CurrencyAmountFromJson(obj["invoice_amount_paid"]) : void 0
  };
};
var FRAGMENT4 = `
fragment InvoiceFragment on Invoice {
    __typename
    invoice_id: id
    invoice_created_at: created_at
    invoice_updated_at: updated_at
    invoice_data: data {
        __typename
        invoice_data_encoded_payment_request: encoded_payment_request
        invoice_data_bitcoin_network: bitcoin_network
        invoice_data_payment_hash: payment_hash
        invoice_data_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        invoice_data_created_at: created_at
        invoice_data_expires_at: expires_at
        invoice_data_memo: memo
        invoice_data_destination: destination {
            __typename
            graph_node_id: id
            graph_node_created_at: created_at
            graph_node_updated_at: updated_at
            graph_node_alias: alias
            graph_node_bitcoin_network: bitcoin_network
            graph_node_color: color
            graph_node_conductivity: conductivity
            graph_node_display_name: display_name
            graph_node_public_key: public_key
        }
    }
    invoice_status: status
    invoice_amount_paid: amount_paid {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
}`;
var getInvoiceQuery = (id) => {
  return {
    queryPayload: `
query GetInvoice($id: ID!) {
    entity(id: $id) {
        ... on Invoice {
            ...InvoiceFragment
        }
    }
}

${FRAGMENT4}    
`,
    variables: { id },
    constructObject: (data) => InvoiceFromJson(data.entity)
  };
};

// src/graqhql/CancelInvoice.ts
var CancelInvoice = `
  mutation CancelInvoice(
    $invoice_id: ID!
  ) {
    cancel_invoice(input: { invoice_id: $invoice_id }) {
      invoice {
        ...InvoiceFragment
      }
    }
  }

  ${FRAGMENT4}
`;

// src/graqhql/CreateBitcoinFundingAddress.ts
var CreateBitcoinFundingAddress = `
  mutation CreateBitcoinFundingAddress {
    create_bitcoin_funding_address {
        bitcoin_address
    }
  }
`;
var CreateBitcoinFundingAddress_default = CreateBitcoinFundingAddress;

// src/graqhql/CreateInvoice.ts
var CreateInvoiceMutation = `
  mutation CreateInvoice(
    $amountMsats: Long!
    $memo: String
    $type: InvoiceType = null
    $expirySecs: Int = null
    ) {
    create_invoice(input: { amount_msats: $amountMsats, memo: $memo, invoice_type: $type, expiry_secs: $expirySecs }) {
      invoice {
        ...InvoiceFragment
      }
    }
  }
  
  ${FRAGMENT4}
`;
var CreateInvoice_default = CreateInvoiceMutation;

// src/graqhql/CreateTestModeInvoice.ts
var CreateTestModeInvoice = `
mutation CreateTestModeInvoice(
  $amount_msats: Long!
  $memo: String
  $invoice_type: InvoiceType
) {
  create_test_mode_invoice(input: {
      amount_msats: $amount_msats
      memo: $memo
      invoice_type: $invoice_type
  }) {
      encoded_payment_request
  }
}
`;
var CreateTestModeInvoice_default = CreateTestModeInvoice;

// src/objects/TransactionStatus.ts
var TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
  TransactionStatus2["FUTURE_VALUE"] = "FUTURE_VALUE";
  TransactionStatus2["SUCCESS"] = "SUCCESS";
  TransactionStatus2["FAILED"] = "FAILED";
  TransactionStatus2["PENDING"] = "PENDING";
  TransactionStatus2["NOT_STARTED"] = "NOT_STARTED";
  TransactionStatus2["EXPIRED"] = "EXPIRED";
  TransactionStatus2["CANCELLED"] = "CANCELLED";
  return TransactionStatus2;
})(TransactionStatus || {});
var TransactionStatus_default = TransactionStatus;

// src/objects/IncomingPayment.ts
var IncomingPaymentFromJson = (obj) => {
  return {
    id: obj["incoming_payment_id"],
    createdAt: obj["incoming_payment_created_at"],
    updatedAt: obj["incoming_payment_updated_at"],
    status: TransactionStatus_default[obj["incoming_payment_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
    amount: CurrencyAmountFromJson(obj["incoming_payment_amount"]),
    typename: "IncomingPayment",
    resolvedAt: obj["incoming_payment_resolved_at"],
    transactionHash: obj["incoming_payment_transaction_hash"],
    paymentRequestId: obj["incoming_payment_payment_request"]?.id ?? void 0
  };
};
var FRAGMENT5 = `
fragment IncomingPaymentFragment on IncomingPayment {
    __typename
    incoming_payment_id: id
    incoming_payment_created_at: created_at
    incoming_payment_updated_at: updated_at
    incoming_payment_status: status
    incoming_payment_resolved_at: resolved_at
    incoming_payment_amount: amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    incoming_payment_transaction_hash: transaction_hash
    incoming_payment_payment_request: payment_request {
        id
    }
}`;
var getIncomingPaymentQuery = (id) => {
  return {
    queryPayload: `
query GetIncomingPayment($id: ID!) {
    entity(id: $id) {
        ... on IncomingPayment {
            ...IncomingPaymentFragment
        }
    }
}

${FRAGMENT5}    
`,
    variables: { id },
    constructObject: (data) => IncomingPaymentFromJson(data.entity)
  };
};

// src/graqhql/CreateTestModePayment.ts
var CreateTestModePayment = `
mutation CreateTestModePayment(
  $encoded_invoice: String!
  $amount_msats: Long
) {
  create_test_mode_payment(input: {
      encoded_invoice: $encoded_invoice
      amount_msats: $amount_msats
  }) {
      incoming_payment {
          ...IncomingPaymentFragment
      }
  }
}

${FRAGMENT5}
`;
var CreateTestModePayment_default = CreateTestModePayment;

// src/objects/Balances.ts
var BalancesFromJson = (obj) => {
  return {
    ownedBalance: CurrencyAmountFromJson(obj["balances_owned_balance"]),
    availableToSendBalance: CurrencyAmountFromJson(
      obj["balances_available_to_send_balance"]
    ),
    availableToWithdrawBalance: CurrencyAmountFromJson(
      obj["balances_available_to_withdraw_balance"]
    )
  };
};
var BalancesToJson = (obj) => {
  return {
    balances_owned_balance: CurrencyAmountToJson(obj.ownedBalance),
    balances_available_to_send_balance: CurrencyAmountToJson(
      obj.availableToSendBalance
    ),
    balances_available_to_withdraw_balance: CurrencyAmountToJson(
      obj.availableToWithdrawBalance
    )
  };
};
var FRAGMENT6 = `
fragment BalancesFragment on Balances {
    __typename
    balances_owned_balance: owned_balance {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    balances_available_to_send_balance: available_to_send_balance {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    balances_available_to_withdraw_balance: available_to_withdraw_balance {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
}`;

// src/objects/WalletStatus.ts
var WalletStatus = /* @__PURE__ */ ((WalletStatus2) => {
  WalletStatus2["FUTURE_VALUE"] = "FUTURE_VALUE";
  WalletStatus2["NOT_SETUP"] = "NOT_SETUP";
  WalletStatus2["DEPLOYING"] = "DEPLOYING";
  WalletStatus2["DEPLOYED"] = "DEPLOYED";
  WalletStatus2["INITIALIZING"] = "INITIALIZING";
  WalletStatus2["READY"] = "READY";
  WalletStatus2["UNAVAILABLE"] = "UNAVAILABLE";
  WalletStatus2["FAILED"] = "FAILED";
  WalletStatus2["TERMINATING"] = "TERMINATING";
  WalletStatus2["TERMINATED"] = "TERMINATED";
  return WalletStatus2;
})(WalletStatus || {});
var WalletStatus_default = WalletStatus;

// src/objects/PageInfo.ts
var PageInfoFromJson = (obj) => {
  return {
    hasNextPage: obj["page_info_has_next_page"],
    hasPreviousPage: obj["page_info_has_previous_page"],
    startCursor: obj["page_info_start_cursor"],
    endCursor: obj["page_info_end_cursor"]
  };
};

// src/objects/PaymentRequest.ts
var import_core = require("@lightsparkdev/core");
var PaymentRequestFromJson = (obj) => {
  if (obj["__typename"] == "Invoice") {
    return {
      id: obj["invoice_id"],
      createdAt: obj["invoice_created_at"],
      updatedAt: obj["invoice_updated_at"],
      data: InvoiceDataFromJson(obj["invoice_data"]),
      status: PaymentRequestStatus_default[obj["invoice_status"]] ?? PaymentRequestStatus_default.FUTURE_VALUE,
      typename: "Invoice",
      amountPaid: !!obj["invoice_amount_paid"] ? CurrencyAmountFromJson(obj["invoice_amount_paid"]) : void 0
    };
  }
  throw new import_core.LightsparkException(
    "DeserializationError",
    `Couldn't find a concrete type for interface PaymentRequest corresponding to the typename=${obj["__typename"]}`
  );
};
var FRAGMENT7 = `
fragment PaymentRequestFragment on PaymentRequest {
    __typename
    ... on Invoice {
        __typename
        invoice_id: id
        invoice_created_at: created_at
        invoice_updated_at: updated_at
        invoice_data: data {
            __typename
            invoice_data_encoded_payment_request: encoded_payment_request
            invoice_data_bitcoin_network: bitcoin_network
            invoice_data_payment_hash: payment_hash
            invoice_data_amount: amount {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            invoice_data_created_at: created_at
            invoice_data_expires_at: expires_at
            invoice_data_memo: memo
            invoice_data_destination: destination {
                __typename
                graph_node_id: id
                graph_node_created_at: created_at
                graph_node_updated_at: updated_at
                graph_node_alias: alias
                graph_node_bitcoin_network: bitcoin_network
                graph_node_color: color
                graph_node_conductivity: conductivity
                graph_node_display_name: display_name
                graph_node_public_key: public_key
            }
        }
        invoice_status: status
        invoice_amount_paid: amount_paid {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
    }
}`;
var getPaymentRequestQuery = (id) => {
  return {
    queryPayload: `
query GetPaymentRequest($id: ID!) {
    entity(id: $id) {
        ... on PaymentRequest {
            ...PaymentRequestFragment
        }
    }
}

${FRAGMENT7}    
`,
    variables: { id },
    constructObject: (data) => PaymentRequestFromJson(data.entity)
  };
};

// src/objects/WalletToPaymentRequestsConnection.ts
var WalletToPaymentRequestsConnectionFromJson = (obj) => {
  return {
    count: obj["wallet_to_payment_requests_connection_count"],
    pageInfo: PageInfoFromJson(
      obj["wallet_to_payment_requests_connection_page_info"]
    ),
    entities: obj["wallet_to_payment_requests_connection_entities"].map(
      (e) => PaymentRequestFromJson(e)
    ),
    typename: "WalletToPaymentRequestsConnection"
  };
};

// src/objects/Transaction.ts
var import_core3 = require("@lightsparkdev/core");

// src/objects/PaymentFailureReason.ts
var PaymentFailureReason = /* @__PURE__ */ ((PaymentFailureReason2) => {
  PaymentFailureReason2["FUTURE_VALUE"] = "FUTURE_VALUE";
  PaymentFailureReason2["NONE"] = "NONE";
  PaymentFailureReason2["TIMEOUT"] = "TIMEOUT";
  PaymentFailureReason2["NO_ROUTE"] = "NO_ROUTE";
  PaymentFailureReason2["ERROR"] = "ERROR";
  PaymentFailureReason2["INCORRECT_PAYMENT_DETAILS"] = "INCORRECT_PAYMENT_DETAILS";
  PaymentFailureReason2["INSUFFICIENT_BALANCE"] = "INSUFFICIENT_BALANCE";
  PaymentFailureReason2["INVOICE_ALREADY_PAID"] = "INVOICE_ALREADY_PAID";
  PaymentFailureReason2["SELF_PAYMENT"] = "SELF_PAYMENT";
  PaymentFailureReason2["INVOICE_EXPIRED"] = "INVOICE_EXPIRED";
  PaymentFailureReason2["INVOICE_CANCELLED"] = "INVOICE_CANCELLED";
  PaymentFailureReason2["RISK_SCREENING_FAILED"] = "RISK_SCREENING_FAILED";
  PaymentFailureReason2["INSUFFICIENT_BALANCE_ON_SINGLE_PATH_INVOICE"] = "INSUFFICIENT_BALANCE_ON_SINGLE_PATH_INVOICE";
  return PaymentFailureReason2;
})(PaymentFailureReason || {});
var PaymentFailureReason_default = PaymentFailureReason;

// src/objects/PaymentRequestData.ts
var import_core2 = require("@lightsparkdev/core");
var PaymentRequestDataFromJson = (obj) => {
  if (obj["__typename"] == "InvoiceData") {
    return {
      encodedPaymentRequest: obj["invoice_data_encoded_payment_request"],
      bitcoinNetwork: BitcoinNetwork_default[obj["invoice_data_bitcoin_network"]] ?? BitcoinNetwork_default.FUTURE_VALUE,
      paymentHash: obj["invoice_data_payment_hash"],
      amount: CurrencyAmountFromJson(obj["invoice_data_amount"]),
      createdAt: obj["invoice_data_created_at"],
      expiresAt: obj["invoice_data_expires_at"],
      destination: GraphNodeFromJson(obj["invoice_data_destination"]),
      typename: "InvoiceData",
      memo: obj["invoice_data_memo"]
    };
  }
  throw new import_core2.LightsparkException(
    "DeserializationError",
    `Couldn't find a concrete type for interface PaymentRequestData corresponding to the typename=${obj["__typename"]}`
  );
};

// src/objects/RichText.ts
var RichTextFromJson = (obj) => {
  return {
    text: obj["rich_text_text"]
  };
};

// src/objects/Transaction.ts
var TransactionFromJson = (obj) => {
  if (obj["__typename"] == "ChannelClosingTransaction") {
    return {
      id: obj["channel_closing_transaction_id"],
      createdAt: obj["channel_closing_transaction_created_at"],
      updatedAt: obj["channel_closing_transaction_updated_at"],
      status: TransactionStatus_default[obj["channel_closing_transaction_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["channel_closing_transaction_amount"]),
      blockHeight: obj["channel_closing_transaction_block_height"],
      destinationAddresses: obj["channel_closing_transaction_destination_addresses"],
      typename: "ChannelClosingTransaction",
      resolvedAt: obj["channel_closing_transaction_resolved_at"],
      transactionHash: obj["channel_closing_transaction_transaction_hash"],
      fees: !!obj["channel_closing_transaction_fees"] ? CurrencyAmountFromJson(obj["channel_closing_transaction_fees"]) : void 0,
      blockHash: obj["channel_closing_transaction_block_hash"],
      numConfirmations: obj["channel_closing_transaction_num_confirmations"]
    };
  }
  if (obj["__typename"] == "ChannelOpeningTransaction") {
    return {
      id: obj["channel_opening_transaction_id"],
      createdAt: obj["channel_opening_transaction_created_at"],
      updatedAt: obj["channel_opening_transaction_updated_at"],
      status: TransactionStatus_default[obj["channel_opening_transaction_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["channel_opening_transaction_amount"]),
      blockHeight: obj["channel_opening_transaction_block_height"],
      destinationAddresses: obj["channel_opening_transaction_destination_addresses"],
      typename: "ChannelOpeningTransaction",
      resolvedAt: obj["channel_opening_transaction_resolved_at"],
      transactionHash: obj["channel_opening_transaction_transaction_hash"],
      fees: !!obj["channel_opening_transaction_fees"] ? CurrencyAmountFromJson(obj["channel_opening_transaction_fees"]) : void 0,
      blockHash: obj["channel_opening_transaction_block_hash"],
      numConfirmations: obj["channel_opening_transaction_num_confirmations"]
    };
  }
  if (obj["__typename"] == "Deposit") {
    return {
      id: obj["deposit_id"],
      createdAt: obj["deposit_created_at"],
      updatedAt: obj["deposit_updated_at"],
      status: TransactionStatus_default[obj["deposit_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["deposit_amount"]),
      blockHeight: obj["deposit_block_height"],
      destinationAddresses: obj["deposit_destination_addresses"],
      typename: "Deposit",
      resolvedAt: obj["deposit_resolved_at"],
      transactionHash: obj["deposit_transaction_hash"],
      fees: !!obj["deposit_fees"] ? CurrencyAmountFromJson(obj["deposit_fees"]) : void 0,
      blockHash: obj["deposit_block_hash"],
      numConfirmations: obj["deposit_num_confirmations"]
    };
  }
  if (obj["__typename"] == "IncomingPayment") {
    return {
      id: obj["incoming_payment_id"],
      createdAt: obj["incoming_payment_created_at"],
      updatedAt: obj["incoming_payment_updated_at"],
      status: TransactionStatus_default[obj["incoming_payment_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["incoming_payment_amount"]),
      typename: "IncomingPayment",
      resolvedAt: obj["incoming_payment_resolved_at"],
      transactionHash: obj["incoming_payment_transaction_hash"],
      paymentRequestId: obj["incoming_payment_payment_request"]?.id ?? void 0
    };
  }
  if (obj["__typename"] == "OutgoingPayment") {
    return {
      id: obj["outgoing_payment_id"],
      createdAt: obj["outgoing_payment_created_at"],
      updatedAt: obj["outgoing_payment_updated_at"],
      status: TransactionStatus_default[obj["outgoing_payment_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["outgoing_payment_amount"]),
      typename: "OutgoingPayment",
      resolvedAt: obj["outgoing_payment_resolved_at"],
      transactionHash: obj["outgoing_payment_transaction_hash"],
      fees: !!obj["outgoing_payment_fees"] ? CurrencyAmountFromJson(obj["outgoing_payment_fees"]) : void 0,
      paymentRequestData: !!obj["outgoing_payment_payment_request_data"] ? PaymentRequestDataFromJson(
        obj["outgoing_payment_payment_request_data"]
      ) : void 0,
      failureReason: !!obj["outgoing_payment_failure_reason"] ? PaymentFailureReason_default[obj["outgoing_payment_failure_reason"]] ?? PaymentFailureReason_default.FUTURE_VALUE : null,
      failureMessage: !!obj["outgoing_payment_failure_message"] ? RichTextFromJson(obj["outgoing_payment_failure_message"]) : void 0,
      paymentPreimage: obj["outgoing_payment_payment_preimage"]
    };
  }
  if (obj["__typename"] == "Withdrawal") {
    return {
      id: obj["withdrawal_id"],
      createdAt: obj["withdrawal_created_at"],
      updatedAt: obj["withdrawal_updated_at"],
      status: TransactionStatus_default[obj["withdrawal_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["withdrawal_amount"]),
      blockHeight: obj["withdrawal_block_height"],
      destinationAddresses: obj["withdrawal_destination_addresses"],
      typename: "Withdrawal",
      resolvedAt: obj["withdrawal_resolved_at"],
      transactionHash: obj["withdrawal_transaction_hash"],
      fees: !!obj["withdrawal_fees"] ? CurrencyAmountFromJson(obj["withdrawal_fees"]) : void 0,
      blockHash: obj["withdrawal_block_hash"],
      numConfirmations: obj["withdrawal_num_confirmations"]
    };
  }
  throw new import_core3.LightsparkException(
    "DeserializationError",
    `Couldn't find a concrete type for interface Transaction corresponding to the typename=${obj["__typename"]}`
  );
};
var FRAGMENT8 = `
fragment TransactionFragment on Transaction {
    __typename
    ... on ChannelClosingTransaction {
        __typename
        channel_closing_transaction_id: id
        channel_closing_transaction_created_at: created_at
        channel_closing_transaction_updated_at: updated_at
        channel_closing_transaction_status: status
        channel_closing_transaction_resolved_at: resolved_at
        channel_closing_transaction_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        channel_closing_transaction_transaction_hash: transaction_hash
        channel_closing_transaction_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        channel_closing_transaction_block_hash: block_hash
        channel_closing_transaction_block_height: block_height
        channel_closing_transaction_destination_addresses: destination_addresses
        channel_closing_transaction_num_confirmations: num_confirmations
    }
    ... on ChannelOpeningTransaction {
        __typename
        channel_opening_transaction_id: id
        channel_opening_transaction_created_at: created_at
        channel_opening_transaction_updated_at: updated_at
        channel_opening_transaction_status: status
        channel_opening_transaction_resolved_at: resolved_at
        channel_opening_transaction_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        channel_opening_transaction_transaction_hash: transaction_hash
        channel_opening_transaction_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        channel_opening_transaction_block_hash: block_hash
        channel_opening_transaction_block_height: block_height
        channel_opening_transaction_destination_addresses: destination_addresses
        channel_opening_transaction_num_confirmations: num_confirmations
    }
    ... on Deposit {
        __typename
        deposit_id: id
        deposit_created_at: created_at
        deposit_updated_at: updated_at
        deposit_status: status
        deposit_resolved_at: resolved_at
        deposit_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        deposit_transaction_hash: transaction_hash
        deposit_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        deposit_block_hash: block_hash
        deposit_block_height: block_height
        deposit_destination_addresses: destination_addresses
        deposit_num_confirmations: num_confirmations
    }
    ... on IncomingPayment {
        __typename
        incoming_payment_id: id
        incoming_payment_created_at: created_at
        incoming_payment_updated_at: updated_at
        incoming_payment_status: status
        incoming_payment_resolved_at: resolved_at
        incoming_payment_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        incoming_payment_transaction_hash: transaction_hash
        incoming_payment_payment_request: payment_request {
            id
        }
    }
    ... on OutgoingPayment {
        __typename
        outgoing_payment_id: id
        outgoing_payment_created_at: created_at
        outgoing_payment_updated_at: updated_at
        outgoing_payment_status: status
        outgoing_payment_resolved_at: resolved_at
        outgoing_payment_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        outgoing_payment_transaction_hash: transaction_hash
        outgoing_payment_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        outgoing_payment_payment_request_data: payment_request_data {
            __typename
            ... on InvoiceData {
                __typename
                invoice_data_encoded_payment_request: encoded_payment_request
                invoice_data_bitcoin_network: bitcoin_network
                invoice_data_payment_hash: payment_hash
                invoice_data_amount: amount {
                    __typename
                    currency_amount_original_value: original_value
                    currency_amount_original_unit: original_unit
                    currency_amount_preferred_currency_unit: preferred_currency_unit
                    currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                    currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                }
                invoice_data_created_at: created_at
                invoice_data_expires_at: expires_at
                invoice_data_memo: memo
                invoice_data_destination: destination {
                    __typename
                    graph_node_id: id
                    graph_node_created_at: created_at
                    graph_node_updated_at: updated_at
                    graph_node_alias: alias
                    graph_node_bitcoin_network: bitcoin_network
                    graph_node_color: color
                    graph_node_conductivity: conductivity
                    graph_node_display_name: display_name
                    graph_node_public_key: public_key
                }
            }
        }
        outgoing_payment_failure_reason: failure_reason
        outgoing_payment_failure_message: failure_message {
            __typename
            rich_text_text: text
        }
        outgoing_payment_payment_preimage: payment_preimage
    }
    ... on Withdrawal {
        __typename
        withdrawal_id: id
        withdrawal_created_at: created_at
        withdrawal_updated_at: updated_at
        withdrawal_status: status
        withdrawal_resolved_at: resolved_at
        withdrawal_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        withdrawal_transaction_hash: transaction_hash
        withdrawal_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        withdrawal_block_hash: block_hash
        withdrawal_block_height: block_height
        withdrawal_destination_addresses: destination_addresses
        withdrawal_num_confirmations: num_confirmations
    }
}`;
var getTransactionQuery = (id) => {
  return {
    queryPayload: `
query GetTransaction($id: ID!) {
    entity(id: $id) {
        ... on Transaction {
            ...TransactionFragment
        }
    }
}

${FRAGMENT8}    
`,
    variables: { id },
    constructObject: (data) => TransactionFromJson(data.entity)
  };
};

// src/objects/WalletToTransactionsConnection.ts
var WalletToTransactionsConnectionFromJson = (obj) => {
  return {
    count: obj["wallet_to_transactions_connection_count"],
    pageInfo: PageInfoFromJson(
      obj["wallet_to_transactions_connection_page_info"]
    ),
    entities: obj["wallet_to_transactions_connection_entities"].map(
      (e) => TransactionFromJson(e)
    ),
    typename: "WalletToTransactionsConnection"
  };
};

// src/objects/WithdrawalRequestStatus.ts
var WithdrawalRequestStatus = /* @__PURE__ */ ((WithdrawalRequestStatus2) => {
  WithdrawalRequestStatus2["FUTURE_VALUE"] = "FUTURE_VALUE";
  WithdrawalRequestStatus2["CREATING"] = "CREATING";
  WithdrawalRequestStatus2["CREATED"] = "CREATED";
  WithdrawalRequestStatus2["FAILED"] = "FAILED";
  WithdrawalRequestStatus2["IN_PROGRESS"] = "IN_PROGRESS";
  WithdrawalRequestStatus2["SUCCESSFUL"] = "SUCCESSFUL";
  WithdrawalRequestStatus2["PARTIALLY_SUCCESSFUL"] = "PARTIALLY_SUCCESSFUL";
  return WithdrawalRequestStatus2;
})(WithdrawalRequestStatus || {});
var WithdrawalRequestStatus_default = WithdrawalRequestStatus;

// src/objects/Withdrawal.ts
var WithdrawalFromJson = (obj) => {
  return {
    id: obj["withdrawal_id"],
    createdAt: obj["withdrawal_created_at"],
    updatedAt: obj["withdrawal_updated_at"],
    status: TransactionStatus_default[obj["withdrawal_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
    amount: CurrencyAmountFromJson(obj["withdrawal_amount"]),
    blockHeight: obj["withdrawal_block_height"],
    destinationAddresses: obj["withdrawal_destination_addresses"],
    typename: "Withdrawal",
    resolvedAt: obj["withdrawal_resolved_at"],
    transactionHash: obj["withdrawal_transaction_hash"],
    fees: !!obj["withdrawal_fees"] ? CurrencyAmountFromJson(obj["withdrawal_fees"]) : void 0,
    blockHash: obj["withdrawal_block_hash"],
    numConfirmations: obj["withdrawal_num_confirmations"]
  };
};
var FRAGMENT9 = `
fragment WithdrawalFragment on Withdrawal {
    __typename
    withdrawal_id: id
    withdrawal_created_at: created_at
    withdrawal_updated_at: updated_at
    withdrawal_status: status
    withdrawal_resolved_at: resolved_at
    withdrawal_amount: amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_transaction_hash: transaction_hash
    withdrawal_fees: fees {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_block_hash: block_hash
    withdrawal_block_height: block_height
    withdrawal_destination_addresses: destination_addresses
    withdrawal_num_confirmations: num_confirmations
}`;
var getWithdrawalQuery = (id) => {
  return {
    queryPayload: `
query GetWithdrawal($id: ID!) {
    entity(id: $id) {
        ... on Withdrawal {
            ...WithdrawalFragment
        }
    }
}

${FRAGMENT9}    
`,
    variables: { id },
    constructObject: (data) => WithdrawalFromJson(data.entity)
  };
};

// src/objects/WithdrawalRequestToWithdrawalsConnection.ts
var WithdrawalRequestToWithdrawalsConnectionFromJson = (obj) => {
  return {
    count: obj["withdrawal_request_to_withdrawals_connection_count"],
    entities: obj["withdrawal_request_to_withdrawals_connection_entities"].map(
      (e) => WithdrawalFromJson(e)
    )
  };
};

// src/objects/WithdrawalRequest.ts
var WithdrawalRequest = class {
  constructor(id, createdAt, updatedAt, requestedAmount, amount, bitcoinAddress, status, typename, estimatedAmount, amountWithdrawn, totalFees, completedAt, withdrawalId) {
    this.id = id;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.requestedAmount = requestedAmount;
    this.amount = amount;
    this.bitcoinAddress = bitcoinAddress;
    this.status = status;
    this.typename = typename;
    this.estimatedAmount = estimatedAmount;
    this.amountWithdrawn = amountWithdrawn;
    this.totalFees = totalFees;
    this.completedAt = completedAt;
    this.withdrawalId = withdrawalId;
    autoBind(this);
  }
  async getWithdrawals(client, first = void 0) {
    return await client.executeRawQuery({
      queryPayload: ` 
query FetchWithdrawalRequestToWithdrawalsConnection($entity_id: ID!, $first: Int) {
    entity(id: $entity_id) {
        ... on WithdrawalRequest {
            withdrawals(, first: $first) {
                __typename
                withdrawal_request_to_withdrawals_connection_count: count
                withdrawal_request_to_withdrawals_connection_entities: entities {
                    __typename
                    withdrawal_id: id
                    withdrawal_created_at: created_at
                    withdrawal_updated_at: updated_at
                    withdrawal_status: status
                    withdrawal_resolved_at: resolved_at
                    withdrawal_amount: amount {
                        __typename
                        currency_amount_original_value: original_value
                        currency_amount_original_unit: original_unit
                        currency_amount_preferred_currency_unit: preferred_currency_unit
                        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                    }
                    withdrawal_transaction_hash: transaction_hash
                    withdrawal_fees: fees {
                        __typename
                        currency_amount_original_value: original_value
                        currency_amount_original_unit: original_unit
                        currency_amount_preferred_currency_unit: preferred_currency_unit
                        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                    }
                    withdrawal_block_hash: block_hash
                    withdrawal_block_height: block_height
                    withdrawal_destination_addresses: destination_addresses
                    withdrawal_num_confirmations: num_confirmations
                }
            }
        }
    }
}
`,
      variables: { entity_id: this.id, first },
      constructObject: (json) => {
        const connection = json["entity"]["withdrawals"];
        return WithdrawalRequestToWithdrawalsConnectionFromJson(connection);
      }
    });
  }
  static getWithdrawalRequestQuery(id) {
    return {
      queryPayload: `
query GetWithdrawalRequest($id: ID!) {
    entity(id: $id) {
        ... on WithdrawalRequest {
            ...WithdrawalRequestFragment
        }
    }
}

${FRAGMENT10}    
`,
      variables: { id },
      constructObject: (data) => WithdrawalRequestFromJson(data.entity)
    };
  }
  toJson() {
    return {
      __typename: "WithdrawalRequest",
      withdrawal_request_id: this.id,
      withdrawal_request_created_at: this.createdAt,
      withdrawal_request_updated_at: this.updatedAt,
      withdrawal_request_requested_amount: CurrencyAmountToJson(
        this.requestedAmount
      ),
      withdrawal_request_amount: CurrencyAmountToJson(this.amount),
      withdrawal_request_estimated_amount: this.estimatedAmount ? CurrencyAmountToJson(this.estimatedAmount) : void 0,
      withdrawal_request_amount_withdrawn: this.amountWithdrawn ? CurrencyAmountToJson(this.amountWithdrawn) : void 0,
      withdrawal_request_total_fees: this.totalFees ? CurrencyAmountToJson(this.totalFees) : void 0,
      withdrawal_request_bitcoin_address: this.bitcoinAddress,
      withdrawal_request_status: this.status,
      withdrawal_request_completed_at: this.completedAt,
      withdrawal_request_withdrawal: { id: this.withdrawalId }
    };
  }
};
var WithdrawalRequestFromJson = (obj) => {
  return new WithdrawalRequest(
    obj["withdrawal_request_id"],
    obj["withdrawal_request_created_at"],
    obj["withdrawal_request_updated_at"],
    CurrencyAmountFromJson(obj["withdrawal_request_requested_amount"]),
    CurrencyAmountFromJson(obj["withdrawal_request_amount"]),
    obj["withdrawal_request_bitcoin_address"],
    WithdrawalRequestStatus_default[obj["withdrawal_request_status"]] ?? WithdrawalRequestStatus_default.FUTURE_VALUE,
    "WithdrawalRequest",
    !!obj["withdrawal_request_estimated_amount"] ? CurrencyAmountFromJson(obj["withdrawal_request_estimated_amount"]) : void 0,
    !!obj["withdrawal_request_amount_withdrawn"] ? CurrencyAmountFromJson(obj["withdrawal_request_amount_withdrawn"]) : void 0,
    !!obj["withdrawal_request_total_fees"] ? CurrencyAmountFromJson(obj["withdrawal_request_total_fees"]) : void 0,
    obj["withdrawal_request_completed_at"],
    obj["withdrawal_request_withdrawal"]?.id ?? void 0
  );
};
var FRAGMENT10 = `
fragment WithdrawalRequestFragment on WithdrawalRequest {
    __typename
    withdrawal_request_id: id
    withdrawal_request_created_at: created_at
    withdrawal_request_updated_at: updated_at
    withdrawal_request_requested_amount: requested_amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_request_amount: amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_request_estimated_amount: estimated_amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_request_amount_withdrawn: amount_withdrawn {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_request_total_fees: total_fees {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_request_bitcoin_address: bitcoin_address
    withdrawal_request_status: status
    withdrawal_request_completed_at: completed_at
    withdrawal_request_withdrawal: withdrawal {
        id
    }
}`;
var WithdrawalRequest_default = WithdrawalRequest;

// src/objects/WalletToWithdrawalRequestsConnection.ts
var WalletToWithdrawalRequestsConnectionFromJson = (obj) => {
  return {
    count: obj["wallet_to_withdrawal_requests_connection_count"],
    pageInfo: PageInfoFromJson(
      obj["wallet_to_withdrawal_requests_connection_page_info"]
    ),
    entities: obj["wallet_to_withdrawal_requests_connection_entities"].map(
      (e) => WithdrawalRequestFromJson(e)
    ),
    typename: "WalletToWithdrawalRequestsConnection"
  };
};

// src/objects/Wallet.ts
var Wallet = class {
  constructor(id, createdAt, updatedAt, status, typename, balances) {
    this.id = id;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.status = status;
    this.typename = typename;
    this.balances = balances;
    autoBind(this);
  }
  async getTransactions(client, first = void 0, after = void 0, createdAfterDate = void 0, createdBeforeDate = void 0, statuses = void 0, types = void 0) {
    return await client.executeRawQuery({
      queryPayload: ` 
query FetchWalletToTransactionsConnection($first: Int, $after: ID, $created_after_date: DateTime, $created_before_date: DateTime, $statuses: [TransactionStatus!], $types: [TransactionType!]) {
    current_wallet {
        ... on Wallet {
            transactions(, first: $first, after: $after, created_after_date: $created_after_date, created_before_date: $created_before_date, statuses: $statuses, types: $types) {
                __typename
                wallet_to_transactions_connection_count: count
                wallet_to_transactions_connection_page_info: page_info {
                    __typename
                    page_info_has_next_page: has_next_page
                    page_info_has_previous_page: has_previous_page
                    page_info_start_cursor: start_cursor
                    page_info_end_cursor: end_cursor
                }
                wallet_to_transactions_connection_entities: entities {
                    __typename
                    ... on ChannelClosingTransaction {
                        __typename
                        channel_closing_transaction_id: id
                        channel_closing_transaction_created_at: created_at
                        channel_closing_transaction_updated_at: updated_at
                        channel_closing_transaction_status: status
                        channel_closing_transaction_resolved_at: resolved_at
                        channel_closing_transaction_amount: amount {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        channel_closing_transaction_transaction_hash: transaction_hash
                        channel_closing_transaction_fees: fees {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        channel_closing_transaction_block_hash: block_hash
                        channel_closing_transaction_block_height: block_height
                        channel_closing_transaction_destination_addresses: destination_addresses
                        channel_closing_transaction_num_confirmations: num_confirmations
                    }
                    ... on ChannelOpeningTransaction {
                        __typename
                        channel_opening_transaction_id: id
                        channel_opening_transaction_created_at: created_at
                        channel_opening_transaction_updated_at: updated_at
                        channel_opening_transaction_status: status
                        channel_opening_transaction_resolved_at: resolved_at
                        channel_opening_transaction_amount: amount {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        channel_opening_transaction_transaction_hash: transaction_hash
                        channel_opening_transaction_fees: fees {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        channel_opening_transaction_block_hash: block_hash
                        channel_opening_transaction_block_height: block_height
                        channel_opening_transaction_destination_addresses: destination_addresses
                        channel_opening_transaction_num_confirmations: num_confirmations
                    }
                    ... on Deposit {
                        __typename
                        deposit_id: id
                        deposit_created_at: created_at
                        deposit_updated_at: updated_at
                        deposit_status: status
                        deposit_resolved_at: resolved_at
                        deposit_amount: amount {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        deposit_transaction_hash: transaction_hash
                        deposit_fees: fees {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        deposit_block_hash: block_hash
                        deposit_block_height: block_height
                        deposit_destination_addresses: destination_addresses
                        deposit_num_confirmations: num_confirmations
                    }
                    ... on IncomingPayment {
                        __typename
                        incoming_payment_id: id
                        incoming_payment_created_at: created_at
                        incoming_payment_updated_at: updated_at
                        incoming_payment_status: status
                        incoming_payment_resolved_at: resolved_at
                        incoming_payment_amount: amount {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        incoming_payment_transaction_hash: transaction_hash
                        incoming_payment_payment_request: payment_request {
                            id
                        }
                    }
                    ... on OutgoingPayment {
                        __typename
                        outgoing_payment_id: id
                        outgoing_payment_created_at: created_at
                        outgoing_payment_updated_at: updated_at
                        outgoing_payment_status: status
                        outgoing_payment_resolved_at: resolved_at
                        outgoing_payment_amount: amount {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        outgoing_payment_transaction_hash: transaction_hash
                        outgoing_payment_fees: fees {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        outgoing_payment_payment_request_data: payment_request_data {
                            __typename
                            ... on InvoiceData {
                                __typename
                                invoice_data_encoded_payment_request: encoded_payment_request
                                invoice_data_bitcoin_network: bitcoin_network
                                invoice_data_payment_hash: payment_hash
                                invoice_data_amount: amount {
                                    __typename
                                    currency_amount_original_value: original_value
                                    currency_amount_original_unit: original_unit
                                    currency_amount_preferred_currency_unit: preferred_currency_unit
                                    currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                                    currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                                }
                                invoice_data_created_at: created_at
                                invoice_data_expires_at: expires_at
                                invoice_data_memo: memo
                                invoice_data_destination: destination {
                                    __typename
                                    graph_node_id: id
                                    graph_node_created_at: created_at
                                    graph_node_updated_at: updated_at
                                    graph_node_alias: alias
                                    graph_node_bitcoin_network: bitcoin_network
                                    graph_node_color: color
                                    graph_node_conductivity: conductivity
                                    graph_node_display_name: display_name
                                    graph_node_public_key: public_key
                                }
                            }
                        }
                        outgoing_payment_failure_reason: failure_reason
                        outgoing_payment_failure_message: failure_message {
                            __typename
                            rich_text_text: text
                        }
                        outgoing_payment_payment_preimage: payment_preimage
                    }
                    ... on Withdrawal {
                        __typename
                        withdrawal_id: id
                        withdrawal_created_at: created_at
                        withdrawal_updated_at: updated_at
                        withdrawal_status: status
                        withdrawal_resolved_at: resolved_at
                        withdrawal_amount: amount {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        withdrawal_transaction_hash: transaction_hash
                        withdrawal_fees: fees {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                        withdrawal_block_hash: block_hash
                        withdrawal_block_height: block_height
                        withdrawal_destination_addresses: destination_addresses
                        withdrawal_num_confirmations: num_confirmations
                    }
                }
            }
        }
    }
}
`,
      variables: {
        first,
        after,
        created_after_date: createdAfterDate,
        created_before_date: createdBeforeDate,
        statuses,
        types
      },
      constructObject: (json) => {
        const connection = json["current_wallet"]["transactions"];
        return WalletToTransactionsConnectionFromJson(connection);
      }
    });
  }
  async getPaymentRequests(client, first = void 0, after = void 0, createdAfterDate = void 0, createdBeforeDate = void 0) {
    return await client.executeRawQuery({
      queryPayload: ` 
query FetchWalletToPaymentRequestsConnection($first: Int, $after: ID, $created_after_date: DateTime, $created_before_date: DateTime) {
    current_wallet {
        ... on Wallet {
            payment_requests(, first: $first, after: $after, created_after_date: $created_after_date, created_before_date: $created_before_date) {
                __typename
                wallet_to_payment_requests_connection_count: count
                wallet_to_payment_requests_connection_page_info: page_info {
                    __typename
                    page_info_has_next_page: has_next_page
                    page_info_has_previous_page: has_previous_page
                    page_info_start_cursor: start_cursor
                    page_info_end_cursor: end_cursor
                }
                wallet_to_payment_requests_connection_entities: entities {
                    __typename
                    ... on Invoice {
                        __typename
                        invoice_id: id
                        invoice_created_at: created_at
                        invoice_updated_at: updated_at
                        invoice_data: data {
                            __typename
                            invoice_data_encoded_payment_request: encoded_payment_request
                            invoice_data_bitcoin_network: bitcoin_network
                            invoice_data_payment_hash: payment_hash
                            invoice_data_amount: amount {
                                __typename
                                currency_amount_original_value: original_value
                                currency_amount_original_unit: original_unit
                                currency_amount_preferred_currency_unit: preferred_currency_unit
                                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                            }
                            invoice_data_created_at: created_at
                            invoice_data_expires_at: expires_at
                            invoice_data_memo: memo
                            invoice_data_destination: destination {
                                __typename
                                graph_node_id: id
                                graph_node_created_at: created_at
                                graph_node_updated_at: updated_at
                                graph_node_alias: alias
                                graph_node_bitcoin_network: bitcoin_network
                                graph_node_color: color
                                graph_node_conductivity: conductivity
                                graph_node_display_name: display_name
                                graph_node_public_key: public_key
                            }
                        }
                        invoice_status: status
                        invoice_amount_paid: amount_paid {
                            __typename
                            currency_amount_original_value: original_value
                            currency_amount_original_unit: original_unit
                            currency_amount_preferred_currency_unit: preferred_currency_unit
                            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                        }
                    }
                }
            }
        }
    }
}
`,
      variables: {
        first,
        after,
        created_after_date: createdAfterDate,
        created_before_date: createdBeforeDate
      },
      constructObject: (json) => {
        const connection = json["current_wallet"]["payment_requests"];
        return WalletToPaymentRequestsConnectionFromJson(connection);
      }
    });
  }
  async getWithdrawalRequests(client, first = void 0, after = void 0, statuses = void 0, createdAfterDate = void 0, createdBeforeDate = void 0) {
    return await client.executeRawQuery({
      queryPayload: ` 
query FetchWalletToWithdrawalRequestsConnection($first: Int, $after: ID, $statuses: [WithdrawalRequestStatus!], $created_after_date: DateTime, $created_before_date: DateTime) {
    current_wallet {
        ... on Wallet {
            withdrawal_requests(, first: $first, after: $after, statuses: $statuses, created_after_date: $created_after_date, created_before_date: $created_before_date) {
                __typename
                wallet_to_withdrawal_requests_connection_count: count
                wallet_to_withdrawal_requests_connection_page_info: page_info {
                    __typename
                    page_info_has_next_page: has_next_page
                    page_info_has_previous_page: has_previous_page
                    page_info_start_cursor: start_cursor
                    page_info_end_cursor: end_cursor
                }
                wallet_to_withdrawal_requests_connection_entities: entities {
                    __typename
                    withdrawal_request_id: id
                    withdrawal_request_created_at: created_at
                    withdrawal_request_updated_at: updated_at
                    withdrawal_request_requested_amount: requested_amount {
                        __typename
                        currency_amount_original_value: original_value
                        currency_amount_original_unit: original_unit
                        currency_amount_preferred_currency_unit: preferred_currency_unit
                        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                    }
                    withdrawal_request_amount: amount {
                        __typename
                        currency_amount_original_value: original_value
                        currency_amount_original_unit: original_unit
                        currency_amount_preferred_currency_unit: preferred_currency_unit
                        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                    }
                    withdrawal_request_estimated_amount: estimated_amount {
                        __typename
                        currency_amount_original_value: original_value
                        currency_amount_original_unit: original_unit
                        currency_amount_preferred_currency_unit: preferred_currency_unit
                        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                    }
                    withdrawal_request_amount_withdrawn: amount_withdrawn {
                        __typename
                        currency_amount_original_value: original_value
                        currency_amount_original_unit: original_unit
                        currency_amount_preferred_currency_unit: preferred_currency_unit
                        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                    }
                    withdrawal_request_total_fees: total_fees {
                        __typename
                        currency_amount_original_value: original_value
                        currency_amount_original_unit: original_unit
                        currency_amount_preferred_currency_unit: preferred_currency_unit
                        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                    }
                    withdrawal_request_bitcoin_address: bitcoin_address
                    withdrawal_request_status: status
                    withdrawal_request_completed_at: completed_at
                    withdrawal_request_withdrawal: withdrawal {
                        id
                    }
                }
            }
        }
    }
}
`,
      variables: {
        first,
        after,
        statuses,
        created_after_date: createdAfterDate,
        created_before_date: createdBeforeDate
      },
      constructObject: (json) => {
        const connection = json["current_wallet"]["withdrawal_requests"];
        return WalletToWithdrawalRequestsConnectionFromJson(connection);
      }
    });
  }
  static getWalletQuery() {
    return {
      queryPayload: `
query GetWallet {
    current_wallet {
        ... on Wallet {
            ...WalletFragment
        }
    }
}

${FRAGMENT11}    
`,
      variables: {},
      constructObject: (data) => WalletFromJson(data.current_wallet)
    };
  }
  toJson() {
    return {
      __typename: "Wallet",
      wallet_id: this.id,
      wallet_created_at: this.createdAt,
      wallet_updated_at: this.updatedAt,
      wallet_balances: this.balances ? BalancesToJson(this.balances) : void 0,
      wallet_status: this.status
    };
  }
};
var WalletFromJson = (obj) => {
  return new Wallet(
    obj["wallet_id"],
    obj["wallet_created_at"],
    obj["wallet_updated_at"],
    WalletStatus_default[obj["wallet_status"]] ?? WalletStatus_default.FUTURE_VALUE,
    "Wallet",
    !!obj["wallet_balances"] ? BalancesFromJson(obj["wallet_balances"]) : void 0
  );
};
var FRAGMENT11 = `
fragment WalletFragment on Wallet {
    __typename
    wallet_id: id
    wallet_created_at: created_at
    wallet_updated_at: updated_at
    wallet_balances: balances {
        __typename
        balances_owned_balance: owned_balance {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        balances_available_to_send_balance: available_to_send_balance {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        balances_available_to_withdraw_balance: available_to_withdraw_balance {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
    }
    wallet_status: status
}`;
var Wallet_default = Wallet;

// src/graqhql/CurrentWallet.ts
var CurrentWalletQuery = `
query CurrentWallet {
    current_wallet {
        ...WalletFragment
    }
}

${FRAGMENT11}
`;
var CurrentWallet_default = CurrentWalletQuery;

// src/graqhql/DecodeInvoice.ts
var DecodeInvoiceQuery = `
  query DecodeInvoice($encoded_payment_request: String!) {
    decoded_payment_request(encoded_payment_request: $encoded_payment_request) {
      __typename
      ... on InvoiceData {
        ...InvoiceDataFragment
      }
    }
  }

${FRAGMENT3}
`;
var DecodeInvoice_default = DecodeInvoiceQuery;

// src/objects/DeployWalletOutput.ts
var DeployWalletOutputFromJson = (obj) => {
  return {
    wallet: WalletFromJson(obj["deploy_wallet_output_wallet"])
  };
};
var FRAGMENT12 = `
fragment DeployWalletOutputFragment on DeployWalletOutput {
    __typename
    deploy_wallet_output_wallet: wallet {
        __typename
        wallet_id: id
        wallet_created_at: created_at
        wallet_updated_at: updated_at
        wallet_balances: balances {
            __typename
            balances_owned_balance: owned_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            balances_available_to_send_balance: available_to_send_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            balances_available_to_withdraw_balance: available_to_withdraw_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
        }
        wallet_status: status
    }
}`;

// src/graqhql/DeployWallet.ts
var DeployWallet = `
  mutation DeployWallet {
    deploy_wallet {
      ...DeployWalletOutputFragment
    }
  }
  
  ${FRAGMENT12}
`;
var DeployWallet_default = DeployWallet;

// src/objects/InitializeWalletOutput.ts
var InitializeWalletOutputFromJson = (obj) => {
  return {
    wallet: WalletFromJson(obj["initialize_wallet_output_wallet"])
  };
};
var FRAGMENT13 = `
fragment InitializeWalletOutputFragment on InitializeWalletOutput {
    __typename
    initialize_wallet_output_wallet: wallet {
        __typename
        wallet_id: id
        wallet_created_at: created_at
        wallet_updated_at: updated_at
        wallet_balances: balances {
            __typename
            balances_owned_balance: owned_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            balances_available_to_send_balance: available_to_send_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            balances_available_to_withdraw_balance: available_to_withdraw_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
        }
        wallet_status: status
    }
}`;

// src/graqhql/InitializeWallet.ts
var InitializeWallet = `
  mutation InitializeWallet($key_type: KeyType!, $signing_public_key: String!) {
    initialize_wallet(input: {
        signing_public_key: { type: $key_type, public_key: $signing_public_key }
    }) {
        ...InitializeWalletOutputFragment
    }
  }

  ${FRAGMENT13}
`;
var InitializeWallet_default = InitializeWallet;

// src/objects/LightningFeeEstimateOutput.ts
var FRAGMENT14 = `
fragment LightningFeeEstimateOutputFragment on LightningFeeEstimateOutput {
    __typename
    lightning_fee_estimate_output_fee_estimate: fee_estimate {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
}`;

// src/graqhql/LightningFeeEstimateForInvoice.ts
var LightningFeeEstimateForInvoiceQuery = `
  query LightningFeeEstimateForInvoice(
    $encoded_payment_request: String!
    $amount_msats: Long
  ) {
    lightning_fee_estimate_for_invoice(input: {
      encoded_payment_request: $encoded_payment_request,
      amount_msats: $amount_msats
    }) {
      ...LightningFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT14}
`;
var LightningFeeEstimateForInvoice_default = LightningFeeEstimateForInvoiceQuery;

// src/graqhql/LightningFeeEstimateForNode.ts
var LightningFeeEstimateForNodeQuery = `
  query LightningFeeEstimateForNode(
    $destination_node_public_key: String!
    $amount_msats: Long!
  ) {
    lightning_fee_estimate_for_node(input: {
      destination_node_public_key: $destination_node_public_key,
      amount_msats: $amount_msats
    }) {
      ...LightningFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT14}
`;
var LightningFeeEstimateForNode_default = LightningFeeEstimateForNodeQuery;

// src/objects/LoginWithJWTOutput.ts
var LoginWithJWTOutputFromJson = (obj) => {
  return {
    accessToken: obj["login_with_j_w_t_output_access_token"],
    wallet: WalletFromJson(obj["login_with_j_w_t_output_wallet"]),
    validUntil: obj["login_with_j_w_t_output_valid_until"]
  };
};
var FRAGMENT15 = `
fragment LoginWithJWTOutputFragment on LoginWithJWTOutput {
    __typename
    login_with_j_w_t_output_access_token: access_token
    login_with_j_w_t_output_wallet: wallet {
        __typename
        wallet_id: id
        wallet_created_at: created_at
        wallet_updated_at: updated_at
        wallet_balances: balances {
            __typename
            balances_owned_balance: owned_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            balances_available_to_send_balance: available_to_send_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            balances_available_to_withdraw_balance: available_to_withdraw_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
        }
        wallet_status: status
    }
    login_with_j_w_t_output_valid_until: valid_until
}`;

// src/graqhql/LoginWithJWT.ts
var LoginWithJWT = `
  mutation LoginWithJWT($account_id: ID!, $jwt: String!) {
    login_with_jwt(input: { account_id: $account_id, jwt: $jwt }) {
        ...LoginWithJWTOutputFragment
    }
  }

  ${FRAGMENT15}
`;
var LoginWithJWT_default = LoginWithJWT;

// src/objects/OutgoingPayment.ts
var OutgoingPaymentFromJson = (obj) => {
  return {
    id: obj["outgoing_payment_id"],
    createdAt: obj["outgoing_payment_created_at"],
    updatedAt: obj["outgoing_payment_updated_at"],
    status: TransactionStatus_default[obj["outgoing_payment_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
    amount: CurrencyAmountFromJson(obj["outgoing_payment_amount"]),
    typename: "OutgoingPayment",
    resolvedAt: obj["outgoing_payment_resolved_at"],
    transactionHash: obj["outgoing_payment_transaction_hash"],
    fees: !!obj["outgoing_payment_fees"] ? CurrencyAmountFromJson(obj["outgoing_payment_fees"]) : void 0,
    paymentRequestData: !!obj["outgoing_payment_payment_request_data"] ? PaymentRequestDataFromJson(obj["outgoing_payment_payment_request_data"]) : void 0,
    failureReason: !!obj["outgoing_payment_failure_reason"] ? PaymentFailureReason_default[obj["outgoing_payment_failure_reason"]] ?? PaymentFailureReason_default.FUTURE_VALUE : null,
    failureMessage: !!obj["outgoing_payment_failure_message"] ? RichTextFromJson(obj["outgoing_payment_failure_message"]) : void 0,
    paymentPreimage: obj["outgoing_payment_payment_preimage"]
  };
};
var FRAGMENT16 = `
fragment OutgoingPaymentFragment on OutgoingPayment {
    __typename
    outgoing_payment_id: id
    outgoing_payment_created_at: created_at
    outgoing_payment_updated_at: updated_at
    outgoing_payment_status: status
    outgoing_payment_resolved_at: resolved_at
    outgoing_payment_amount: amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    outgoing_payment_transaction_hash: transaction_hash
    outgoing_payment_fees: fees {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    outgoing_payment_payment_request_data: payment_request_data {
        __typename
        ... on InvoiceData {
            __typename
            invoice_data_encoded_payment_request: encoded_payment_request
            invoice_data_bitcoin_network: bitcoin_network
            invoice_data_payment_hash: payment_hash
            invoice_data_amount: amount {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            invoice_data_created_at: created_at
            invoice_data_expires_at: expires_at
            invoice_data_memo: memo
            invoice_data_destination: destination {
                __typename
                graph_node_id: id
                graph_node_created_at: created_at
                graph_node_updated_at: updated_at
                graph_node_alias: alias
                graph_node_bitcoin_network: bitcoin_network
                graph_node_color: color
                graph_node_conductivity: conductivity
                graph_node_display_name: display_name
                graph_node_public_key: public_key
            }
        }
    }
    outgoing_payment_failure_reason: failure_reason
    outgoing_payment_failure_message: failure_message {
        __typename
        rich_text_text: text
    }
    outgoing_payment_payment_preimage: payment_preimage
}`;
var getOutgoingPaymentQuery = (id) => {
  return {
    queryPayload: `
query GetOutgoingPayment($id: ID!) {
    entity(id: $id) {
        ... on OutgoingPayment {
            ...OutgoingPaymentFragment
        }
    }
}

${FRAGMENT16}    
`,
    variables: { id },
    constructObject: (data) => OutgoingPaymentFromJson(data.entity)
  };
};

// src/graqhql/PayInvoice.ts
var PayInvoiceMutation = `
  mutation PayInvoice(
    $encoded_invoice: String!
    $timeout_secs: Int!
    $maximum_fees_msats: Long!
    $amount_msats: Long
  ) {
    pay_invoice(
      input: {
        encoded_invoice: $encoded_invoice
        timeout_secs: $timeout_secs
        amount_msats: $amount_msats
        maximum_fees_msats: $maximum_fees_msats
      }
    ) {
      payment {
        ...OutgoingPaymentFragment
      }
    }
  }

  ${FRAGMENT16}
`;
var PayInvoice_default = PayInvoiceMutation;

// src/graqhql/RequestWithdrawal.ts
var RequestWithdrawalMutation = `
  mutation RequestWithdrawal(
    $amount_sats: Long!
    $bitcoin_address: String!
  ) {
    request_withdrawal(input: {
        amount_sats: $amount_sats
        bitcoin_address: $bitcoin_address
    }) {
        request {
            ...WithdrawalRequestFragment
        }
    }
  }

  ${FRAGMENT10}
`;
var RequestWithdrawal_default = RequestWithdrawalMutation;

// src/graqhql/SendPayment.ts
var SendPaymentMutation = `
  mutation SendPayment(
    $destination_public_key: String!
    $timeout_secs: Int!
    $amount_msats: Long!
    $maximum_fees_msats: Long!
  ) {
    send_payment(
      input: {
        destination_public_key: $destination_public_key
        timeout_secs: $timeout_secs
        amount_msats: $amount_msats
        maximum_fees_msats: $maximum_fees_msats
      }
    ) {
      payment {
        ...OutgoingPaymentFragment
      }
    }
  }

  ${FRAGMENT16}
`;
var SendPayment_default = SendPaymentMutation;

// src/objects/TerminateWalletOutput.ts
var TerminateWalletOutputFromJson = (obj) => {
  return {
    wallet: WalletFromJson(obj["terminate_wallet_output_wallet"])
  };
};
var FRAGMENT17 = `
fragment TerminateWalletOutputFragment on TerminateWalletOutput {
    __typename
    terminate_wallet_output_wallet: wallet {
        __typename
        wallet_id: id
        wallet_created_at: created_at
        wallet_updated_at: updated_at
        wallet_balances: balances {
            __typename
            balances_owned_balance: owned_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            balances_available_to_send_balance: available_to_send_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            balances_available_to_withdraw_balance: available_to_withdraw_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
        }
        wallet_status: status
    }
}`;

// src/graqhql/TerminateWallet.ts
var TerminateWallet = `
  mutation TerminateWallet {
    terminate_wallet {
      ...TerminateWalletOutputFragment
    }
  }
  
    ${FRAGMENT17}
`;
var TerminateWallet_default = TerminateWallet;

// src/graqhql/WalletDashboard.ts
var WalletDashboardQuery = `
query WalletDashboard(
    $numTransactions: Int,
    $numPaymentRequests: Int,
    $transactionsAfterDate: DateTime = null,
    $paymentRequestsAfterDate: DateTime = null,
    $transactionTypes: [TransactionType!] = [CHANNEL_OPEN, CHANNEL_CLOSE, L1_DEPOSIT, L1_WITHDRAW, INCOMING_PAYMENT, OUTGOING_PAYMENT],
    $transactionStatuses: [TransactionStatus!] = [SUCCESS, FAILED, PENDING]
) {
    current_wallet {
        id
        balances {
            ...BalancesFragment
        }
        status
        recent_transactions: transactions(
            first: $numTransactions
            types: $transactionTypes
            statuses: $transactionStatuses
            created_after_date: $transactionsAfterDate
        ) {
            wallet_to_transactions_connection_count: count
            wallet_to_transactions_connection_entities: entities {
                ...TransactionFragment
            }
            wallet_to_transactions_connection_page_info: page_info {
                page_info_has_next_page: has_next_page
                page_info_has_previous_page: has_previous_page
                page_info_start_cursor: start_cursor
                page_info_end_cursor: end_cursor
            }
            type: __typename
        }
        payment_requests(
            first: $numPaymentRequests
            created_after_date: $paymentRequestsAfterDate
        ) {
            wallet_to_payment_requests_connection_count: count
            wallet_to_payment_requests_connection_entities: entities {
                ...PaymentRequestFragment
            }
            wallet_to_payment_requests_connection_page_info: page_info {
                page_info_has_next_page: has_next_page
                page_info_has_previous_page: has_previous_page
                page_info_start_cursor: start_cursor
                page_info_end_cursor: end_cursor
            }
        }
    }
}

${FRAGMENT8}
${FRAGMENT6}
${FRAGMENT7}
`;
var WalletDashboard_default = WalletDashboardQuery;

// src/objects/WithdrawalFeeEstimateOutput.ts
var WithdrawalFeeEstimateOutputFromJson = (obj) => {
  return {
    feeEstimate: CurrencyAmountFromJson(
      obj["withdrawal_fee_estimate_output_fee_estimate"]
    )
  };
};
var FRAGMENT18 = `
fragment WithdrawalFeeEstimateOutputFragment on WithdrawalFeeEstimateOutput {
    __typename
    withdrawal_fee_estimate_output_fee_estimate: fee_estimate {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
}`;

// src/graqhql/WithdrawalFeeEstimate.ts
var WithdrawalFeeEstimate = `
  query WithdrawalFeeEstimate(
    $amount_sats: Long!
    $withdrawal_mode: WithdrawalMode!
  ) {
    withdrawal_fee_estimate(input: {
      amount_sats: $amount_sats,
      withdrawal_mode: $withdrawal_mode
    }) {
      ...WithdrawalFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT18}
`;

// src/logger.ts
var import_core4 = require("@lightsparkdev/core");
var import_async_storage = __toESM(require("@react-native-async-storage/async-storage"), 1);
var logger = new import_core4.Logger("@lightsparkdev/wallet-sdk", async () => {
  try {
    if (import_core4.isTest) {
      return true;
    }
    const enabled = await import_async_storage.default.getItem(
      import_core4.ConfigKeys.LoggingEnabled
    );
    return enabled === "1";
  } catch (e) {
    return false;
  }
});

// src/objects/InvoiceType.ts
var InvoiceType = /* @__PURE__ */ ((InvoiceType2) => {
  InvoiceType2["FUTURE_VALUE"] = "FUTURE_VALUE";
  InvoiceType2["STANDARD"] = "STANDARD";
  InvoiceType2["AMP"] = "AMP";
  return InvoiceType2;
})(InvoiceType || {});
var InvoiceType_default = InvoiceType;

// src/client.ts
function isOutgoingPayment(payment) {
  return Boolean(
    payment && typeof payment === "object" && "typename" in payment && payment.typename === "OutgoingPayment"
  );
}
var sdkVersion = package_default.version;
var LightsparkClient = class {
  /**
   * Constructs a new LightsparkClient.
   *
   * @param authProvider The auth provider to use for authentication. Defaults to a stub auth provider. For server-side
   *     use, you should use the `AccountTokenAuthProvider`.
   * @param serverUrl The base URL of the server to connect to. Defaults to lightspark production.
   * @param cryptoImpl The crypto implementation to use. Defaults to web and node compatible crypto.
   *     For React Native, you should use the `ReactNativeCrypto`
   *     implementation from `@lightsparkdev/react-native`.
   * @param signingKeyType The type of signing key used in the LightsparkClient. Different signing operations are used depending on the key type.
   */
  constructor(authProvider = new import_core5.StubAuthProvider(), serverUrl = "api.lightspark.com", cryptoImpl = import_core5.DefaultCrypto, signingKeyType = import_core5.SigningKeyType.RSASigningKey) {
    this.authProvider = authProvider;
    this.serverUrl = serverUrl;
    this.cryptoImpl = cryptoImpl;
    this.signingKeyType = signingKeyType;
    this.nodeKeyCache = new import_core5.NodeKeyCache(this.cryptoImpl);
    this.requester = new import_core5.Requester(
      this.nodeKeyCache,
      WALLET_SDK_ENDPOINT,
      `js-wallet-sdk/${sdkVersion}`,
      authProvider,
      serverUrl,
      this.cryptoImpl
    );
    autoBind(this);
  }
  requester;
  nodeKeyCache;
  /**
   * Sets the auth provider for the client.
   * This is useful for switching between auth providers if you are using
   * multiple accounts or waiting for the user to log in.
   *
   * @param authProvider
   */
  setAuthProvider(authProvider) {
    this.requester = new import_core5.Requester(
      this.nodeKeyCache,
      WALLET_SDK_ENDPOINT,
      `js-wallet-sdk/${sdkVersion}`,
      authProvider,
      this.serverUrl,
      this.cryptoImpl
    );
    this.authProvider = authProvider;
  }
  /**
   * @returns Whether or not the client is authorized. This is useful for determining if the user is logged in or not.
   */
  async isAuthorized() {
    return this.authProvider.isAuthorized();
  }
  /**
   * Login using the Custom JWT authentication scheme described in our
   * documentation.
   *
   * Note: When using this method, you are responsible for refreshing the JWT
   * token before or when it expires. If the token expires,
   * the client will throw a [LightsparkAuthenticationException] on the next
   * API call which requires valid authentication.
   * Then you'll need to call this method again to get a new token.
   *
   * @param accountId The account ID to login with. This is specific to your company's account.
   * @param jwt The JWT to use for authentication of this user.
   * @param storage The storage to use for storing the JWT token.
   * @return The output of the login operation, including the access token, expiration time, and wallet info.
   */
  async loginWithJWT(accountId, jwt, storage) {
    const response = await this.executeRawQuery({
      queryPayload: LoginWithJWT_default,
      variables: {
        account_id: accountId,
        jwt
      },
      constructObject: (responseJson) => {
        return LoginWithJWTOutputFromJson(responseJson.login_with_jwt);
      },
      skipAuth: true
    });
    if (!response) {
      throw new import_core5.LightsparkAuthException(
        "Login failed. Please check your credentials and try again."
      );
    }
    const authProvider = new CustomJwtAuthProvider_default(storage);
    await authProvider.setTokenInfo({
      accessToken: response.accessToken,
      validUntil: new Date(response.validUntil)
    });
    this.setAuthProvider(authProvider);
    return response;
  }
  /**
   * Deploys a wallet in the Lightspark infrastructure.
   * This is an asynchronous operation,
   * the caller should then poll the wallet frequently (or subscribe to its
   * modifications). When this process is over,
   * the Wallet status will change to `DEPLOYED` (or `FAILED`).
   *
   * @return The wallet that was deployed.
   */
  async deployWallet() {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: DeployWallet_default,
      constructObject: (responseJson) => {
        return DeployWalletOutputFromJson(responseJson.deploy_wallet).wallet;
      }
    });
  }
  /**
   * Deploys a wallet in the Lightspark infrastructure and waits for it to be
   * deployed. This is an asynchronous operation,
   * which will continue processing wallet status updates until the Wallet
   * status changes to `DEPLOYED` (or `FAILED`).
   *
   * @return A Promise with the final wallet status after deployment or failure.
   * @throws LightsparkException if the wallet status is not `DEPLOYED` or `FAILED` after 60 seconds,
   * or if the subscription fails.
   */
  async deployWalletAndAwaitDeployed() {
    const wallet = await this.deployWallet();
    if (wallet?.status === WalletStatus_default.DEPLOYED || wallet?.status === WalletStatus_default.FAILED) {
      return wallet.status;
    }
    return await this.waitForWalletStatus([
      WalletStatus_default.DEPLOYED,
      WalletStatus_default.FAILED
    ]);
  }
  /**
   * Initializes a wallet in the Lightspark infrastructure and syncs it to the
   * Bitcoin network. This is an asynchronous operation,
   * the caller should then poll the wallet frequently (or subscribe to its
   * modifications). When this process is over,
   * the Wallet status will change to `READY` (or `FAILED`).
   *
   * @param keyType The type of key to use for the wallet.
   * @param signingPublicKey The base64-encoded public key to use for signing transactions.
   * @param signingPrivateKeyOrAlias An object containing either the base64-encoded private key or, in the case of
   *     React Native, a key alias for a key in the mobile keystore.
   *     The key will be used for signing transactions.
   *     This key will not leave the device.
   *     It is only used for signing transactions locally.
   * @return The wallet that was initialized.
   */
  async initializeWallet(keyType, signingPublicKey, signingPrivateKeyOrAlias) {
    await this.requireValidAuth();
    await this.loadWalletSigningKey(signingPrivateKeyOrAlias);
    return await this.executeRawQuery({
      queryPayload: InitializeWallet_default,
      variables: {
        key_type: keyType,
        signing_public_key: signingPublicKey
      },
      signingNodeId: WALLET_NODE_ID_KEY,
      constructObject: (responseJson) => {
        return InitializeWalletOutputFromJson(responseJson.initialize_wallet).wallet;
      }
    });
  }
  /**
   * Initializes a wallet in the Lightspark infrastructure and syncs it to the
   * Bitcoin network. This is an asynchronous operation,
   * which will continue processing wallet status updates until the Wallet
   * status changes to `READY` (or `FAILED`).
   *
   * @param keyType The type of key to use for the wallet.
   * @param signingPublicKey The base64-encoded public key to use for signing transactions.
   * @param signingPrivateKeyOrAlias An object containing either the base64-encoded private key or, in the case of
   *     React Native, a key alias for a key in the mobile keystore.
   *     The key will be used for signing transactions.
   *     This key will not leave the device.
   *     It is only used for signing transactions locally.
   * @return A Promise with the final wallet status after initialization or failure.
   * @throws LightsparkException if the wallet status is not `READY` or `FAILED` after 5 minutes,
   * or if the subscription fails.
   */
  async initializeWalletAndAwaitReady(keyType, signingPublicKey, signingPrivateKeyOrAlias) {
    const wallet = await this.initializeWallet(
      keyType,
      signingPublicKey,
      signingPrivateKeyOrAlias
    );
    if (wallet?.status === WalletStatus_default.READY || wallet?.status === WalletStatus_default.FAILED) {
      return wallet.status;
    }
    return await this.waitForWalletStatus(
      [WalletStatus_default.READY, WalletStatus_default.FAILED],
      300
    );
  }
  /**
   * Removes the wallet from Lightspark infrastructure.
   * It won't be connected to the Lightning network anymore and its funds won't
   * be accessible outside of the Funds Recovery Kit process.
   *
   * @return The wallet that was terminated.
   */
  async terminateWallet() {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: TerminateWallet_default,
      constructObject: (responseJson) => {
        return TerminateWalletOutputFromJson(responseJson.terminate_wallet).wallet;
      }
    });
  }
  /**
   * Get the dashboard overview for a Lightning wallet.
   * Includes balance info and the most recent transactions and payment
   * requests.
   *
   * @param numTransactions The max number of recent transactions to fetch. Defaults to 20.
   * @param numPaymentRequests The max number of recent payment requests to fetch. Defaults to 20.
   * @return The dashboard overview for the wallet, including balance and recent transactions and payment requests.
   */
  async getWalletDashboard(numTransactions = 20, numPaymentRequests = 20) {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: WalletDashboard_default,
      variables: {
        numTransactions,
        numPaymentRequests
      },
      constructObject: (responseJson) => {
        const currentWallet = responseJson.current_wallet;
        if (!currentWallet) {
          return null;
        }
        return {
          id: currentWallet.id,
          status: currentWallet.status,
          balances: currentWallet.balances && BalancesFromJson(currentWallet.balances),
          recentTransactions: currentWallet.recent_transactions && WalletToTransactionsConnectionFromJson(
            currentWallet.recent_transactions
          ),
          paymentRequests: currentWallet.payment_requests && WalletToPaymentRequestsConnectionFromJson(
            currentWallet.payment_requests
          )
        };
      }
    });
  }
  /**
   * Creates a lightning invoice from the current wallet.
   *
   * Test mode note: You can simulate a payment of this invoice in test move
   * using [createTestModePayment].
   *
   * @param amountMsats The amount of the invoice in milli-satoshis.
   * @param memo Optional memo to include in the invoice.
   * @param type The type of invoice to create. Defaults to [InvoiceType.STANDARD].
   * @param expirySecs The number of seconds until the invoice expires. Defaults to 1 day.
   * @return The created invoice.
   */
  async createInvoice(amountMsats, memo = void 0, type = InvoiceType_default.STANDARD, expirySecs = void 0) {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CreateInvoice_default,
      variables: {
        amountMsats,
        memo,
        type,
        expirySecs
      },
      constructObject: (responseJson) => {
        return InvoiceFromJson(responseJson.create_invoice.invoice);
      }
    });
  }
  /**
   * Cancels an existing unpaid invoice and returns that invoice. Cancelled invoices cannot be paid.
   *
   * @param invoiceId The ID of the invoice to cancel.
   * @returns The cancelled invoice, or undefined if the invoice could not be cancelled.
   */
  async cancelInvoice(invoiceId) {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CancelInvoice,
      variables: {
        invoice_id: invoiceId
      },
      constructObject: (responseJson) => {
        return InvoiceFromJson(responseJson.cancel_invoice.invoice);
      }
    });
  }
  /**
   * Pay a lightning invoice from the current wallet.
   * This function will return immediately with the payment details,
   * which may still be in a PENDING state.
   * You can use the [payInvoiceAndAwaitResult] function to wait for the
   * payment to complete or fail.
   *
   * Note: This call will fail if the wallet is not unlocked yet via
   * [loadWalletSigningKey]. You must successfully unlock the wallet before
   * calling this function.
   *
   * Test mode note: For test mode, you can use the [createTestModeInvoice]
   * function to create an invoice you can pay in test mode.
   *
   * @param encodedInvoice An encoded string representation of the invoice to pay.
   * @param maxFeesMsats The maximum fees to pay in milli-satoshis. You must pass a value.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @param amountMsats The amount to pay in milli-satoshis. Defaults to the full amount of the invoice.
   * @param timeoutSecs The number of seconds to wait for the payment to complete. Defaults to 60.
   * @return The payment details, which may still be in a PENDING state. You can use the [payInvoiceAndAwaitResult]
   *     function to wait for the payment to complete or fail.
   */
  async payInvoice(encodedInvoice, maxFeesMsats, amountMsats = void 0, timoutSecs = 60) {
    await this.requireValidAuth();
    this.requireWalletUnlocked();
    const variables = {
      encoded_invoice: encodedInvoice,
      maximum_fees_msats: maxFeesMsats,
      timeout_secs: timoutSecs
    };
    if (amountMsats !== void 0) {
      variables.amount_msats = amountMsats;
    }
    const payment = await this.executeRawQuery({
      queryPayload: PayInvoice_default,
      variables,
      constructObject: (responseJson) => {
        return OutgoingPaymentFromJson(responseJson.pay_invoice.payment);
      },
      signingNodeId: WALLET_NODE_ID_KEY
    });
    if (!payment) {
      throw new import_core5.LightsparkException(
        "PaymentNullError",
        "Unknown error paying invoice"
      );
    }
    return payment;
  }
  /**
   * Pay a lightning invoice from the current wallet and wait for the payment
   * to complete or fail.
   *
   * Note: This call will fail if the wallet is not unlocked yet via
   * [loadWalletSigningKey]. You must successfully unlock the wallet before
   * calling this function.
   *
   * @param encodedInvoice An encoded string representation of the invoice to pay.
   * @param maxFeesMsats The maximum fees to pay in milli-satoshis. You must pass a value.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @param amountMsats The amount to pay in milli-satoshis. Defaults to the full amount of the invoice.
   * @param timeoutSecs The number of seconds to wait for the payment to complete. Defaults to 60.
   * @return The payment details.
   */
  async payInvoiceAndAwaitResult(encodedInvoice, maxFeesMsats, amountMsats = void 0, timeoutSecs = 60) {
    logger.trace(`payInvoiceAndAwaitResult params`, {
      encodedInvoice,
      maxFeesMsats,
      amountMsats,
      timeoutSecs
    });
    const payment = await this.payInvoice(
      encodedInvoice,
      maxFeesMsats,
      amountMsats,
      timeoutSecs
    );
    logger.trace(`payInvoiceAndAwaitResult payment`, {
      paymentId: payment.id,
      paymentStatus: payment.status
    });
    const paymentResult = await this.awaitPaymentResult(payment, timeoutSecs);
    return paymentResult;
  }
  async awaitPaymentResult(payment, timeoutSecs = 60) {
    logger.trace(`awaitPaymentResult payment`, {
      paymentId: payment.id,
      paymentStatus: payment.status
    });
    const completionStatuses = [
      TransactionStatus_default.FAILED,
      TransactionStatus_default.CANCELLED,
      TransactionStatus_default.SUCCESS
    ];
    logger.trace(`awaitPaymentResult payment.status`, payment.status);
    if (completionStatuses.includes(payment.status)) {
      return Promise.resolve(payment);
    }
    const timeoutError = new import_core5.LightsparkException(
      "PaymentStatusAwaitError",
      `Timed out waiting for payment status to be one of ${completionStatuses.join(
        ", "
      )}.`
    );
    const pollIntervalMs = 500;
    const ignoreErrors = false;
    const isOutgoing = isOutgoingPayment(payment);
    const paymentResult = await (0, import_core5.pollUntil)(
      () => {
        return this.executeRawQuery({
          queryPayload: `
          query ${isOutgoing ? "Outgoing" : "Incoming"}PaymentStatusQuery {
            entity(id: "${payment.id}") {
              ...${isOutgoing ? "OutgoingPaymentFragment" : "IncomingPaymentFragment"}
            }
          }
          ${isOutgoing ? FRAGMENT16 : FRAGMENT5}
        `,
          constructObject: (responseJson) => {
            return isOutgoing ? OutgoingPaymentFromJson(responseJson.entity) : IncomingPaymentFromJson(responseJson.entity);
          }
        });
      },
      (current, response) => {
        logger.trace(`pollUntil current`, current);
        if (current && completionStatuses.includes(current.status)) {
          return {
            stopPolling: true,
            value: current
          };
        }
        return response;
      },
      timeoutSecs * 1e3 / pollIntervalMs,
      pollIntervalMs,
      ignoreErrors,
      () => timeoutError
    );
    return paymentResult;
  }
  /**
   * Sends a payment directly to a node on the Lightning Network through the
   * public key of the node without an invoice.
   * This function will return immediately with the payment details,
   * which may still be in a PENDING state.
   * You can use the [sendPaymentAndAwaitResult] function to wait for the
   * payment to complete or fail.
   *
   * @param destinationPublicKey The public key of the destination node.
   * @param amountMsats The amount to pay in milli-satoshis.
   * @param maxFeesMsats The maximum amount of fees that you want to pay for this payment to be sent.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @param timeoutSecs The timeout in seconds that we will try to make the payment.
   * @return An `OutgoingPayment` object, which may still be in a PENDING state. You can use the
   *     [sendPaymentAndAwaitResult] function to wait for the payment to
   *     complete or fail.
   */
  async sendPayment(destinationNodePublicKey, amountMsats, maxFeesMsats, timeoutSecs = 60) {
    await this.requireValidAuth();
    this.requireWalletUnlocked();
    const payment = await this.executeRawQuery({
      queryPayload: SendPayment_default,
      variables: {
        destination_node_public_key: destinationNodePublicKey,
        amount_msats: amountMsats,
        maximum_fees_msats: maxFeesMsats,
        timeout_secs: timeoutSecs
      },
      constructObject: (responseJson) => {
        return OutgoingPaymentFromJson(responseJson.send_payment.payment);
      },
      signingNodeId: WALLET_NODE_ID_KEY
    });
    if (!payment) {
      throw new import_core5.LightsparkException(
        "PaymentNullError",
        "Unknown error sending payment"
      );
    }
    return payment;
  }
  /**
   * Sends a payment directly to a node on the Lightning Network through the
   * public key of the node without an invoice.
   * Waits for the payment to complete or fail.
   *
   * @param destinationPublicKey The public key of the destination node.
   * @param amountMsats The amount to pay in milli-satoshis.
   * @param maxFeesMsats The maximum amount of fees that you want to pay for this payment to be sent.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @param timeoutSecs The timeout in seconds that we will try to make the payment.
   * @return An `OutgoingPayment` object. Check the `status` field to see if the payment succeeded or failed.
   */
  async sendPaymentAndAwaitResult(destinationNodePublicKey, amountMsats, maxFeesMsats, timeoutSecs = 60) {
    const payment = await this.sendPayment(
      destinationNodePublicKey,
      amountMsats,
      maxFeesMsats,
      timeoutSecs
    );
    return await this.awaitPaymentResult(payment, timeoutSecs);
  }
  /**
   * Decode a lightning invoice to get its details included payment amount,
   * destination, etc.
   *
   * @param encodedInvoice An encoded string representation of the invoice to decode.
   * @return The decoded invoice details.
   */
  async decodeInvoice(encodedInvoice) {
    return await this.executeRawQuery({
      queryPayload: DecodeInvoice_default,
      variables: {
        encoded_payment_request: encodedInvoice
      },
      constructObject: (responseJson) => {
        return InvoiceDataFromJson(responseJson.decoded_payment_request);
      }
    });
  }
  /**
   * Gets an estimate of the fee for sending a payment over the given bitcoin
   * network.
   *
   * @param bitcoinNetwork The bitcoin network for which to get a fee estimate. Defaults to MAINNET.
   * @returns A fee estimate for the given bitcoin network including a minimum fee rate, and a max-speed fee rate.
   */
  async getBitcoinFeeEstimate() {
    const response = await this.requester.makeRawRequest(
      BitcoinFeeEstimate_default
    );
    return FeeEstimateFromJson(response.bitcoin_fee_estimate);
  }
  /**
   * Gets an estimate of the fees that will be paid for a Lightning invoice.
   *
   * @param encodedPaymentRequest The invoice you want to pay (as defined by the BOLT11 standard).
   * @param amountMsats If the invoice does not specify a payment amount, then the amount that you wish to pay,
   *     expressed in msats.
   * @returns An estimate of the fees that will be paid for a Lightning invoice.
   */
  async getLightningFeeEstimateForInvoice(encodedPaymentRequest, amountMsats = void 0) {
    await this.requireValidAuth();
    const response = await this.requester.makeRawRequest(
      LightningFeeEstimateForInvoice_default,
      {
        encoded_payment_request: encodedPaymentRequest,
        amount_msats: amountMsats
      }
    );
    return CurrencyAmountFromJson(
      response.lightning_fee_estimate_for_invoice.lightning_fee_estimate_output_fee_estimate
    );
  }
  /**
   * Returns an estimate of the fees that will be paid to send a payment to
   * another Lightning node.
   *
   * @param destinationNodePublicKey The public key of the node that you want to pay.
   * @param amountMsats The payment amount expressed in msats.
   * @returns An estimate of the fees that will be paid to send a payment to another Lightning node.
   */
  async getLightningFeeEstimateForNode(destinationNodePublicKey, amountMsats) {
    await this.requireValidAuth();
    const response = await this.requester.makeRawRequest(
      LightningFeeEstimateForNode_default,
      {
        destination_node_public_key: destinationNodePublicKey,
        amount_msats: amountMsats
      }
    );
    return CurrencyAmountFromJson(
      response.lightning_fee_estimate_for_node.lightning_fee_estimate_output_fee_estimate
    );
  }
  /**
   * Returns an estimated amount for the L1 withdrawal fees for the specified node, amount, and
   * strategy.
   *
   * @param amountSats The amount you want to withdraw from this node in Satoshis. Use the special value -1 to
   *     withdrawal all funds from this wallet.
   * @param withdrawalMode The strategy that should be used to withdraw the funds from this node.
   * @returns An estimated amount for the L1 withdrawal fees for the specified node, amount, and strategy.
   */
  async getWithrawalFeeEstimate(amountSats, withdrawalMode) {
    const response = await this.executeRawQuery({
      queryPayload: WithdrawalFeeEstimate,
      variables: {
        amount_sats: amountSats,
        withdrawal_mode: withdrawalMode
      },
      constructObject: (response2) => {
        return WithdrawalFeeEstimateOutputFromJson(
          response2.withdrawal_fee_estimate
        );
      }
    });
    if (!response) {
      throw new import_core5.LightsparkException(
        "WithdrawalFeeEstimateError",
        "Null or invalid fee estimate response from server"
      );
    }
    return response.feeEstimate;
  }
  /**
   * Unlocks the wallet for use with the SDK for the current application
   * session. This function must be called before any other functions that
   * require wallet signing keys, including [payInvoice].
   *
   * This function is intended for use in cases where the wallet's private
   * signing key is already saved by the application outside of the SDK.
   * It is the responsibility of the application to ensure that the key is
   * valid and that it is the correct key for the wallet.
   * Otherwise signed requests will fail.
   *
   * @param signingKeyBytesOrAlias An object holding either the PEM encoded bytes of the wallet's private signing key or,
   *     in the case of ReactNative, the alias of the key in the mobile
   *     keychain.
   */
  loadWalletSigningKey(signingKeyBytesOrAlias) {
    return this.nodeKeyCache.loadKey(
      WALLET_NODE_ID_KEY,
      signingKeyBytesOrAlias,
      import_core5.SigningKeyType.RSASigningKey
    );
  }
  /**
   * Creates an L1 Bitcoin wallet address which can be used to deposit or
   * withdraw funds from the Lightning wallet.
   *
   * @return The newly created L1 wallet address.
   */
  async createBitcoinFundingAddress() {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CreateBitcoinFundingAddress_default,
      constructObject: (responseJson) => {
        return responseJson.create_bitcoin_funding_address.bitcoin_address;
      }
    });
  }
  /**
   * @return The current wallet if one exists, null otherwise.
   */
  async getCurrentWallet() {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CurrentWallet_default,
      constructObject: (responseJson) => {
        return WalletFromJson(responseJson.current_wallet);
      }
    });
  }
  /**
   * Withdraws funds from the account and sends it to the requested bitcoin
   * address.
   *
   * The process is asynchronous and may take up to a few minutes.
   * You can check the progress by polling the `WithdrawalRequest` that is
   * created, or by subscribing to a webhook.
   *
   * @param amountSats The amount of funds to withdraw in SATOSHI.
   * @param bitcoinAddress The Bitcoin address to withdraw funds to.
   */
  async requestWithdrawal(amountSats, bitcoinAddress) {
    await this.requireValidAuth();
    this.requireWalletUnlocked();
    return await this.executeRawQuery({
      queryPayload: RequestWithdrawal_default,
      variables: {
        amount_sats: amountSats,
        bitcoin_address: bitcoinAddress
      },
      constructObject: (responseJson) => {
        return WithdrawalRequestFromJson(
          responseJson.request_withdrawal.request
        );
      },
      signingNodeId: WALLET_NODE_ID_KEY
    });
  }
  /**
   * In test mode, generates a Lightning Invoice which can be paid by a local
   * node. This call is only valid in test mode.
   * You can then pay the invoice using [payInvoice].
   *
   * @param amountMsats The amount to pay in milli-satoshis.
   * @param memo An optional memo to attach to the invoice.
   * @param invoiceType The type of invoice to create.
   */
  async createTestModeInvoice(amountMsats, memo = void 0, invoiceType = InvoiceType_default.STANDARD) {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CreateTestModeInvoice_default,
      variables: {
        amount_msats: amountMsats,
        memo,
        invoice_type: invoiceType
      },
      constructObject: (responseJson) => {
        const encodedPaymentRequest = responseJson.create_test_mode_invoice?.encoded_payment_request;
        if (!encodedPaymentRequest) {
          throw new import_core5.LightsparkException(
            "CreateTestModeInvoiceError",
            "Unable to create test mode invoice"
          );
        }
        return encodedPaymentRequest;
      }
    });
  }
  /**
   * In test mode, simulates a payment of a Lightning Invoice from another
   * node. This can only be used in test mode and should be used with invoices
   * generated by [createInvoice].
   *
   * @param encodedInvoice The encoded invoice to pay.
   * @param amountMsats The amount to pay in milli-satoshis for 0-amount invoices. This should be null for non-zero
   *     amount invoices.
   */
  async createTestModePayment(encodedInvoice, amountMsats = void 0) {
    await this.requireValidAuth();
    this.requireWalletUnlocked();
    return await this.executeRawQuery({
      queryPayload: CreateTestModePayment_default,
      variables: {
        encoded_invoice: encodedInvoice,
        amount_msats: amountMsats
      },
      constructObject: (responseJson) => {
        return IncomingPaymentFromJson(
          responseJson.create_test_mode_payment?.incoming_payment
        );
      },
      signingNodeId: WALLET_NODE_ID_KEY
    });
  }
  /**
   * @return True if the wallet is unlocked or false if it is locked.
   */
  isWalletUnlocked() {
    return this.nodeKeyCache.hasKey(WALLET_NODE_ID_KEY);
  }
  async requireValidAuth() {
    if (!await this.isAuthorized()) {
      throw new import_core5.LightsparkAuthException(
        "You must be logged in to perform this action."
      );
    }
  }
  requireWalletUnlocked() {
    if (!this.isWalletUnlocked()) {
      throw new import_core5.LightsparkAuthException(
        "You must unlock the wallet before performing this action."
      );
    }
  }
  waitForWalletStatus(statuses, timeoutSecs = 60) {
    let timeout;
    let subscription;
    const result = new Promise((resolve, reject) => {
      subscription = this.listenToWalletStatus().subscribe({
        next: (status) => {
          if (statuses.includes(status)) {
            resolve(status);
          }
        },
        error: (error) => {
          reject(error);
        },
        complete: () => {
          reject(
            new import_core5.LightsparkException(
              "WalletStatusAwaitError",
              "Wallet status subscription completed without receiving a status update."
            )
          );
        }
      });
      timeout = setTimeout(() => {
        reject(
          new import_core5.LightsparkException(
            "WalletStatusAwaitError",
            `Timed out waiting for wallet status to be one of ${statuses.join(
              ", "
            )}.`
          )
        );
      }, timeoutSecs * 1e3);
    });
    return result.finally(() => {
      clearTimeout(timeout);
      subscription.unsubscribe();
    });
  }
  listenToWalletStatus() {
    return this.requester.subscribe(
      `
      subscription WalletStatusSubscription {
        current_wallet {
          status
        }
      }`
    ).map((responseJson) => {
      return WalletStatus_default[responseJson.data.current_wallet.status] ?? WalletStatus_default.FUTURE_VALUE;
    });
  }
  /**
   * Executes a raw `Query` as a subscription and returns an `Observable` that
   * emits the result of the query when it changes.
   *
   * This can only be used with `subscription` operations.
   *
   * @param query The `Query` to execute.
   * @returns A zen-observable that emits the result of the query when it changes.
   */
  subscribeToRawQuery(query) {
    return this.requester.subscribe(query.queryPayload, query.variables).map((responseJson) => {
      return query.constructObject(responseJson.data);
    });
  }
  /**
   * Executes a raw `Query` against the Lightspark API.
   *
   * This generally should not be used directly,
   * but is exposed for advanced use cases and for internal use to retrieve
   * complex fields from objects.
   *
   * @param query The `Query` to execute.
   * @returns The result of the query.
   */
  executeRawQuery(query) {
    return this.requester.executeQuery(query);
  }
};
var WALLET_NODE_ID_KEY = "wallet_node_id";
var WALLET_SDK_ENDPOINT = "graphql/wallet/2023-05-05";
var client_default = LightsparkClient;

// src/objects/ChannelClosingTransaction.ts
var ChannelClosingTransactionFromJson = (obj) => {
  return {
    id: obj["channel_closing_transaction_id"],
    createdAt: obj["channel_closing_transaction_created_at"],
    updatedAt: obj["channel_closing_transaction_updated_at"],
    status: TransactionStatus_default[obj["channel_closing_transaction_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
    amount: CurrencyAmountFromJson(obj["channel_closing_transaction_amount"]),
    blockHeight: obj["channel_closing_transaction_block_height"],
    destinationAddresses: obj["channel_closing_transaction_destination_addresses"],
    typename: "ChannelClosingTransaction",
    resolvedAt: obj["channel_closing_transaction_resolved_at"],
    transactionHash: obj["channel_closing_transaction_transaction_hash"],
    fees: !!obj["channel_closing_transaction_fees"] ? CurrencyAmountFromJson(obj["channel_closing_transaction_fees"]) : void 0,
    blockHash: obj["channel_closing_transaction_block_hash"],
    numConfirmations: obj["channel_closing_transaction_num_confirmations"]
  };
};
var FRAGMENT19 = `
fragment ChannelClosingTransactionFragment on ChannelClosingTransaction {
    __typename
    channel_closing_transaction_id: id
    channel_closing_transaction_created_at: created_at
    channel_closing_transaction_updated_at: updated_at
    channel_closing_transaction_status: status
    channel_closing_transaction_resolved_at: resolved_at
    channel_closing_transaction_amount: amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    channel_closing_transaction_transaction_hash: transaction_hash
    channel_closing_transaction_fees: fees {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    channel_closing_transaction_block_hash: block_hash
    channel_closing_transaction_block_height: block_height
    channel_closing_transaction_destination_addresses: destination_addresses
    channel_closing_transaction_num_confirmations: num_confirmations
}`;
var getChannelClosingTransactionQuery = (id) => {
  return {
    queryPayload: `
query GetChannelClosingTransaction($id: ID!) {
    entity(id: $id) {
        ... on ChannelClosingTransaction {
            ...ChannelClosingTransactionFragment
        }
    }
}

${FRAGMENT19}    
`,
    variables: { id },
    constructObject: (data) => ChannelClosingTransactionFromJson(data.entity)
  };
};

// src/objects/ChannelOpeningTransaction.ts
var ChannelOpeningTransactionFromJson = (obj) => {
  return {
    id: obj["channel_opening_transaction_id"],
    createdAt: obj["channel_opening_transaction_created_at"],
    updatedAt: obj["channel_opening_transaction_updated_at"],
    status: TransactionStatus_default[obj["channel_opening_transaction_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
    amount: CurrencyAmountFromJson(obj["channel_opening_transaction_amount"]),
    blockHeight: obj["channel_opening_transaction_block_height"],
    destinationAddresses: obj["channel_opening_transaction_destination_addresses"],
    typename: "ChannelOpeningTransaction",
    resolvedAt: obj["channel_opening_transaction_resolved_at"],
    transactionHash: obj["channel_opening_transaction_transaction_hash"],
    fees: !!obj["channel_opening_transaction_fees"] ? CurrencyAmountFromJson(obj["channel_opening_transaction_fees"]) : void 0,
    blockHash: obj["channel_opening_transaction_block_hash"],
    numConfirmations: obj["channel_opening_transaction_num_confirmations"]
  };
};
var FRAGMENT20 = `
fragment ChannelOpeningTransactionFragment on ChannelOpeningTransaction {
    __typename
    channel_opening_transaction_id: id
    channel_opening_transaction_created_at: created_at
    channel_opening_transaction_updated_at: updated_at
    channel_opening_transaction_status: status
    channel_opening_transaction_resolved_at: resolved_at
    channel_opening_transaction_amount: amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    channel_opening_transaction_transaction_hash: transaction_hash
    channel_opening_transaction_fees: fees {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    channel_opening_transaction_block_hash: block_hash
    channel_opening_transaction_block_height: block_height
    channel_opening_transaction_destination_addresses: destination_addresses
    channel_opening_transaction_num_confirmations: num_confirmations
}`;
var getChannelOpeningTransactionQuery = (id) => {
  return {
    queryPayload: `
query GetChannelOpeningTransaction($id: ID!) {
    entity(id: $id) {
        ... on ChannelOpeningTransaction {
            ...ChannelOpeningTransactionFragment
        }
    }
}

${FRAGMENT20}    
`,
    variables: { id },
    constructObject: (data) => ChannelOpeningTransactionFromJson(data.entity)
  };
};

// src/objects/Connection.ts
var import_core6 = require("@lightsparkdev/core");

// src/objects/Deposit.ts
var DepositFromJson = (obj) => {
  return {
    id: obj["deposit_id"],
    createdAt: obj["deposit_created_at"],
    updatedAt: obj["deposit_updated_at"],
    status: TransactionStatus_default[obj["deposit_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
    amount: CurrencyAmountFromJson(obj["deposit_amount"]),
    blockHeight: obj["deposit_block_height"],
    destinationAddresses: obj["deposit_destination_addresses"],
    typename: "Deposit",
    resolvedAt: obj["deposit_resolved_at"],
    transactionHash: obj["deposit_transaction_hash"],
    fees: !!obj["deposit_fees"] ? CurrencyAmountFromJson(obj["deposit_fees"]) : void 0,
    blockHash: obj["deposit_block_hash"],
    numConfirmations: obj["deposit_num_confirmations"]
  };
};
var FRAGMENT21 = `
fragment DepositFragment on Deposit {
    __typename
    deposit_id: id
    deposit_created_at: created_at
    deposit_updated_at: updated_at
    deposit_status: status
    deposit_resolved_at: resolved_at
    deposit_amount: amount {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    deposit_transaction_hash: transaction_hash
    deposit_fees: fees {
        __typename
        currency_amount_original_value: original_value
        currency_amount_original_unit: original_unit
        currency_amount_preferred_currency_unit: preferred_currency_unit
        currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
        currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    deposit_block_hash: block_hash
    deposit_block_height: block_height
    deposit_destination_addresses: destination_addresses
    deposit_num_confirmations: num_confirmations
}`;
var getDepositQuery = (id) => {
  return {
    queryPayload: `
query GetDeposit($id: ID!) {
    entity(id: $id) {
        ... on Deposit {
            ...DepositFragment
        }
    }
}

${FRAGMENT21}    
`,
    variables: { id },
    constructObject: (data) => DepositFromJson(data.entity)
  };
};

// src/objects/FundsRecoveryKit.ts
var import_core7 = require("@lightsparkdev/core");

// src/objects/KeyType.ts
var KeyType = /* @__PURE__ */ ((KeyType2) => {
  KeyType2["FUTURE_VALUE"] = "FUTURE_VALUE";
  KeyType2["RSA_OAEP"] = "RSA_OAEP";
  KeyType2["ELLIPTIC_CURVE"] = "ELLIPTIC_CURVE";
  KeyType2["ED25519"] = "ED25519";
  return KeyType2;
})(KeyType || {});
var KeyType_default = KeyType;

// src/objects/LightningTransaction.ts
var import_core8 = require("@lightsparkdev/core");
var LightningTransactionFromJson = (obj) => {
  if (obj["__typename"] == "IncomingPayment") {
    return {
      id: obj["incoming_payment_id"],
      createdAt: obj["incoming_payment_created_at"],
      updatedAt: obj["incoming_payment_updated_at"],
      status: TransactionStatus_default[obj["incoming_payment_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["incoming_payment_amount"]),
      typename: "IncomingPayment",
      resolvedAt: obj["incoming_payment_resolved_at"],
      transactionHash: obj["incoming_payment_transaction_hash"],
      paymentRequestId: obj["incoming_payment_payment_request"]?.id ?? void 0
    };
  }
  if (obj["__typename"] == "OutgoingPayment") {
    return {
      id: obj["outgoing_payment_id"],
      createdAt: obj["outgoing_payment_created_at"],
      updatedAt: obj["outgoing_payment_updated_at"],
      status: TransactionStatus_default[obj["outgoing_payment_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["outgoing_payment_amount"]),
      typename: "OutgoingPayment",
      resolvedAt: obj["outgoing_payment_resolved_at"],
      transactionHash: obj["outgoing_payment_transaction_hash"],
      fees: !!obj["outgoing_payment_fees"] ? CurrencyAmountFromJson(obj["outgoing_payment_fees"]) : void 0,
      paymentRequestData: !!obj["outgoing_payment_payment_request_data"] ? PaymentRequestDataFromJson(
        obj["outgoing_payment_payment_request_data"]
      ) : void 0,
      failureReason: !!obj["outgoing_payment_failure_reason"] ? PaymentFailureReason_default[obj["outgoing_payment_failure_reason"]] ?? PaymentFailureReason_default.FUTURE_VALUE : null,
      failureMessage: !!obj["outgoing_payment_failure_message"] ? RichTextFromJson(obj["outgoing_payment_failure_message"]) : void 0,
      paymentPreimage: obj["outgoing_payment_payment_preimage"]
    };
  }
  throw new import_core8.LightsparkException(
    "DeserializationError",
    `Couldn't find a concrete type for interface LightningTransaction corresponding to the typename=${obj["__typename"]}`
  );
};
var FRAGMENT22 = `
fragment LightningTransactionFragment on LightningTransaction {
    __typename
    ... on IncomingPayment {
        __typename
        incoming_payment_id: id
        incoming_payment_created_at: created_at
        incoming_payment_updated_at: updated_at
        incoming_payment_status: status
        incoming_payment_resolved_at: resolved_at
        incoming_payment_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        incoming_payment_transaction_hash: transaction_hash
        incoming_payment_payment_request: payment_request {
            id
        }
    }
    ... on OutgoingPayment {
        __typename
        outgoing_payment_id: id
        outgoing_payment_created_at: created_at
        outgoing_payment_updated_at: updated_at
        outgoing_payment_status: status
        outgoing_payment_resolved_at: resolved_at
        outgoing_payment_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        outgoing_payment_transaction_hash: transaction_hash
        outgoing_payment_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        outgoing_payment_payment_request_data: payment_request_data {
            __typename
            ... on InvoiceData {
                __typename
                invoice_data_encoded_payment_request: encoded_payment_request
                invoice_data_bitcoin_network: bitcoin_network
                invoice_data_payment_hash: payment_hash
                invoice_data_amount: amount {
                    __typename
                    currency_amount_original_value: original_value
                    currency_amount_original_unit: original_unit
                    currency_amount_preferred_currency_unit: preferred_currency_unit
                    currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                    currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                }
                invoice_data_created_at: created_at
                invoice_data_expires_at: expires_at
                invoice_data_memo: memo
                invoice_data_destination: destination {
                    __typename
                    graph_node_id: id
                    graph_node_created_at: created_at
                    graph_node_updated_at: updated_at
                    graph_node_alias: alias
                    graph_node_bitcoin_network: bitcoin_network
                    graph_node_color: color
                    graph_node_conductivity: conductivity
                    graph_node_display_name: display_name
                    graph_node_public_key: public_key
                }
            }
        }
        outgoing_payment_failure_reason: failure_reason
        outgoing_payment_failure_message: failure_message {
            __typename
            rich_text_text: text
        }
        outgoing_payment_payment_preimage: payment_preimage
    }
}`;
var getLightningTransactionQuery = (id) => {
  return {
    queryPayload: `
query GetLightningTransaction($id: ID!) {
    entity(id: $id) {
        ... on LightningTransaction {
            ...LightningTransactionFragment
        }
    }
}

${FRAGMENT22}    
`,
    variables: { id },
    constructObject: (data) => LightningTransactionFromJson(data.entity)
  };
};

// src/objects/Node.ts
var import_core9 = require("@lightsparkdev/core");
var NodeFromJson = (obj) => {
  if (obj["__typename"] == "GraphNode") {
    return new GraphNode_default(
      obj["graph_node_id"],
      obj["graph_node_created_at"],
      obj["graph_node_updated_at"],
      BitcoinNetwork_default[obj["graph_node_bitcoin_network"]] ?? BitcoinNetwork_default.FUTURE_VALUE,
      obj["graph_node_display_name"],
      "GraphNode",
      obj["graph_node_alias"],
      obj["graph_node_color"],
      obj["graph_node_conductivity"],
      obj["graph_node_public_key"]
    );
  }
  throw new import_core9.LightsparkException(
    "DeserializationError",
    `Couldn't find a concrete type for interface Node corresponding to the typename=${obj["__typename"]}`
  );
};
var FRAGMENT23 = `
fragment NodeFragment on Node {
    __typename
    ... on GraphNode {
        __typename
        graph_node_id: id
        graph_node_created_at: created_at
        graph_node_updated_at: updated_at
        graph_node_alias: alias
        graph_node_bitcoin_network: bitcoin_network
        graph_node_color: color
        graph_node_conductivity: conductivity
        graph_node_display_name: display_name
        graph_node_public_key: public_key
    }
}`;
var getNodeQuery = (id) => {
  return {
    queryPayload: `
query GetNode($id: ID!) {
    entity(id: $id) {
        ... on Node {
            ...NodeFragment
        }
    }
}

${FRAGMENT23}    
`,
    variables: { id },
    constructObject: (data) => NodeFromJson(data.entity)
  };
};

// src/objects/OnChainTransaction.ts
var import_core10 = require("@lightsparkdev/core");
var OnChainTransactionFromJson = (obj) => {
  if (obj["__typename"] == "ChannelClosingTransaction") {
    return {
      id: obj["channel_closing_transaction_id"],
      createdAt: obj["channel_closing_transaction_created_at"],
      updatedAt: obj["channel_closing_transaction_updated_at"],
      status: TransactionStatus_default[obj["channel_closing_transaction_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["channel_closing_transaction_amount"]),
      blockHeight: obj["channel_closing_transaction_block_height"],
      destinationAddresses: obj["channel_closing_transaction_destination_addresses"],
      typename: "ChannelClosingTransaction",
      resolvedAt: obj["channel_closing_transaction_resolved_at"],
      transactionHash: obj["channel_closing_transaction_transaction_hash"],
      fees: !!obj["channel_closing_transaction_fees"] ? CurrencyAmountFromJson(obj["channel_closing_transaction_fees"]) : void 0,
      blockHash: obj["channel_closing_transaction_block_hash"],
      numConfirmations: obj["channel_closing_transaction_num_confirmations"]
    };
  }
  if (obj["__typename"] == "ChannelOpeningTransaction") {
    return {
      id: obj["channel_opening_transaction_id"],
      createdAt: obj["channel_opening_transaction_created_at"],
      updatedAt: obj["channel_opening_transaction_updated_at"],
      status: TransactionStatus_default[obj["channel_opening_transaction_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["channel_opening_transaction_amount"]),
      blockHeight: obj["channel_opening_transaction_block_height"],
      destinationAddresses: obj["channel_opening_transaction_destination_addresses"],
      typename: "ChannelOpeningTransaction",
      resolvedAt: obj["channel_opening_transaction_resolved_at"],
      transactionHash: obj["channel_opening_transaction_transaction_hash"],
      fees: !!obj["channel_opening_transaction_fees"] ? CurrencyAmountFromJson(obj["channel_opening_transaction_fees"]) : void 0,
      blockHash: obj["channel_opening_transaction_block_hash"],
      numConfirmations: obj["channel_opening_transaction_num_confirmations"]
    };
  }
  if (obj["__typename"] == "Deposit") {
    return {
      id: obj["deposit_id"],
      createdAt: obj["deposit_created_at"],
      updatedAt: obj["deposit_updated_at"],
      status: TransactionStatus_default[obj["deposit_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["deposit_amount"]),
      blockHeight: obj["deposit_block_height"],
      destinationAddresses: obj["deposit_destination_addresses"],
      typename: "Deposit",
      resolvedAt: obj["deposit_resolved_at"],
      transactionHash: obj["deposit_transaction_hash"],
      fees: !!obj["deposit_fees"] ? CurrencyAmountFromJson(obj["deposit_fees"]) : void 0,
      blockHash: obj["deposit_block_hash"],
      numConfirmations: obj["deposit_num_confirmations"]
    };
  }
  if (obj["__typename"] == "Withdrawal") {
    return {
      id: obj["withdrawal_id"],
      createdAt: obj["withdrawal_created_at"],
      updatedAt: obj["withdrawal_updated_at"],
      status: TransactionStatus_default[obj["withdrawal_status"]] ?? TransactionStatus_default.FUTURE_VALUE,
      amount: CurrencyAmountFromJson(obj["withdrawal_amount"]),
      blockHeight: obj["withdrawal_block_height"],
      destinationAddresses: obj["withdrawal_destination_addresses"],
      typename: "Withdrawal",
      resolvedAt: obj["withdrawal_resolved_at"],
      transactionHash: obj["withdrawal_transaction_hash"],
      fees: !!obj["withdrawal_fees"] ? CurrencyAmountFromJson(obj["withdrawal_fees"]) : void 0,
      blockHash: obj["withdrawal_block_hash"],
      numConfirmations: obj["withdrawal_num_confirmations"]
    };
  }
  throw new import_core10.LightsparkException(
    "DeserializationError",
    `Couldn't find a concrete type for interface OnChainTransaction corresponding to the typename=${obj["__typename"]}`
  );
};
var FRAGMENT24 = `
fragment OnChainTransactionFragment on OnChainTransaction {
    __typename
    ... on ChannelClosingTransaction {
        __typename
        channel_closing_transaction_id: id
        channel_closing_transaction_created_at: created_at
        channel_closing_transaction_updated_at: updated_at
        channel_closing_transaction_status: status
        channel_closing_transaction_resolved_at: resolved_at
        channel_closing_transaction_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        channel_closing_transaction_transaction_hash: transaction_hash
        channel_closing_transaction_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        channel_closing_transaction_block_hash: block_hash
        channel_closing_transaction_block_height: block_height
        channel_closing_transaction_destination_addresses: destination_addresses
        channel_closing_transaction_num_confirmations: num_confirmations
    }
    ... on ChannelOpeningTransaction {
        __typename
        channel_opening_transaction_id: id
        channel_opening_transaction_created_at: created_at
        channel_opening_transaction_updated_at: updated_at
        channel_opening_transaction_status: status
        channel_opening_transaction_resolved_at: resolved_at
        channel_opening_transaction_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        channel_opening_transaction_transaction_hash: transaction_hash
        channel_opening_transaction_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        channel_opening_transaction_block_hash: block_hash
        channel_opening_transaction_block_height: block_height
        channel_opening_transaction_destination_addresses: destination_addresses
        channel_opening_transaction_num_confirmations: num_confirmations
    }
    ... on Deposit {
        __typename
        deposit_id: id
        deposit_created_at: created_at
        deposit_updated_at: updated_at
        deposit_status: status
        deposit_resolved_at: resolved_at
        deposit_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        deposit_transaction_hash: transaction_hash
        deposit_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        deposit_block_hash: block_hash
        deposit_block_height: block_height
        deposit_destination_addresses: destination_addresses
        deposit_num_confirmations: num_confirmations
    }
    ... on Withdrawal {
        __typename
        withdrawal_id: id
        withdrawal_created_at: created_at
        withdrawal_updated_at: updated_at
        withdrawal_status: status
        withdrawal_resolved_at: resolved_at
        withdrawal_amount: amount {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        withdrawal_transaction_hash: transaction_hash
        withdrawal_fees: fees {
            __typename
            currency_amount_original_value: original_value
            currency_amount_original_unit: original_unit
            currency_amount_preferred_currency_unit: preferred_currency_unit
            currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
            currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        withdrawal_block_hash: block_hash
        withdrawal_block_height: block_height
        withdrawal_destination_addresses: destination_addresses
        withdrawal_num_confirmations: num_confirmations
    }
}`;
var getOnChainTransactionQuery = (id) => {
  return {
    queryPayload: `
query GetOnChainTransaction($id: ID!) {
    entity(id: $id) {
        ... on OnChainTransaction {
            ...OnChainTransactionFragment
        }
    }
}

${FRAGMENT24}    
`,
    variables: { id },
    constructObject: (data) => OnChainTransactionFromJson(data.entity)
  };
};

// src/objects/TransactionType.ts
var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
  TransactionType2["FUTURE_VALUE"] = "FUTURE_VALUE";
  TransactionType2["OUTGOING_PAYMENT"] = "OUTGOING_PAYMENT";
  TransactionType2["INCOMING_PAYMENT"] = "INCOMING_PAYMENT";
  TransactionType2["ROUTED"] = "ROUTED";
  TransactionType2["L1_WITHDRAW"] = "L1_WITHDRAW";
  TransactionType2["L1_DEPOSIT"] = "L1_DEPOSIT";
  TransactionType2["CHANNEL_OPEN"] = "CHANNEL_OPEN";
  TransactionType2["CHANNEL_CLOSE"] = "CHANNEL_CLOSE";
  TransactionType2["PAYMENT"] = "PAYMENT";
  TransactionType2["PAYMENT_REQUEST"] = "PAYMENT_REQUEST";
  TransactionType2["ROUTE"] = "ROUTE";
  return TransactionType2;
})(TransactionType || {});
var TransactionType_default = TransactionType;

// src/objects/WithdrawalMode.ts
var WithdrawalMode = /* @__PURE__ */ ((WithdrawalMode2) => {
  WithdrawalMode2["FUTURE_VALUE"] = "FUTURE_VALUE";
  WithdrawalMode2["WALLET_ONLY"] = "WALLET_ONLY";
  WithdrawalMode2["WALLET_THEN_CHANNELS"] = "WALLET_THEN_CHANNELS";
  return WithdrawalMode2;
})(WithdrawalMode || {});
var WithdrawalMode_default = WithdrawalMode;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BitcoinNetwork,
  ChromeExtensionLocalTokenStorage,
  CurrencyUnit,
  CustomJwtAuthProvider,
  GraphNode,
  InMemoryTokenStorage,
  InvoiceType,
  KeyType,
  LightsparkClient,
  NodeAddressType,
  PaymentFailureReason,
  PaymentRequestStatus,
  TransactionStatus,
  TransactionType,
  Wallet,
  WalletStatus,
  WithdrawalMode,
  WithdrawalRequest,
  WithdrawalRequestStatus,
  getChannelClosingTransactionQuery,
  getChannelOpeningTransactionQuery,
  getDepositQuery,
  getIncomingPaymentQuery,
  getInvoiceQuery,
  getLightningTransactionQuery,
  getNodeQuery,
  getOnChainTransactionQuery,
  getOutgoingPaymentQuery,
  getPaymentRequestQuery,
  getTransactionQuery,
  getWithdrawalQuery
});
