import {
  BalancesFromJson,
  BitcoinNetwork_default,
  CurrencyAmountFromJson,
  CurrencyUnit_default,
  DeployWalletOutputFromJson,
  FRAGMENT,
  FRAGMENT10,
  FRAGMENT11,
  FRAGMENT12,
  FRAGMENT13,
  FRAGMENT14,
  FRAGMENT15,
  FRAGMENT16,
  FRAGMENT2,
  FRAGMENT3,
  FRAGMENT4,
  FRAGMENT5,
  FRAGMENT6,
  FRAGMENT7,
  FRAGMENT8,
  FRAGMENT9,
  FeeEstimateFromJson,
  GraphNode_default,
  IncomingPaymentFromJson,
  InitializeWalletOutputFromJson,
  InvoiceDataFromJson,
  InvoiceFromJson,
  InvoiceType_default,
  KeyType_default,
  LoginWithJWTOutputFromJson,
  NodeAddressType_default,
  OutgoingPaymentFromJson,
  PaymentFailureReason_default,
  PaymentRequestStatus_default,
  TerminateWalletOutputFromJson,
  TransactionStatus_default,
  TransactionType_default,
  WalletFromJson,
  WalletStatus_default,
  WalletToPaymentRequestsConnectionFromJson,
  WalletToTransactionsConnectionFromJson,
  Wallet_default,
  WithdrawalFeeEstimateOutputFromJson,
  WithdrawalMode_default,
  WithdrawalRequestFromJson,
  WithdrawalRequestStatus_default,
  WithdrawalRequest_default,
  autoBind,
  getChannelClosingTransactionQuery,
  getChannelOpeningTransactionQuery,
  getDepositQuery,
  getIncomingPaymentQuery,
  getInvoiceQuery,
  getLightningTransactionQuery,
  getNodeQuery,
  getOnChainTransactionQuery,
  getOutgoingPaymentQuery,
  getPaymentRequestQuery,
  getTransactionQuery,
  getWithdrawalQuery
} from "./chunk-DLPQEUAE.js";

// src/auth/jwt/AccessTokenInfo.ts
function isParsedAccessTokenInfo(value) {
  return typeof value === "object" && value !== null && "accessToken" in value && typeof value.accessToken === "string" && "validUntil" in value && typeof value.validUntil === "string";
}

// src/auth/jwt/ChromeExtensionLocalTokenStorage.ts
var STORAGE_KEY = "lightspark-jwt";
var ChromeExtensionLocalTokenStorage = class {
  async getCurrent() {
    if (!chrome || !chrome.storage || !chrome.storage.local) {
      throw new Error(
        "Chrome extension local storage is not available in this environment."
      );
    }
    const tokenInfo = await chrome.storage.local.get([STORAGE_KEY]);
    if (tokenInfo === null) {
      return null;
    }
    if (isParsedAccessTokenInfo(tokenInfo)) {
      return {
        accessToken: tokenInfo.accessToken,
        validUntil: new Date(tokenInfo.validUntil)
      };
    }
    return null;
  }
  async replace(tokenInfo) {
    await chrome.storage.local.set({
      STORAGE_KEY: {
        accessToken: tokenInfo.accessToken,
        validUntil: tokenInfo.validUntil.toISOString()
      }
    });
  }
  async clear() {
    await chrome.storage.local.remove(STORAGE_KEY);
  }
};
var ChromeExtensionLocalTokenStorage_default = ChromeExtensionLocalTokenStorage;

// src/auth/jwt/CustomJwtAuthProvider.ts
var CustomJwtAuthProvider = class {
  constructor(tokenStorage) {
    this.tokenStorage = tokenStorage;
  }
  async setTokenInfo(tokenInfo) {
    await this.tokenStorage.replace(tokenInfo);
  }
  async logout() {
    await this.tokenStorage.clear();
  }
  async addAuthHeaders(headers) {
    const tokenInfo = await this.tokenStorage.getCurrent();
    if (!tokenInfo) {
      return headers;
    }
    return Object.assign({}, headers, {
      authorization: `Bearer ${tokenInfo.accessToken}`
    });
  }
  async isAuthorized() {
    const tokenInfo = await this.tokenStorage.getCurrent();
    if (!tokenInfo) {
      return false;
    }
    return tokenInfo.validUntil > /* @__PURE__ */ new Date();
  }
  async addWsConnectionParams(params) {
    const tokenInfo = await this.tokenStorage.getCurrent();
    if (!tokenInfo) {
      return params;
    }
    return Object.assign({}, params, {
      access_token: tokenInfo.accessToken
    });
  }
};
var CustomJwtAuthProvider_default = CustomJwtAuthProvider;

// src/auth/jwt/InMemoryTokenStorage.ts
var InMemoryTokenStorage = class {
  tokenInfo = null;
  getCurrent() {
    return Promise.resolve(this.tokenInfo);
  }
  replace(tokenInfo) {
    this.tokenInfo = tokenInfo;
    return Promise.resolve();
  }
  clear() {
    this.tokenInfo = null;
    return Promise.resolve();
  }
};
var InMemoryTokenStorage_default = InMemoryTokenStorage;

// src/client.ts
import {
  DefaultCrypto,
  LightsparkAuthException,
  LightsparkException,
  NodeKeyCache,
  Requester,
  SigningKeyType,
  StubAuthProvider,
  pollUntil
} from "@lightsparkdev/core";

// package.json
var package_default = {
  name: "@lightsparkdev/wallet-sdk",
  version: "0.12.13",
  description: "Lightspark JS Wallet SDK",
  author: "Lightspark Inc.",
  keywords: [
    "lightspark",
    "bitcoin",
    "lightning",
    "payments",
    "typescript"
  ],
  homepage: "https://github.com/lightsparkdev/js-sdk",
  repository: {
    type: "git",
    url: "https://github.com/lightsparkdev/js-sdk.git"
  },
  bugs: {
    url: "https://github.com/lightsparkdev/js-sdk/issues"
  },
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      import: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      },
      require: {
        types: "./dist/index.d.ts",
        default: "./dist/index.cjs"
      }
    },
    "./env": {
      types: "./dist/env.d.ts",
      import: {
        types: "./dist/env.d.ts",
        default: "./dist/env.js"
      },
      module: "./dist/env.js",
      require: "./dist/env.cjs",
      default: "./dist/env.cjs"
    },
    "./objects": {
      types: "./dist/objects/index.d.ts",
      import: {
        types: "./dist/objects/index.d.ts",
        default: "./dist/objects/index.js"
      },
      require: {
        types: "./dist/objects/index.d.ts",
        default: "./dist/objects/index.cjs"
      }
    }
  },
  type: "module",
  types: "./dist/index.d.ts",
  main: "./dist/index.js",
  module: "./dist/index.js",
  browser: {
    crypto: false
  },
  files: [
    "src/*",
    "dist/*",
    "CHANGELOG.md"
  ],
  scripts: {
    build: "yarn tsc && tsup",
    "build:watch": "yarn build --watch --clean=false",
    clean: "rm -rf .turbo && rm -rf dist",
    dev: "yarn build -- --watch",
    docs: "typedoc --media docs-media src",
    "format:fix": "prettier src --write",
    format: "prettier src --check",
    "lint:fix": "eslint --fix .",
    "lint:fix:continue": "eslint --fix . || exit 0",
    "lint:watch": "esw ./src -w --ext .ts,.tsx,.js --color",
    lint: "eslint .",
    postversion: "yarn build",
    test: 'echo "TODO"',
    "test:integration": "node --experimental-vm-modules $(yarn bin jest) --no-cache --runInBand --bail",
    types: "tsc"
  },
  license: "Apache-2.0",
  dependencies: {
    "@lightsparkdev/core": "1.1.0",
    "@react-native-async-storage/async-storage": "^1.18.1",
    "crypto-browserify": "^3.12.0",
    dayjs: "^1.11.7",
    dotenv: "^16.3.1",
    graphql: "^16.6.0",
    "graphql-ws": "^5.11.3",
    react: "^18.2.0",
    ws: "^8.12.1",
    "zen-observable-ts": "^1.1.0"
  },
  devDependencies: {
    "@lightsparkdev/eslint-config": "*",
    "@types/chrome": "^0.0.254",
    "@types/crypto-js": "^4.1.1",
    "@types/ws": "^8.5.4",
    "auto-bind": "^5.0.1",
    eslint: "^8.3.0",
    "eslint-watch": "^8.0.0",
    jest: "^29.6.2",
    jsonwebtoken: "^9.0.1",
    prettier: "3.0.3",
    "prettier-plugin-organize-imports": "^3.2.4",
    "ts-jest": "^29.1.1",
    tsup: "^7.2.0",
    typedoc: "^0.24.7",
    typescript: "^5.0.0"
  },
  engines: {
    node: ">=18"
  }
};

// src/graqhql/BitcoinFeeEstimate.ts
var BitcoinFeeEstimateQuery = `
  query BitcoinFeeEstimate {
    bitcoin_fee_estimate {
      ...FeeEstimateFragment
    }
  }

  ${FRAGMENT}
`;
var BitcoinFeeEstimate_default = BitcoinFeeEstimateQuery;

// src/graqhql/CancelInvoice.ts
var CancelInvoice = `
  mutation CancelInvoice(
    $invoice_id: ID!
  ) {
    cancel_invoice(input: { invoice_id: $invoice_id }) {
      invoice {
        ...InvoiceFragment
      }
    }
  }

  ${FRAGMENT3}
`;

// src/graqhql/CreateBitcoinFundingAddress.ts
var CreateBitcoinFundingAddress = `
  mutation CreateBitcoinFundingAddress {
    create_bitcoin_funding_address {
        bitcoin_address
    }
  }
`;
var CreateBitcoinFundingAddress_default = CreateBitcoinFundingAddress;

// src/graqhql/CreateInvoice.ts
var CreateInvoiceMutation = `
  mutation CreateInvoice(
    $amountMsats: Long!
    $memo: String
    $type: InvoiceType = null
    $expirySecs: Int = null
    ) {
    create_invoice(input: { amount_msats: $amountMsats, memo: $memo, invoice_type: $type, expiry_secs: $expirySecs }) {
      invoice {
        ...InvoiceFragment
      }
    }
  }
  
  ${FRAGMENT3}
`;
var CreateInvoice_default = CreateInvoiceMutation;

// src/graqhql/CreateTestModeInvoice.ts
var CreateTestModeInvoice = `
mutation CreateTestModeInvoice(
  $amount_msats: Long!
  $memo: String
  $invoice_type: InvoiceType
) {
  create_test_mode_invoice(input: {
      amount_msats: $amount_msats
      memo: $memo
      invoice_type: $invoice_type
  }) {
      encoded_payment_request
  }
}
`;
var CreateTestModeInvoice_default = CreateTestModeInvoice;

// src/graqhql/CreateTestModePayment.ts
var CreateTestModePayment = `
mutation CreateTestModePayment(
  $encoded_invoice: String!
  $amount_msats: Long
) {
  create_test_mode_payment(input: {
      encoded_invoice: $encoded_invoice
      amount_msats: $amount_msats
  }) {
      incoming_payment {
          ...IncomingPaymentFragment
      }
  }
}

${FRAGMENT4}
`;
var CreateTestModePayment_default = CreateTestModePayment;

// src/graqhql/CurrentWallet.ts
var CurrentWalletQuery = `
query CurrentWallet {
    current_wallet {
        ...WalletFragment
    }
}

${FRAGMENT9}
`;
var CurrentWallet_default = CurrentWalletQuery;

// src/graqhql/DecodeInvoice.ts
var DecodeInvoiceQuery = `
  query DecodeInvoice($encoded_payment_request: String!) {
    decoded_payment_request(encoded_payment_request: $encoded_payment_request) {
      __typename
      ... on InvoiceData {
        ...InvoiceDataFragment
      }
    }
  }

${FRAGMENT2}
`;
var DecodeInvoice_default = DecodeInvoiceQuery;

// src/graqhql/DeployWallet.ts
var DeployWallet = `
  mutation DeployWallet {
    deploy_wallet {
      ...DeployWalletOutputFragment
    }
  }
  
  ${FRAGMENT10}
`;
var DeployWallet_default = DeployWallet;

// src/graqhql/InitializeWallet.ts
var InitializeWallet = `
  mutation InitializeWallet($key_type: KeyType!, $signing_public_key: String!) {
    initialize_wallet(input: {
        signing_public_key: { type: $key_type, public_key: $signing_public_key }
    }) {
        ...InitializeWalletOutputFragment
    }
  }

  ${FRAGMENT11}
`;
var InitializeWallet_default = InitializeWallet;

// src/graqhql/LightningFeeEstimateForInvoice.ts
var LightningFeeEstimateForInvoiceQuery = `
  query LightningFeeEstimateForInvoice(
    $encoded_payment_request: String!
    $amount_msats: Long
  ) {
    lightning_fee_estimate_for_invoice(input: {
      encoded_payment_request: $encoded_payment_request,
      amount_msats: $amount_msats
    }) {
      ...LightningFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT12}
`;
var LightningFeeEstimateForInvoice_default = LightningFeeEstimateForInvoiceQuery;

// src/graqhql/LightningFeeEstimateForNode.ts
var LightningFeeEstimateForNodeQuery = `
  query LightningFeeEstimateForNode(
    $destination_node_public_key: String!
    $amount_msats: Long!
  ) {
    lightning_fee_estimate_for_node(input: {
      destination_node_public_key: $destination_node_public_key,
      amount_msats: $amount_msats
    }) {
      ...LightningFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT12}
`;
var LightningFeeEstimateForNode_default = LightningFeeEstimateForNodeQuery;

// src/graqhql/LoginWithJWT.ts
var LoginWithJWT = `
  mutation LoginWithJWT($account_id: ID!, $jwt: String!) {
    login_with_jwt(input: { account_id: $account_id, jwt: $jwt }) {
        ...LoginWithJWTOutputFragment
    }
  }

  ${FRAGMENT13}
`;
var LoginWithJWT_default = LoginWithJWT;

// src/graqhql/PayInvoice.ts
var PayInvoiceMutation = `
  mutation PayInvoice(
    $encoded_invoice: String!
    $timeout_secs: Int!
    $maximum_fees_msats: Long!
    $amount_msats: Long
  ) {
    pay_invoice(
      input: {
        encoded_invoice: $encoded_invoice
        timeout_secs: $timeout_secs
        amount_msats: $amount_msats
        maximum_fees_msats: $maximum_fees_msats
      }
    ) {
      payment {
        ...OutgoingPaymentFragment
      }
    }
  }

  ${FRAGMENT14}
`;
var PayInvoice_default = PayInvoiceMutation;

// src/graqhql/RequestWithdrawal.ts
var RequestWithdrawalMutation = `
  mutation RequestWithdrawal(
    $amount_sats: Long!
    $bitcoin_address: String!
  ) {
    request_withdrawal(input: {
        amount_sats: $amount_sats
        bitcoin_address: $bitcoin_address
    }) {
        request {
            ...WithdrawalRequestFragment
        }
    }
  }

  ${FRAGMENT8}
`;
var RequestWithdrawal_default = RequestWithdrawalMutation;

// src/graqhql/SendPayment.ts
var SendPaymentMutation = `
  mutation SendPayment(
    $destination_public_key: String!
    $timeout_secs: Int!
    $amount_msats: Long!
    $maximum_fees_msats: Long!
  ) {
    send_payment(
      input: {
        destination_public_key: $destination_public_key
        timeout_secs: $timeout_secs
        amount_msats: $amount_msats
        maximum_fees_msats: $maximum_fees_msats
      }
    ) {
      payment {
        ...OutgoingPaymentFragment
      }
    }
  }

  ${FRAGMENT14}
`;
var SendPayment_default = SendPaymentMutation;

// src/graqhql/TerminateWallet.ts
var TerminateWallet = `
  mutation TerminateWallet {
    terminate_wallet {
      ...TerminateWalletOutputFragment
    }
  }
  
    ${FRAGMENT15}
`;
var TerminateWallet_default = TerminateWallet;

// src/graqhql/WalletDashboard.ts
var WalletDashboardQuery = `
query WalletDashboard(
    $numTransactions: Int,
    $numPaymentRequests: Int,
    $transactionsAfterDate: DateTime = null,
    $paymentRequestsAfterDate: DateTime = null,
    $transactionTypes: [TransactionType!] = [CHANNEL_OPEN, CHANNEL_CLOSE, L1_DEPOSIT, L1_WITHDRAW, INCOMING_PAYMENT, OUTGOING_PAYMENT],
    $transactionStatuses: [TransactionStatus!] = [SUCCESS, FAILED, PENDING]
) {
    current_wallet {
        id
        balances {
            ...BalancesFragment
        }
        status
        recent_transactions: transactions(
            first: $numTransactions
            types: $transactionTypes
            statuses: $transactionStatuses
            created_after_date: $transactionsAfterDate
        ) {
            wallet_to_transactions_connection_count: count
            wallet_to_transactions_connection_entities: entities {
                ...TransactionFragment
            }
            wallet_to_transactions_connection_page_info: page_info {
                page_info_has_next_page: has_next_page
                page_info_has_previous_page: has_previous_page
                page_info_start_cursor: start_cursor
                page_info_end_cursor: end_cursor
            }
            type: __typename
        }
        payment_requests(
            first: $numPaymentRequests
            created_after_date: $paymentRequestsAfterDate
        ) {
            wallet_to_payment_requests_connection_count: count
            wallet_to_payment_requests_connection_entities: entities {
                ...PaymentRequestFragment
            }
            wallet_to_payment_requests_connection_page_info: page_info {
                page_info_has_next_page: has_next_page
                page_info_has_previous_page: has_previous_page
                page_info_start_cursor: start_cursor
                page_info_end_cursor: end_cursor
            }
        }
    }
}

${FRAGMENT7}
${FRAGMENT5}
${FRAGMENT6}
`;
var WalletDashboard_default = WalletDashboardQuery;

// src/graqhql/WithdrawalFeeEstimate.ts
var WithdrawalFeeEstimate = `
  query WithdrawalFeeEstimate(
    $amount_sats: Long!
    $withdrawal_mode: WithdrawalMode!
  ) {
    withdrawal_fee_estimate(input: {
      amount_sats: $amount_sats,
      withdrawal_mode: $withdrawal_mode
    }) {
      ...WithdrawalFeeEstimateOutputFragment
    }
  }

  ${FRAGMENT16}
`;

// src/logger.ts
import { ConfigKeys, isTest, Logger } from "@lightsparkdev/core";
import AsyncStorage from "@react-native-async-storage/async-storage";
var logger = new Logger("@lightsparkdev/wallet-sdk", async () => {
  try {
    if (isTest) {
      return true;
    }
    const enabled = await AsyncStorage.getItem(
      ConfigKeys.LoggingEnabled
    );
    return enabled === "1";
  } catch (e) {
    return false;
  }
});

// src/client.ts
function isOutgoingPayment(payment) {
  return Boolean(
    payment && typeof payment === "object" && "typename" in payment && payment.typename === "OutgoingPayment"
  );
}
var sdkVersion = package_default.version;
var LightsparkClient = class {
  /**
   * Constructs a new LightsparkClient.
   *
   * @param authProvider The auth provider to use for authentication. Defaults to a stub auth provider. For server-side
   *     use, you should use the `AccountTokenAuthProvider`.
   * @param serverUrl The base URL of the server to connect to. Defaults to lightspark production.
   * @param cryptoImpl The crypto implementation to use. Defaults to web and node compatible crypto.
   *     For React Native, you should use the `ReactNativeCrypto`
   *     implementation from `@lightsparkdev/react-native`.
   * @param signingKeyType The type of signing key used in the LightsparkClient. Different signing operations are used depending on the key type.
   */
  constructor(authProvider = new StubAuthProvider(), serverUrl = "api.lightspark.com", cryptoImpl = DefaultCrypto, signingKeyType = SigningKeyType.RSASigningKey) {
    this.authProvider = authProvider;
    this.serverUrl = serverUrl;
    this.cryptoImpl = cryptoImpl;
    this.signingKeyType = signingKeyType;
    this.nodeKeyCache = new NodeKeyCache(this.cryptoImpl);
    this.requester = new Requester(
      this.nodeKeyCache,
      WALLET_SDK_ENDPOINT,
      `js-wallet-sdk/${sdkVersion}`,
      authProvider,
      serverUrl,
      this.cryptoImpl
    );
    autoBind(this);
  }
  requester;
  nodeKeyCache;
  /**
   * Sets the auth provider for the client.
   * This is useful for switching between auth providers if you are using
   * multiple accounts or waiting for the user to log in.
   *
   * @param authProvider
   */
  setAuthProvider(authProvider) {
    this.requester = new Requester(
      this.nodeKeyCache,
      WALLET_SDK_ENDPOINT,
      `js-wallet-sdk/${sdkVersion}`,
      authProvider,
      this.serverUrl,
      this.cryptoImpl
    );
    this.authProvider = authProvider;
  }
  /**
   * @returns Whether or not the client is authorized. This is useful for determining if the user is logged in or not.
   */
  async isAuthorized() {
    return this.authProvider.isAuthorized();
  }
  /**
   * Login using the Custom JWT authentication scheme described in our
   * documentation.
   *
   * Note: When using this method, you are responsible for refreshing the JWT
   * token before or when it expires. If the token expires,
   * the client will throw a [LightsparkAuthenticationException] on the next
   * API call which requires valid authentication.
   * Then you'll need to call this method again to get a new token.
   *
   * @param accountId The account ID to login with. This is specific to your company's account.
   * @param jwt The JWT to use for authentication of this user.
   * @param storage The storage to use for storing the JWT token.
   * @return The output of the login operation, including the access token, expiration time, and wallet info.
   */
  async loginWithJWT(accountId, jwt, storage) {
    const response = await this.executeRawQuery({
      queryPayload: LoginWithJWT_default,
      variables: {
        account_id: accountId,
        jwt
      },
      constructObject: (responseJson) => {
        return LoginWithJWTOutputFromJson(responseJson.login_with_jwt);
      },
      skipAuth: true
    });
    if (!response) {
      throw new LightsparkAuthException(
        "Login failed. Please check your credentials and try again."
      );
    }
    const authProvider = new CustomJwtAuthProvider_default(storage);
    await authProvider.setTokenInfo({
      accessToken: response.accessToken,
      validUntil: new Date(response.validUntil)
    });
    this.setAuthProvider(authProvider);
    return response;
  }
  /**
   * Deploys a wallet in the Lightspark infrastructure.
   * This is an asynchronous operation,
   * the caller should then poll the wallet frequently (or subscribe to its
   * modifications). When this process is over,
   * the Wallet status will change to `DEPLOYED` (or `FAILED`).
   *
   * @return The wallet that was deployed.
   */
  async deployWallet() {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: DeployWallet_default,
      constructObject: (responseJson) => {
        return DeployWalletOutputFromJson(responseJson.deploy_wallet).wallet;
      }
    });
  }
  /**
   * Deploys a wallet in the Lightspark infrastructure and waits for it to be
   * deployed. This is an asynchronous operation,
   * which will continue processing wallet status updates until the Wallet
   * status changes to `DEPLOYED` (or `FAILED`).
   *
   * @return A Promise with the final wallet status after deployment or failure.
   * @throws LightsparkException if the wallet status is not `DEPLOYED` or `FAILED` after 60 seconds,
   * or if the subscription fails.
   */
  async deployWalletAndAwaitDeployed() {
    const wallet = await this.deployWallet();
    if (wallet?.status === WalletStatus_default.DEPLOYED || wallet?.status === WalletStatus_default.FAILED) {
      return wallet.status;
    }
    return await this.waitForWalletStatus([
      WalletStatus_default.DEPLOYED,
      WalletStatus_default.FAILED
    ]);
  }
  /**
   * Initializes a wallet in the Lightspark infrastructure and syncs it to the
   * Bitcoin network. This is an asynchronous operation,
   * the caller should then poll the wallet frequently (or subscribe to its
   * modifications). When this process is over,
   * the Wallet status will change to `READY` (or `FAILED`).
   *
   * @param keyType The type of key to use for the wallet.
   * @param signingPublicKey The base64-encoded public key to use for signing transactions.
   * @param signingPrivateKeyOrAlias An object containing either the base64-encoded private key or, in the case of
   *     React Native, a key alias for a key in the mobile keystore.
   *     The key will be used for signing transactions.
   *     This key will not leave the device.
   *     It is only used for signing transactions locally.
   * @return The wallet that was initialized.
   */
  async initializeWallet(keyType, signingPublicKey, signingPrivateKeyOrAlias) {
    await this.requireValidAuth();
    await this.loadWalletSigningKey(signingPrivateKeyOrAlias);
    return await this.executeRawQuery({
      queryPayload: InitializeWallet_default,
      variables: {
        key_type: keyType,
        signing_public_key: signingPublicKey
      },
      signingNodeId: WALLET_NODE_ID_KEY,
      constructObject: (responseJson) => {
        return InitializeWalletOutputFromJson(responseJson.initialize_wallet).wallet;
      }
    });
  }
  /**
   * Initializes a wallet in the Lightspark infrastructure and syncs it to the
   * Bitcoin network. This is an asynchronous operation,
   * which will continue processing wallet status updates until the Wallet
   * status changes to `READY` (or `FAILED`).
   *
   * @param keyType The type of key to use for the wallet.
   * @param signingPublicKey The base64-encoded public key to use for signing transactions.
   * @param signingPrivateKeyOrAlias An object containing either the base64-encoded private key or, in the case of
   *     React Native, a key alias for a key in the mobile keystore.
   *     The key will be used for signing transactions.
   *     This key will not leave the device.
   *     It is only used for signing transactions locally.
   * @return A Promise with the final wallet status after initialization or failure.
   * @throws LightsparkException if the wallet status is not `READY` or `FAILED` after 5 minutes,
   * or if the subscription fails.
   */
  async initializeWalletAndAwaitReady(keyType, signingPublicKey, signingPrivateKeyOrAlias) {
    const wallet = await this.initializeWallet(
      keyType,
      signingPublicKey,
      signingPrivateKeyOrAlias
    );
    if (wallet?.status === WalletStatus_default.READY || wallet?.status === WalletStatus_default.FAILED) {
      return wallet.status;
    }
    return await this.waitForWalletStatus(
      [WalletStatus_default.READY, WalletStatus_default.FAILED],
      300
    );
  }
  /**
   * Removes the wallet from Lightspark infrastructure.
   * It won't be connected to the Lightning network anymore and its funds won't
   * be accessible outside of the Funds Recovery Kit process.
   *
   * @return The wallet that was terminated.
   */
  async terminateWallet() {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: TerminateWallet_default,
      constructObject: (responseJson) => {
        return TerminateWalletOutputFromJson(responseJson.terminate_wallet).wallet;
      }
    });
  }
  /**
   * Get the dashboard overview for a Lightning wallet.
   * Includes balance info and the most recent transactions and payment
   * requests.
   *
   * @param numTransactions The max number of recent transactions to fetch. Defaults to 20.
   * @param numPaymentRequests The max number of recent payment requests to fetch. Defaults to 20.
   * @return The dashboard overview for the wallet, including balance and recent transactions and payment requests.
   */
  async getWalletDashboard(numTransactions = 20, numPaymentRequests = 20) {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: WalletDashboard_default,
      variables: {
        numTransactions,
        numPaymentRequests
      },
      constructObject: (responseJson) => {
        const currentWallet = responseJson.current_wallet;
        if (!currentWallet) {
          return null;
        }
        return {
          id: currentWallet.id,
          status: currentWallet.status,
          balances: currentWallet.balances && BalancesFromJson(currentWallet.balances),
          recentTransactions: currentWallet.recent_transactions && WalletToTransactionsConnectionFromJson(
            currentWallet.recent_transactions
          ),
          paymentRequests: currentWallet.payment_requests && WalletToPaymentRequestsConnectionFromJson(
            currentWallet.payment_requests
          )
        };
      }
    });
  }
  /**
   * Creates a lightning invoice from the current wallet.
   *
   * Test mode note: You can simulate a payment of this invoice in test move
   * using [createTestModePayment].
   *
   * @param amountMsats The amount of the invoice in milli-satoshis.
   * @param memo Optional memo to include in the invoice.
   * @param type The type of invoice to create. Defaults to [InvoiceType.STANDARD].
   * @param expirySecs The number of seconds until the invoice expires. Defaults to 1 day.
   * @return The created invoice.
   */
  async createInvoice(amountMsats, memo = void 0, type = InvoiceType_default.STANDARD, expirySecs = void 0) {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CreateInvoice_default,
      variables: {
        amountMsats,
        memo,
        type,
        expirySecs
      },
      constructObject: (responseJson) => {
        return InvoiceFromJson(responseJson.create_invoice.invoice);
      }
    });
  }
  /**
   * Cancels an existing unpaid invoice and returns that invoice. Cancelled invoices cannot be paid.
   *
   * @param invoiceId The ID of the invoice to cancel.
   * @returns The cancelled invoice, or undefined if the invoice could not be cancelled.
   */
  async cancelInvoice(invoiceId) {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CancelInvoice,
      variables: {
        invoice_id: invoiceId
      },
      constructObject: (responseJson) => {
        return InvoiceFromJson(responseJson.cancel_invoice.invoice);
      }
    });
  }
  /**
   * Pay a lightning invoice from the current wallet.
   * This function will return immediately with the payment details,
   * which may still be in a PENDING state.
   * You can use the [payInvoiceAndAwaitResult] function to wait for the
   * payment to complete or fail.
   *
   * Note: This call will fail if the wallet is not unlocked yet via
   * [loadWalletSigningKey]. You must successfully unlock the wallet before
   * calling this function.
   *
   * Test mode note: For test mode, you can use the [createTestModeInvoice]
   * function to create an invoice you can pay in test mode.
   *
   * @param encodedInvoice An encoded string representation of the invoice to pay.
   * @param maxFeesMsats The maximum fees to pay in milli-satoshis. You must pass a value.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @param amountMsats The amount to pay in milli-satoshis. Defaults to the full amount of the invoice.
   * @param timeoutSecs The number of seconds to wait for the payment to complete. Defaults to 60.
   * @return The payment details, which may still be in a PENDING state. You can use the [payInvoiceAndAwaitResult]
   *     function to wait for the payment to complete or fail.
   */
  async payInvoice(encodedInvoice, maxFeesMsats, amountMsats = void 0, timoutSecs = 60) {
    await this.requireValidAuth();
    this.requireWalletUnlocked();
    const variables = {
      encoded_invoice: encodedInvoice,
      maximum_fees_msats: maxFeesMsats,
      timeout_secs: timoutSecs
    };
    if (amountMsats !== void 0) {
      variables.amount_msats = amountMsats;
    }
    const payment = await this.executeRawQuery({
      queryPayload: PayInvoice_default,
      variables,
      constructObject: (responseJson) => {
        return OutgoingPaymentFromJson(responseJson.pay_invoice.payment);
      },
      signingNodeId: WALLET_NODE_ID_KEY
    });
    if (!payment) {
      throw new LightsparkException(
        "PaymentNullError",
        "Unknown error paying invoice"
      );
    }
    return payment;
  }
  /**
   * Pay a lightning invoice from the current wallet and wait for the payment
   * to complete or fail.
   *
   * Note: This call will fail if the wallet is not unlocked yet via
   * [loadWalletSigningKey]. You must successfully unlock the wallet before
   * calling this function.
   *
   * @param encodedInvoice An encoded string representation of the invoice to pay.
   * @param maxFeesMsats The maximum fees to pay in milli-satoshis. You must pass a value.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @param amountMsats The amount to pay in milli-satoshis. Defaults to the full amount of the invoice.
   * @param timeoutSecs The number of seconds to wait for the payment to complete. Defaults to 60.
   * @return The payment details.
   */
  async payInvoiceAndAwaitResult(encodedInvoice, maxFeesMsats, amountMsats = void 0, timeoutSecs = 60) {
    logger.trace(`payInvoiceAndAwaitResult params`, {
      encodedInvoice,
      maxFeesMsats,
      amountMsats,
      timeoutSecs
    });
    const payment = await this.payInvoice(
      encodedInvoice,
      maxFeesMsats,
      amountMsats,
      timeoutSecs
    );
    logger.trace(`payInvoiceAndAwaitResult payment`, {
      paymentId: payment.id,
      paymentStatus: payment.status
    });
    const paymentResult = await this.awaitPaymentResult(payment, timeoutSecs);
    return paymentResult;
  }
  async awaitPaymentResult(payment, timeoutSecs = 60) {
    logger.trace(`awaitPaymentResult payment`, {
      paymentId: payment.id,
      paymentStatus: payment.status
    });
    const completionStatuses = [
      TransactionStatus_default.FAILED,
      TransactionStatus_default.CANCELLED,
      TransactionStatus_default.SUCCESS
    ];
    logger.trace(`awaitPaymentResult payment.status`, payment.status);
    if (completionStatuses.includes(payment.status)) {
      return Promise.resolve(payment);
    }
    const timeoutError = new LightsparkException(
      "PaymentStatusAwaitError",
      `Timed out waiting for payment status to be one of ${completionStatuses.join(
        ", "
      )}.`
    );
    const pollIntervalMs = 500;
    const ignoreErrors = false;
    const isOutgoing = isOutgoingPayment(payment);
    const paymentResult = await pollUntil(
      () => {
        return this.executeRawQuery({
          queryPayload: `
          query ${isOutgoing ? "Outgoing" : "Incoming"}PaymentStatusQuery {
            entity(id: "${payment.id}") {
              ...${isOutgoing ? "OutgoingPaymentFragment" : "IncomingPaymentFragment"}
            }
          }
          ${isOutgoing ? FRAGMENT14 : FRAGMENT4}
        `,
          constructObject: (responseJson) => {
            return isOutgoing ? OutgoingPaymentFromJson(responseJson.entity) : IncomingPaymentFromJson(responseJson.entity);
          }
        });
      },
      (current, response) => {
        logger.trace(`pollUntil current`, current);
        if (current && completionStatuses.includes(current.status)) {
          return {
            stopPolling: true,
            value: current
          };
        }
        return response;
      },
      timeoutSecs * 1e3 / pollIntervalMs,
      pollIntervalMs,
      ignoreErrors,
      () => timeoutError
    );
    return paymentResult;
  }
  /**
   * Sends a payment directly to a node on the Lightning Network through the
   * public key of the node without an invoice.
   * This function will return immediately with the payment details,
   * which may still be in a PENDING state.
   * You can use the [sendPaymentAndAwaitResult] function to wait for the
   * payment to complete or fail.
   *
   * @param destinationPublicKey The public key of the destination node.
   * @param amountMsats The amount to pay in milli-satoshis.
   * @param maxFeesMsats The maximum amount of fees that you want to pay for this payment to be sent.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @param timeoutSecs The timeout in seconds that we will try to make the payment.
   * @return An `OutgoingPayment` object, which may still be in a PENDING state. You can use the
   *     [sendPaymentAndAwaitResult] function to wait for the payment to
   *     complete or fail.
   */
  async sendPayment(destinationNodePublicKey, amountMsats, maxFeesMsats, timeoutSecs = 60) {
    await this.requireValidAuth();
    this.requireWalletUnlocked();
    const payment = await this.executeRawQuery({
      queryPayload: SendPayment_default,
      variables: {
        destination_node_public_key: destinationNodePublicKey,
        amount_msats: amountMsats,
        maximum_fees_msats: maxFeesMsats,
        timeout_secs: timeoutSecs
      },
      constructObject: (responseJson) => {
        return OutgoingPaymentFromJson(responseJson.send_payment.payment);
      },
      signingNodeId: WALLET_NODE_ID_KEY
    });
    if (!payment) {
      throw new LightsparkException(
        "PaymentNullError",
        "Unknown error sending payment"
      );
    }
    return payment;
  }
  /**
   * Sends a payment directly to a node on the Lightning Network through the
   * public key of the node without an invoice.
   * Waits for the payment to complete or fail.
   *
   * @param destinationPublicKey The public key of the destination node.
   * @param amountMsats The amount to pay in milli-satoshis.
   * @param maxFeesMsats The maximum amount of fees that you want to pay for this payment to be sent.
   *     As guidance, a maximum fee of 15 basis points should make almost all
   *     transactions succeed. For example,
   *     for a transaction between 10k sats and 100k sats,
   *     this would mean a fee limit of 15 to 150 sats.
   * @param timeoutSecs The timeout in seconds that we will try to make the payment.
   * @return An `OutgoingPayment` object. Check the `status` field to see if the payment succeeded or failed.
   */
  async sendPaymentAndAwaitResult(destinationNodePublicKey, amountMsats, maxFeesMsats, timeoutSecs = 60) {
    const payment = await this.sendPayment(
      destinationNodePublicKey,
      amountMsats,
      maxFeesMsats,
      timeoutSecs
    );
    return await this.awaitPaymentResult(payment, timeoutSecs);
  }
  /**
   * Decode a lightning invoice to get its details included payment amount,
   * destination, etc.
   *
   * @param encodedInvoice An encoded string representation of the invoice to decode.
   * @return The decoded invoice details.
   */
  async decodeInvoice(encodedInvoice) {
    return await this.executeRawQuery({
      queryPayload: DecodeInvoice_default,
      variables: {
        encoded_payment_request: encodedInvoice
      },
      constructObject: (responseJson) => {
        return InvoiceDataFromJson(responseJson.decoded_payment_request);
      }
    });
  }
  /**
   * Gets an estimate of the fee for sending a payment over the given bitcoin
   * network.
   *
   * @param bitcoinNetwork The bitcoin network for which to get a fee estimate. Defaults to MAINNET.
   * @returns A fee estimate for the given bitcoin network including a minimum fee rate, and a max-speed fee rate.
   */
  async getBitcoinFeeEstimate() {
    const response = await this.requester.makeRawRequest(
      BitcoinFeeEstimate_default
    );
    return FeeEstimateFromJson(response.bitcoin_fee_estimate);
  }
  /**
   * Gets an estimate of the fees that will be paid for a Lightning invoice.
   *
   * @param encodedPaymentRequest The invoice you want to pay (as defined by the BOLT11 standard).
   * @param amountMsats If the invoice does not specify a payment amount, then the amount that you wish to pay,
   *     expressed in msats.
   * @returns An estimate of the fees that will be paid for a Lightning invoice.
   */
  async getLightningFeeEstimateForInvoice(encodedPaymentRequest, amountMsats = void 0) {
    await this.requireValidAuth();
    const response = await this.requester.makeRawRequest(
      LightningFeeEstimateForInvoice_default,
      {
        encoded_payment_request: encodedPaymentRequest,
        amount_msats: amountMsats
      }
    );
    return CurrencyAmountFromJson(
      response.lightning_fee_estimate_for_invoice.lightning_fee_estimate_output_fee_estimate
    );
  }
  /**
   * Returns an estimate of the fees that will be paid to send a payment to
   * another Lightning node.
   *
   * @param destinationNodePublicKey The public key of the node that you want to pay.
   * @param amountMsats The payment amount expressed in msats.
   * @returns An estimate of the fees that will be paid to send a payment to another Lightning node.
   */
  async getLightningFeeEstimateForNode(destinationNodePublicKey, amountMsats) {
    await this.requireValidAuth();
    const response = await this.requester.makeRawRequest(
      LightningFeeEstimateForNode_default,
      {
        destination_node_public_key: destinationNodePublicKey,
        amount_msats: amountMsats
      }
    );
    return CurrencyAmountFromJson(
      response.lightning_fee_estimate_for_node.lightning_fee_estimate_output_fee_estimate
    );
  }
  /**
   * Returns an estimated amount for the L1 withdrawal fees for the specified node, amount, and
   * strategy.
   *
   * @param amountSats The amount you want to withdraw from this node in Satoshis. Use the special value -1 to
   *     withdrawal all funds from this wallet.
   * @param withdrawalMode The strategy that should be used to withdraw the funds from this node.
   * @returns An estimated amount for the L1 withdrawal fees for the specified node, amount, and strategy.
   */
  async getWithrawalFeeEstimate(amountSats, withdrawalMode) {
    const response = await this.executeRawQuery({
      queryPayload: WithdrawalFeeEstimate,
      variables: {
        amount_sats: amountSats,
        withdrawal_mode: withdrawalMode
      },
      constructObject: (response2) => {
        return WithdrawalFeeEstimateOutputFromJson(
          response2.withdrawal_fee_estimate
        );
      }
    });
    if (!response) {
      throw new LightsparkException(
        "WithdrawalFeeEstimateError",
        "Null or invalid fee estimate response from server"
      );
    }
    return response.feeEstimate;
  }
  /**
   * Unlocks the wallet for use with the SDK for the current application
   * session. This function must be called before any other functions that
   * require wallet signing keys, including [payInvoice].
   *
   * This function is intended for use in cases where the wallet's private
   * signing key is already saved by the application outside of the SDK.
   * It is the responsibility of the application to ensure that the key is
   * valid and that it is the correct key for the wallet.
   * Otherwise signed requests will fail.
   *
   * @param signingKeyBytesOrAlias An object holding either the PEM encoded bytes of the wallet's private signing key or,
   *     in the case of ReactNative, the alias of the key in the mobile
   *     keychain.
   */
  loadWalletSigningKey(signingKeyBytesOrAlias) {
    return this.nodeKeyCache.loadKey(
      WALLET_NODE_ID_KEY,
      signingKeyBytesOrAlias,
      SigningKeyType.RSASigningKey
    );
  }
  /**
   * Creates an L1 Bitcoin wallet address which can be used to deposit or
   * withdraw funds from the Lightning wallet.
   *
   * @return The newly created L1 wallet address.
   */
  async createBitcoinFundingAddress() {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CreateBitcoinFundingAddress_default,
      constructObject: (responseJson) => {
        return responseJson.create_bitcoin_funding_address.bitcoin_address;
      }
    });
  }
  /**
   * @return The current wallet if one exists, null otherwise.
   */
  async getCurrentWallet() {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CurrentWallet_default,
      constructObject: (responseJson) => {
        return WalletFromJson(responseJson.current_wallet);
      }
    });
  }
  /**
   * Withdraws funds from the account and sends it to the requested bitcoin
   * address.
   *
   * The process is asynchronous and may take up to a few minutes.
   * You can check the progress by polling the `WithdrawalRequest` that is
   * created, or by subscribing to a webhook.
   *
   * @param amountSats The amount of funds to withdraw in SATOSHI.
   * @param bitcoinAddress The Bitcoin address to withdraw funds to.
   */
  async requestWithdrawal(amountSats, bitcoinAddress) {
    await this.requireValidAuth();
    this.requireWalletUnlocked();
    return await this.executeRawQuery({
      queryPayload: RequestWithdrawal_default,
      variables: {
        amount_sats: amountSats,
        bitcoin_address: bitcoinAddress
      },
      constructObject: (responseJson) => {
        return WithdrawalRequestFromJson(
          responseJson.request_withdrawal.request
        );
      },
      signingNodeId: WALLET_NODE_ID_KEY
    });
  }
  /**
   * In test mode, generates a Lightning Invoice which can be paid by a local
   * node. This call is only valid in test mode.
   * You can then pay the invoice using [payInvoice].
   *
   * @param amountMsats The amount to pay in milli-satoshis.
   * @param memo An optional memo to attach to the invoice.
   * @param invoiceType The type of invoice to create.
   */
  async createTestModeInvoice(amountMsats, memo = void 0, invoiceType = InvoiceType_default.STANDARD) {
    await this.requireValidAuth();
    return await this.executeRawQuery({
      queryPayload: CreateTestModeInvoice_default,
      variables: {
        amount_msats: amountMsats,
        memo,
        invoice_type: invoiceType
      },
      constructObject: (responseJson) => {
        const encodedPaymentRequest = responseJson.create_test_mode_invoice?.encoded_payment_request;
        if (!encodedPaymentRequest) {
          throw new LightsparkException(
            "CreateTestModeInvoiceError",
            "Unable to create test mode invoice"
          );
        }
        return encodedPaymentRequest;
      }
    });
  }
  /**
   * In test mode, simulates a payment of a Lightning Invoice from another
   * node. This can only be used in test mode and should be used with invoices
   * generated by [createInvoice].
   *
   * @param encodedInvoice The encoded invoice to pay.
   * @param amountMsats The amount to pay in milli-satoshis for 0-amount invoices. This should be null for non-zero
   *     amount invoices.
   */
  async createTestModePayment(encodedInvoice, amountMsats = void 0) {
    await this.requireValidAuth();
    this.requireWalletUnlocked();
    return await this.executeRawQuery({
      queryPayload: CreateTestModePayment_default,
      variables: {
        encoded_invoice: encodedInvoice,
        amount_msats: amountMsats
      },
      constructObject: (responseJson) => {
        return IncomingPaymentFromJson(
          responseJson.create_test_mode_payment?.incoming_payment
        );
      },
      signingNodeId: WALLET_NODE_ID_KEY
    });
  }
  /**
   * @return True if the wallet is unlocked or false if it is locked.
   */
  isWalletUnlocked() {
    return this.nodeKeyCache.hasKey(WALLET_NODE_ID_KEY);
  }
  async requireValidAuth() {
    if (!await this.isAuthorized()) {
      throw new LightsparkAuthException(
        "You must be logged in to perform this action."
      );
    }
  }
  requireWalletUnlocked() {
    if (!this.isWalletUnlocked()) {
      throw new LightsparkAuthException(
        "You must unlock the wallet before performing this action."
      );
    }
  }
  waitForWalletStatus(statuses, timeoutSecs = 60) {
    let timeout;
    let subscription;
    const result = new Promise((resolve, reject) => {
      subscription = this.listenToWalletStatus().subscribe({
        next: (status) => {
          if (statuses.includes(status)) {
            resolve(status);
          }
        },
        error: (error) => {
          reject(error);
        },
        complete: () => {
          reject(
            new LightsparkException(
              "WalletStatusAwaitError",
              "Wallet status subscription completed without receiving a status update."
            )
          );
        }
      });
      timeout = setTimeout(() => {
        reject(
          new LightsparkException(
            "WalletStatusAwaitError",
            `Timed out waiting for wallet status to be one of ${statuses.join(
              ", "
            )}.`
          )
        );
      }, timeoutSecs * 1e3);
    });
    return result.finally(() => {
      clearTimeout(timeout);
      subscription.unsubscribe();
    });
  }
  listenToWalletStatus() {
    return this.requester.subscribe(
      `
      subscription WalletStatusSubscription {
        current_wallet {
          status
        }
      }`
    ).map((responseJson) => {
      return WalletStatus_default[responseJson.data.current_wallet.status] ?? WalletStatus_default.FUTURE_VALUE;
    });
  }
  /**
   * Executes a raw `Query` as a subscription and returns an `Observable` that
   * emits the result of the query when it changes.
   *
   * This can only be used with `subscription` operations.
   *
   * @param query The `Query` to execute.
   * @returns A zen-observable that emits the result of the query when it changes.
   */
  subscribeToRawQuery(query) {
    return this.requester.subscribe(query.queryPayload, query.variables).map((responseJson) => {
      return query.constructObject(responseJson.data);
    });
  }
  /**
   * Executes a raw `Query` against the Lightspark API.
   *
   * This generally should not be used directly,
   * but is exposed for advanced use cases and for internal use to retrieve
   * complex fields from objects.
   *
   * @param query The `Query` to execute.
   * @returns The result of the query.
   */
  executeRawQuery(query) {
    return this.requester.executeQuery(query);
  }
};
var WALLET_NODE_ID_KEY = "wallet_node_id";
var WALLET_SDK_ENDPOINT = "graphql/wallet/2023-05-05";
var client_default = LightsparkClient;
export {
  BitcoinNetwork_default as BitcoinNetwork,
  ChromeExtensionLocalTokenStorage_default as ChromeExtensionLocalTokenStorage,
  CurrencyUnit_default as CurrencyUnit,
  CustomJwtAuthProvider_default as CustomJwtAuthProvider,
  GraphNode_default as GraphNode,
  InMemoryTokenStorage_default as InMemoryTokenStorage,
  InvoiceType_default as InvoiceType,
  KeyType_default as KeyType,
  client_default as LightsparkClient,
  NodeAddressType_default as NodeAddressType,
  PaymentFailureReason_default as PaymentFailureReason,
  PaymentRequestStatus_default as PaymentRequestStatus,
  TransactionStatus_default as TransactionStatus,
  TransactionType_default as TransactionType,
  Wallet_default as Wallet,
  WalletStatus_default as WalletStatus,
  WithdrawalMode_default as WithdrawalMode,
  WithdrawalRequest_default as WithdrawalRequest,
  WithdrawalRequestStatus_default as WithdrawalRequestStatus,
  getChannelClosingTransactionQuery,
  getChannelOpeningTransactionQuery,
  getDepositQuery,
  getIncomingPaymentQuery,
  getInvoiceQuery,
  getLightningTransactionQuery,
  getNodeQuery,
  getOnChainTransactionQuery,
  getOutgoingPaymentQuery,
  getPaymentRequestQuery,
  getTransactionQuery,
  getWithdrawalQuery
};
